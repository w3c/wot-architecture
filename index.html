<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Architecture</title>
    <script class="remove" async="" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove">
          var respecConfig = {
              specStatus:     "ED"
            , processVersion: 2017
            , shortName:      "wot-architecture"
            , copyrightStart: 2017
            , wg:             "Web of Things Working Group"
            , wgURI:          "https://www.w3.org/WoT/WG/"
            , wgPublicList:   "public-wot-wg"
            , edDraftURI:     "https://w3c.github.io/wot-architecture/"
            , githubAPI:      "https://api.github.com/repos/w3c/wot-architecture"
            , issueBase:      "https://www.github.com/w3c/wot-architecture/issues"
            , editors: [
                {
                  name:       "Matthias Kovatsch"
                , w3cid:      "75998"
                , company:    "Huawei"
                , companyURL: "https://www.huawei.com/"
                }
              , {
                  name:       "Kazuo Kajimoto"
                , w3cid:      "74112"
                , company:    "Panasonic Corp."
                , companyURL: "https://www.panasonic.com/"
                }
              , {
                  name:       "Ryuichi Matsukura"
                , w3cid:      "64284"
                , company:    "Fujitsu Ltd."
                , companyURL: "https://www.fujitsu.com/"
                }
              , {
                  name:       "Michael Lagally"
                , w3cid:      "47166"
                , company:    "Oracle Corp."
                , companyURL: "https://www.oracle.com/"
                }
              ]
            , otherLinks: [
                {
                  key: "Contributors"
                , data: [
                    {
                      value: "In the GitHub repository"
                    , href: "https://github.com/w3c/wot-architecture/graphs/contributors"
                    }
                  ]
                }
              , {
                  key: "Repository",
                  data: [
                    {
                      value: "We are on GitHub",
                      href: "https://github.com/w3c/wot-architecture/"
                    }
                  , {
                      value: "File a bug",
                      href: "https://github.com/w3c/wot-architecture/issues"
                    }
                  ]
                }
              ]
            , localBiblio: {
                "CoRE-RD" : {
                  href: "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11"
                , title: "CoRE Resource Directory"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "03 July 2017"
                },
                "WOT-SECURITY-CONSIDERATIONS" : {
                  href: "https://www.w3.org/TR/wot-security/",
                  title: "Web of Things Security and Privacy Considerations",
                  publisher: "W3C"
                }
              }
            };
    </script>
  </head>
  <body>
    <section id="abstract">
	    <p class="ednote" title="TODO">
        The text become too long for an effective abstract.
        Text is partly copied from introduction.
        Needs realignment between the two sections.
      <p>
      <p>The W3C Web of Things (WoT) is intended to enable
        interoperability across IoT Platforms and application domains.
        Primarily, it provides mechanisms to formally describe IoT
        interfaces to allow IoT devices and services to communicate with
        each other, independent of their underlying implementation, and
        across multiple networking protocols. Secondarily, it provides a
        standardized way to define and program IoT behavior.</p>
      <p>This document describes the abstract architecture for the W3C
        Web of Things. It is derived from a set of use cases and can be
        mapped onto a variety of concrete deployment scenarios, several
        examples of which are given. This document is focused on the
        standardization scope of W3C WoT, which consists of three
        initial building blocks that are briefly introduced and their
        interplay explained.</p>
      <p>
        An abstract architecture for the Web of Things and a
        functional architecture for
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-servient">Servients</a>
        has been introduced. It is based on WoT building blocks, which
        are described by additional WoT specifications:
      </p>
      <ul>
        <li>
          the
          <a href="https://w3c.github.io/wot-thing-description/">WoT Thing Description</a>
          ,
        </li>
        <li>
          the
          <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a>
          , and
        </li>
        <li>
          the
          <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting API</a>
          .
        </li>
      </ul>
      <p>
        Of these, the
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing-description-td">WoT Thing Description</a>
        is the primary building block, as it
        describes the network-facing interface of a Thing (
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-interface">WoT





          Interface</a>
        ), whether or not it uses
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-binding-templates">WoT





          Binding Templates</a>
        or the
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-scripting-api">WoT





          Scripting API</a>
        internally. The implementation of
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-binding-templates">WoT





          Binding Templates</a>
        results in multiple possible Protocol
        Bindings, so that a
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Thing</a>
        can communicate with different
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-iot-platform">IoT





          Platforms</a>
        (i.e., IoT ecosystems or standards). When a
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Thing</a>
        uses the
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-scripting-api">WoT





          Scripting API</a>
        internally, its application logic can be
        programmed against a standardized contract using JavaScript.
        This way, it simplifies IoT application development and enables
        portability across vendors and WoT network components.
      </p>
      <p>
        The architecture described here applies well to a wide variety
        of different use cases. Based on these, we have described
        serveral scenarios where one or more
        <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-servient">Servients</a>
        were used together to overcome, for instance, limitations on the
        reach of specific communication protocols. These examples are
        not exhaustive and are only meant to illustrate the
        applicability and flexibility of the WoT approach.
      </p>
      <p>Other non-normative architectural blocks and conditions
        underlying the Web of Things are also described in the context
        of deployment scenarios. In particular, recommendations for
        security and privacy are included, while the goal is to preserve
        and support existing device mechanisms and properties. In
        general, W3C WoT is designed to describe what exists rather than
        to prescribe what to implement.</p>
    </section>
    <section id="sotd">
      <p class="ednote" title="The W3C WoT WG is asking for feedback">
        Please contribute to this draft using the
        <a href="https://github.com/w3c/wot-architecture/issues">GitHub
          Issue</a>
        feature of the
        <a href="https://github.com/w3c/wot-architecture/">WoT
          Architecture</a>
        repository. For feedback on security and
        privacy considerations, please use the
        <a href="https://github.com/w3c/wot-security/issues">WoT Security
          and Privacy</a>
        Issues, as they are cross-cutting over all our
        documents.
      </p>
    </section>
    <section>
      <h1>Introduction</h1>
      <p>
        The "Web of Things" (WoT) started as an academic initiative in
        the form of publications and, starting in 2010, a yearly
        <a href="https://webofthings.org/events/">International Workshop
          on the Web of Things</a>
        . Its goal is to improve
        interoperability as well as usability in the Internet of Things
        (IoT). With the increasing role of IoT services using other web
        standards in commercial and industrial applications, the W3C
        chartered an
        <a href="https://www.w3.org/WoT/IG/">Interest
          Group</a>
        in 2015 to identify technological building blocks
        for Recommendation Track standardization. With the WoT
        <a href="https://www.w3.org/WoT/WG/">Working Group</a>
        chartered
        end of 2016, the first set of WoT building blocks is now being
        standardized:
      </p>
      <ul>
        <li>
          the
          <a href="https://w3c.github.io/wot-thing-description/">WoT Thing Description</a>
          ,
        </li>
        <li>
          the
          <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a>
          , and
        </li>
        <li>
          the
          <a href="https://w3c.github.io/wot-scripting-api/">WoT
            Scripting API</a>
          .
        </li>
      </ul>
      <p>This document serves as an umbrella for the W3C WoT draft
        specifications and defines the basics such as terminology and
        the underlying abstract architecture of the W3C Web of Things.
        In particular, the purpose of this document is to provide</p>
      <ul>
        <li>a set of use cases that lead to the W3C WoT Architecture,</li>
        <li>a set of requirements for WoT implementations,</li>
        <li>an overview of the WoT building blocks being standardized
          and their interplay,</li>
        <li>a guideline to map the abstract architecture to software
          stacks and hardware components,</li>
        <li>and security considerations to be aware of when implementing
          WoT building blocks.</li>
      </ul>
    </section>
    <section>
      <h2>Terminology</h2>
      <p>This document uses the following terms as defined here. The
        WoT prefix is used to avoid ambiguity for terms that are defined
        specifically for Web of Things concepts.</p>
      <dl>
        <dt>
          <dfn id="action">Action</dfn>
        </dt>
        <dd>An Interaction Pattern to invoke procedure on a Thing,
          potentially a long running physical process (e.g., lowering of
          window blinds).</dd>
        <dt>
          <dfn id="application">Application</dfn>
        </dt>
        <dd>A running or periodically running process that consumes one
          or more Things (read and processes there data, control their
          state) and/or exposes one or more Things (provide access to
          locally gathered data or computed from consumed Things,
          provide remote control and management interfaces). The
          application can be implemented using the Scripting API or
          native platform APIs. The application may also be distributed
          over multiple Things and other hosts.</dd>
        <dt>
          <dfn id="binding-templates">Binding Templates</dfn>
        </dt>
        <dd>A re-usable collection of blueprints for the communication
          with different IoT platforms. The blueprints includes the
          required vocabulary for the Thing Description to map
          Interactions to platform-specific messages as well as
          implementation notes for the required protocol stacks or
          dedicated communication drivers.</dd>
        <dt>
          <dfn id="client-api">Client API</dfn>
        </dt>
        <dd>Programming interface that allows scripts to access remote
          Things over the network, local Things in a different execution
          environment, or directly attached hardware (which is
          abstracted as Things).</dd>
        <dt>
          <dfn id="to-consume-a-thing">to consume a Thing</dfn>
        </dt>
        <dd>To read in a Thing Description and create a Consumed Thing
          software object for the application in the local runtime
          environment.</dd>
        <dt>
          <dfn id="consumed-thing">Consumed Thing</dfn>
        </dt>
        <dd>A software object instance created through the WoT object of
          the Scripting API that represents a remote Thing used by the
          local application. It is defined by the ConsumedThing
          interface of the WoT Scripting API.</dd>
        <dt>
          <dfn id="discovery-api">Discovery API</dfn>
        </dt>
        <dd>Programming interface that allows scripts to discover other
          Things (local, nearby, or remote).</dd>
        <dt>
          <dfn id="domain-specific-vocabulary">Domain-specific
            vocabulary</dfn>
        </dt>
        <dd>Linked Data vocabulary that can be used in the WoT Thing
          Description, but is not defined by W3C WoT.</dd>
        <dt>
          <dfn id="event">Event</dfn>
        </dt>
        <dd>An Interaction Pattern to subscribe to data pushed by a WoT
          Server. These can be stand-alone events such as an alarm,
          change-of-value notifications, or time series of data.</dd>
        <dt>
          <dfn id="execution-environment">Execution Environment</dfn>
        </dt>
        <dd>A sandbox within the Runtime that isolates scripts running
          on the same Servient.</dd>
        <dt>
          <dfn id="to-expose-a-thing">to expose a Thing</dfn>
        </dt>
        <dd>To create an Exposed Thing software object in the local
          runtime environment that enables the application to provide
          local state and calls as Interactions over the network.</dd>
        <dt>
          <dfn id="exposed-thing">Exposed Thing</dfn>
        </dt>
        <dd>A software object instance created through the Server API
          that is implemented locally and can be accessed over the
          network by remote WoT Clients. It is defined by the
          ExposedThing interface of the WoT Scripting API.</dd>
        <dt>
          <dfn id="interaction">Interaction</dfn>
        </dt>
        <dd>A functionality exposed by Thing that is defined by the TD
          Interaction Model.</dd>
        <dt>
          <dfn id="interaction-model">Interaction Model</dfn>
        </dt>
        <dd>A formal model that syntactically and semantically maps
          different network-facing interfaces (i.e., WoT Interfaces) to
          application-facing interfaces (e.g., the Scripting API -- note
          that these can also be proprietary APIs when not implementing
          the WoT Runtime). The Thing Description is built around this
          model and connects it to Link Data vocabularies.</dd>
        <dt>
          <dfn id="interaction-pattern">Interaction Pattern</dfn>
        </dt>
        <dd>A default solution to describe common Interactions:
          Property, Action, and Event.</dd>
        <dt>
          <dfn id="iot-platform">IoT platform</dfn>
        </dt>
        <dd>A specific IoT ecosystem such as OCF, oneM2M, or Mozilla
          Project Things with its own specifications for
          application-facing APIs, data model, and protocols or protocol
          configurations.</dd>
        <dt>
          <dfn id="local-discovery">Local Discovery</dfn>
        </dt>
        <dd>A discovery method that can discover Things directly
          connected to a Servient (e.g., sensor or actuator that is
          abstracted as Thing).</dd>
        <dt>
          <dfn id="manual-discovery">Manual Discovery</dfn>
        </dt>
        <dd>A discovery method where the URI of the used consumed Thing
          Descriptions is provided manually (e.g., through user
          configuration or hard-coding in a script).</dd>
        <dt>
          <dfn id="nearby-discovery">Nearby Discovery</dfn>
        </dt>
        <dd>A discovery method where the physical location is considered
          (e.g., BLE, Audio Watermarking, ...).</dd>
        <dt>
          <dfn id="network-discovery">Network Discovery</dfn>
        </dt>
        <dd>A discovery method that can discover Things in local
          networks (e.g. SSDP, mDNS/DNS-SD, ...).</dd>
        <dt>
          <dfn id="property">Property</dfn>
        </dt>
        <dd>An Interaction Pattern to read a specific value of a Thing
          and optionally to write it.</dd>
        <dt>
          <dfn id="protocol-binding">Protocol Binding</dfn>
        </dt>
        <dd>An implementation of the mapping between Interaction in the
          TD Interaction Model (e.g., Property read) and specific
          operations of a protocol (e.g., HTTP GET).</dd>
        <dt>
          <dfn id="remote-discovery">Remote Discovery</dfn>
        </dt>
        <dd>A discovery method which supports lookup of remote Things
          also beyond network boundaries, for instance by using a
          directory service. The endpoint of the directory must be
          supported.</dd>
        <dt>
          <dfn id="scripting-api">Scripting API</dfn>
        </dt>
        <dd>The application-facing programming interface provided by a
          Servient; comparable to the Web browser APIs.</dd>
        <dt>
          <dfn id="server-api">Server API</dfn>
        </dt>
        <dd>Programming interface that allows scripts to expose local
          functionality as Things to WoT Clients.</dd>
        <dt>
          <dfn id="servient">Servient</dfn>
        </dt>
        <dd>A software stack that implements the WoT building blocks. A
          Servient can host and expose Things (server role) and/or
          consume Things (client role). Servients usually have multiple
          Protocol Bindings to enable interaction with different
          platforms.</dd>
        <dt>
          <dfn id="td">TD</dfn>
        </dt>
        <dd>Short for Thing Description.</dd>
        <dt>
          <dfn id="td-vocabulary">TD Vocabulary</dfn>
        </dt>
        <dd>A controlled Linked Data vocabulary by W3C WoT to tag the
          metadata of Things in the WoT Thing Description including
          communication metadata of WoT Binding Templates.</dd>
        <dt>
          <dfn id="thing">Thing</dfn>
        </dt>
        <dd>An abstraction of a physical or virtual entity whose
          metadata and interfaces are described by a WoT Thing
          Description. This entity can be an existing device augmented
          with a Thing Description, a logical component of a device that
          has a software stack that natively provides Thing Descriptions
          (see Servient), a local hardware component of a Servient, or a
          logical entity (e.g., location) that does not directly provide
          any software stack such as a room or building.</dd>
        <dt>
          <dfn id="thing-description-td">Thing Description (TD)</dfn>
        </dt>
        <dd>Structured data describing a Thing. A TD includes metadata,
          domain-specific metadata, a list of offered interactions, the
          supported protocol bindings for each interaction, and links to
          related Things. The Thing Description is built around a formal
          Interaction Model.</dd>
        <dt>
          <dfn id="thing-directory">Thing Directory</dfn>
        </dt>
        <dd>
          A directory service for TDs that provides a Web interface to
          register TDs (see
          <a href="https://tools.ietf.org/html/draft-ietf-core-resource-directory">draft-ietf-core-resource-directory</a>
          )
          and look them up (e.g., using SPARQL queries or CoRE Link
          Format).
        </dd>
        <dt>
          <dfn id="wot-client">WoT Client</dfn>
        </dt>
        <dd>An entity that can connect with a network interface
          described by a WoT Thing Description (i.e., consume a Thing).
          WoT Clients usually implement multiple Protocol Bindings. WoT
          Client is also used to refer to a Servient in client role
          only.</dd>
        <dt>
          <dfn id="wot-interface">WoT Interface</dfn>
        </dt>
        <dd>The network-facing interface of a Thing as defined by its
          Thing Description.</dd>
        <dt>
          <dfn id="wot-object">WoT Object</dfn>
        </dt>
        <dd>The WoT object is the Scripting API entry point within a WoT
          Runtime. It provides methods to discover, consume, and expose
          Things.</dd>
        <dt>
          <dfn id="wot-runtime">WoT Runtime</dfn>
        </dt>
        <dd>A runtime system for application scripts with the WoT
          Scripting API. Implementing a WoT Runtime is optional for
          Servients.</dd>
        <dt>
          <dfn id="wot-server">WoT Server</dfn>
        </dt>
        <dd>An entity that exposes a network interface consistent with a
          WoT Thing Description. WoT Server is also used to refer to a
          Servient in server role only.</dd>
        <dt>
          <dfn id="coap">CoAP</dfn>
        </dt>
        <dd>Acronym for Constrained Application Protocol [RFC7252]</dd>
        <dt>
          <dfn id="cwt">CWT</dfn>
        </dt>
        <dd>CBOR Web Token</dd>
        <dt>
          <dfn id="json-ld">JSON-LD</dfn>
        </dt>
        <dd>
          A JSON document that is augmented with support for Linked
          Data by providing an
          <code>@context</code>
          property with a
          defining URI
          <a href="https://www.w3.org/TR/json-ld/">JSON-LD</a>
          .
        </dd>
        <dt>
          <dfn id="jwt">JWT</dfn>
        </dt>
        <dd>JSON Web Token [RFC7519]</dd>
        <dt>
          <dfn id="rdf">RDF</dfn>
        </dt>
        <dd>
          The Resource Description Framework (RDF) of the Semantic Web
          <a href="https://www.w3.org/TR/rdf11-concepts/">rdf11-concept</a>
        </dd>
      </dl>
      <p class="ednote" title="Additional Terms">TODO: add missing terms, such as WoT, WoT Containers, MQTT, TD
          manager</p>
    </section>
    <!--  USE CASES -->
    <section id="sec-use-cases" class="informative">
      <h1>Use Cases</h1>
      <p>
        This section presents the application domains and use cases
        targeted by the W3C WoT and which are used to derive the
        abstract architecture discussed in
        <span style="color:red">TODO:
          add link</span>
        . While Smart Home use cases might appear
        predominant in this section, they should be seen as simply a
        vehicle to identify fundamental requirements inherent to most
        application domains. The Smart Home domain is suitable for
        identifying such general requirements, as most stakeholders can
        relate to it.
      </p>
      <section>
        <h2>Application Domains</h2>
        <section>
          <h3>Consumer</h3>
          <p class="ednote" title="Home Application Domain">TODO: add language describing scenarios of the consumer domain</p>
        </section>
        <section id="industrialiotusecases">
          <h3>Industrial</h3>
          <p>
            The industrial use cases in this section are applicable to
            different industry verticals.
            <br />
            Due to the nature of overlaps in the application scenarios,
            different verticals have similar use cases.
          </p>
          <p>shows an example of a Smart Factory. In this case, cell
          controllers automate factory equipment with specialized
          communication such as RS-485 or EtherCAT. Line controllers
          orchestrate multiple cell controllers over IP-based networks.
          A factory controller integrates different line controllers. A
          cloud service collects data from the factory controller and
          analyzes them for predictive maintenance. Users can monitor
          the factory through a dashboard. Note that factories usually
          do not reveal the internal topology of their lines and cells.</p>
          <figure id="smart-factory">
            <img src="images/smart-factory.png" style="width: 640px;" />
            <figcaption>Smart Factory</figcaption>
          </figure>
          <h4 id="manufacturing">Manufacturing</h4>
          <h5 id="predictivemaintenance">Predictive Maintenance</h5>
          <p>Monitoring and predicting machine failures and anomalies.</p>
          <h5 id="maintenanceautomation">Maintenance automation</h5>
          <p>Automating the process of creating a maintenance/service
            ticket based on reactive or predictive detection of
            problems.</p>
          <h5 id="qualityimprovements">Quality Improvements</h5>
          <p>Improving quality through monitoring the condition of
            manufacturing equipment.</p>
          <h5 id="industrialsafety">Industrial safety</h5>
          <p>Reducing industrial safety incidents/accidents.</p>
          <h5 id="environmentmonitoring">Environment monitoring</h5>
          <p>Monitoring environment in the manufacturing plant for
            presence of poisonous gases, excessive noise/heat, etc.</p>
          <h5 id="realtimemonitoring">Real-time monitoring</h5>
          <p>Real-time monitoring and KPI calculations of production
            equipment.</p>
          <h4 id="transportationlogistics">Transportation &amp;
            Logistics</h4>
          <h5 id="shipmenttracking">Shipment tracking</h5>
          <p>Tracking of shipment en-route - condition, quality and
            location monitoring.</p>
          <h5 id="fleettracking">Fleet tracking</h5>
          <p>Monitoring fleet vehicles, fuel costs, maintenance needs,
            assignments.</p>
          <h5 id="coldchainmonitoring">Cold chain monitoring</h5>
          <p>Ensuring integrity of the cold chain - from warehouses to
            refrigerated trucks to delivery.</p>
          <h5 id="warehousemonitoring">Warehouse monitoring</h5>
          <p>Monitoring equipment and stock in warehouses, yards.</p>
          <h4 id="utilities">Utilities</h4>
          <h5 id="advancedmeteringinfrastructure">Advanced Metering
            Infrastructure</h5>
          <p>Automated reading of residential and C&amp;I (Commercial
            and Industrial) meters, and billing.</p>
          <h5 id="distributedenergyresourcemanagement">Distributed
            Energy Resource management</h5>
          <p>Monitoring the condition and output of distributed
            renewable energy generation equipment.</p>
          <h5 id="distributionautomation">Distribution Automation</h5>
          <p>Monitoring and remote-controlling Distribution equipment.</p>
          <h5 id="crewsafety">Crew safety</h5>
          <p>Improving safety of utilities crew in the field.</p>
          <h4 id="oilandgas">Oil and Gas</h4>
          <h5 id="pipelinemonitoring">Pipeline monitoring</h5>
          <p>Offshore platform monitoring Industrial safety on offshore
            platforms.</p>
          <h5 id="leakagedetection">Leakage detection</h5>
          <p>Detecting/Predicting leakage through the pipelines.</p>
          <h5 id="tankreservoirlevelmonitoring">Tank/Reservoir level
            monitoring</h5>
          <p>Monitoring and Controlling the levels in tanks and
            reservoirs.</p>
          <h5 id="automatedstocktaking">Automated Stock Taking</h5>
          <p>Automated calculation of a distributed stock through
            various storage tanks and delivery pipes/trucks.</p>
          <h4 id="insurance">Insurance</h4>
          <h5 id="proactiveassetmonitoring">Proactive Asset Monitoring</h5>
          <p>Monitoring of high value assets such as connected
            structures, fleet vehicles, etc.</p>
          <h5 id="usagebasedinsurance">Usage based insurance</h5>
          <p>Usage tracking and customized insurance policies.</p>
          <h5 id="safetymonitoring">Safety monitoring</h5>
          <p>Employee/Occupant safety monitoring.</p>
          <h5 id="lossreductionleakagedetection">Loss reduction -
            leakage detection</h5>
          <p>Detecting leakages to limit the losses.</p>
          <h5 id="losspreventiongaragingfleetvehicles">Loss prevention -
            garaging fleet vehicles</h5>
          <p>Predictive weather monitoring and re-routing fleet vehicles
            to covered garages to limit loss due to hail damage, tree
            damage.</p>
          <h4 id="engineeringandconstruction">Engineering and
            Construction</h4>
          <h5 id="workersafety">Worker Safety</h5>
          <p>Worker monitoring for industrial safety.</p>
          <h5 id="constructionassetmonitoring">Construction Asset
            Monitoring</h5>
          <p>Monitoring assets at construction site.</p>
        </section>
        <section id="smart buildings">
          <h3 id="smartbuildings">Smart Buildings</h3>
          <h4 id="energymanagement">Energy management</h4>
          <p>Monitoring energy usage throughout the building.</p>
          <h4 id="equipmentmonitoringoccupantsatisfaction">Equipment
            monitoring, Occupant satisfaction</h4>
          <p>Monitoring equipment in the buildings such as HVAC,
            Elevators, etc. Monitoring satisfaction of occupants.</p>
        </section>
        <section id="connected car">
          <h3 id="connectedcar">Connected Car</h3>
          <p>shows an example of a Connected Car. In this case, a gateway
          connects to car components through CAN and to the car
          navigation system through a proprietary interface. Services
          running in the cloud collect data pushed from car components
          and analyze the data from multiple cars to determine traffic
          patterns. The gateway can also consume cloud services, in this
          case, to get traffic data and show it to the driver through
          the car navigation system.</p>
          <figure id="connected-car">
            <img src="images/connected-car.png" style="width: 500px;" />
            <figcaption>Connected Car</figcaption>
          </figure>
          <h4 id="operationmonitoring">Operation monitoring</h4>
          <p>Monitoring of operation status, prediction of service
            needs, optimisation of maintenance.</p>
          <h4 id="driversafety">Driver Safety</h4>
          <p>Enhance driver safety with notifications of an early
            warning system for critical road and traffic conditions.</p>
        </section>
        <section id="agriculture">
          <h3 id="agriculture">Agriculture</h3>
          <h4 id="soilconditionmonitoring">Soil condition monitoring</h4>
          <p>Monitoring soil conditions and creating optimal plans for
            watering, fertilizing.</p>
          <h4 id="producemonitoring">Produce monitoring</h4>
          <p>Monitoring produce conditions.</p>
        </section>
        <section id="healthcare">
          <h3 id="healthcare">Healthcare</h3>
          <h4 id="clinicaltrials">Clinical Trials</h4>
          <p>Data collection and analytics of clinical trial data.</p>
          <h4 id="pharmaceuticalmonitoring">Pharmaceutical monitoring</h4>
          <p>Monitoring of medicines and totes throughout the supply
            chain.</p>
          <h4 id="remotepatientmonitoring">Remote Patient Monitoring</h4>
          <p>Monitoring of patients after hospitalization.</p>
        </section>
        <section id="smart cities">
          <h3 id="smartcities">Smart Cities</h3>
          <h4 id="infrastructuremonitoring">Infrastructure monitoring</h4>
          <p>Monitoring of Bridges, Dams, Levees, Canals - material
            condition, deterioration, vibrations monitoring.</p>
          <h4 id="smartparking">Smart Parking</h4>
          <p>Tracking usage, availability of parking spaces and
            automating billing/reservations.</p>
          <h4 id="smartlighting">Smart Lighting</h4>
          <p>Smart control of street lights based on presence detection,
            weather predictions, etc.</p>
          <h4 id="wastemanagement">Waste Management</h4>
          <p>Monitoring of garbage containers to optimize the trash
            collection route.</p>
          <h4 id="highwaymonitoring">Highway Monitoring</h4>
          <p>Monitoring of highways and providing appropriate signage.</p>
        </section>
        <section>
          <h3 id="environmentmonitoring-1">Environment Monitoring</h3>
          <h4 id="airandwaterpollution">Air and water pollution</h4>
          <p>Monitoring of air pollution, water pollution and other
            environmental risk factors such as fine dust, ozone,
            volatile organic compound, radioactivity, temperature,
            humidity to detect critical environment conditions.</p>
          <h4 id="disasterpredictionandprevention">Disaster prediction
            and prevention</h4>
          <p>Analysis of sensor data from distributed sensors to detect
            anomalies and predict critical environment conditions.</p>
        </section>
      </section>
      <section id="commonusecasespatterns">
        <h2>Common Patterns</h2>
        <section>
          <h3>Device Controllers</h3>
          <p>
            The first use case is a local device controlled by
            user-operated remote controller as depicted in
            <span style="color:red">TODO</span>
            . For
            example, an electronic appliance such as an air conditioner
            with Web server functionality might be connected directly to
            a local home network. A remote controller can access the air
            conditioner through the local home network directly. In this
            case, the remote controller can be realized by a browser or
            native application.
          </p>
          <figure id="smart-home-deive">
            <img src="images/smart-home-device.png" style="width: 500px;" />
            <figcaption>Device Control</figcaption>
          </figure>
        </section>
        <section>
          <h3>Thing-to-Thing</h3>
          <p>shows an example of direct Thing-to-Thing interaction. The
            scenario is as follows: when a sensor detects the room
            temperature is surpassing a set threshold (e.g., 25°C), a
            control agent issues a "power-on" command to an air
            conditioner.</p>
          <figure id="smart-home-t2t">
            <img src="images/smart-home-t2t.png" style="width: 500px;" />
            <figcaption>Control Agent</figcaption>
          </figure>
        </section>
        <section>
          <h3>Remote Access</h3>
          <p class="ednote" title="TODO">Must rewrite for remote access/control use case. Include changing uplink connectivity.</p>
          <p>The third use case is a mobile remote controller (e.g., on
            a smartphone) as shown in . When at home, the smartphone can
            use Wi-Fi or Bluetooth/BLE to control an electronic
            appliance locally, while outside, it can use the cellular
            network.</p>
          <figure id="smart-home-multi">
            <img src="images/smart-home-multi.png" style="width: 500px;" />
            <figcaption>Multiple Network Interfaces</figcaption>
          </figure>
        </section>
        <section>
          <h3>Multiple Subsystems</h3>
          <p class="ednote" title="TODO">Pattern from consumer (ZigBee, Bluetooth, and WiFi in home), industrial (multiple fieldbusses), connected car, and more.</p>
        </section>
        <section>
          <h3>Gateways</h3>
          <p class="ednote" title="TODO">Must rewrite for local box/compute node use case.</p>
          <p>shows a use case based on a Smart Home gateway. It is
            placed between a home network and the Internet. The gateway
            manages electronic appliances inside the house and can
            receive commands from a remote controller over the Internet,
            e.g., from a smartphone as in the previous use case.</p>
          <figure id="smart-home-gateway">
            <img src="images/smart-home-gateway.png" style="width: 500px;" />
            <figcaption>Smart Home Gateway</figcaption>
          </figure>
        </section>
        <section>
          <h3>Cloud Proxies</h3>
          <p class="ednote" title="TODO">Explain cloud proxy.</p>
          <p>Cloud proxies can be realized in different ways:</p>
          <p class="ednote">The complexity of the use cases here
            increases too quickly. They will be split up to
            progressively add and explain each new feature.</p>
        </section>
        <section>
          <h4>Cloud-ready Devices</h4>
          <p>shows an example where electronic appliances are
              connected directly to the cloud. The cloud mirrors the
              appliances and, acting as a proxy, can receive commands
              from remote controllers (e.g., a smartphone). Authorized
              controllers can be located anywhere, as the proxy is
              globally reachable.</p>
          <figure id="smart-home-cloud1">
            <img src="images/smart-home-cloud1.png" style="width: 500px;" />
            <figcaption>Proxies with Cloud-ready Devices</figcaption>
          </figure>
        </section>
        <section>
          <h3>Legacy Devices</h3>
          <p class="ednote" title="TODO">Check terminology, here agent.</p>
          <p>shows an example where legacy electronic appliances
              cannot directly connect to the cloud. Here, a gateway is
              needed to relay the connection. The gateway works as:</p>
          <ul>
            <li>integrator of a variety of legacy communication
                protocols both in the physical and logical view</li>
            <li>firewall toward the Internet</li>
            <li>privacy filter which substitutes real image and/or
                speech, and logs data locally</li>
            <li>local agent in case the Internet connection is
                interrupted</li>
            <li>emergency services running locally when fire alarms
                and similar events occur</li>
          </ul>
          <p>The cloud mirrors the gateway with all connected
              appliances and acts as an agent that manages them in the
              cloud in conjunction with the gateway. Furthermore, the
              cloud can receive commands from remote controllers (e.g.,
              a smartphone), which can be located anywhere.</p>
          <figure id="smart-home-cloud2">
            <img src="images/smart-home-cloud2.png" style="width: 500px;" />
            <figcaption>Proxies with Legacy Devices</figcaption>
          </figure>
        </section>
        <section>
          <h3>Cross-domain Collaboration</h3>
          <p>
            show an example of a Cross-domain collaboration. In this
            case, each system involves other systems in other domains,
            such as Smart Factrory with Smart City, Smart City with Smart
            Home. This type of system is called
            <a href="https://www.iec.ch/whitepaper/pdf/iecWP-futurefactory-LR-en.pdf">"Symbiotic" ecosystem</a>
            . There are two collaboration models: direct
            collaboration and indirect collaboration. In the direct
            collaboration model, systems exchange their own information
            directly with each other in peer-to-peer manner. In the
            indirect collaboration, systems exchange their own information
            via some collaboration platform. In order to maintain and
            continue this collaboration, each system provide the metadata
            of their ability and interfaces and adopt itself to others.
          </p>
          <figure id="cross-domain">
            <img src="images/cross-domain-direct.png" style="width: 500px;" />
            <img src="images/cross-domain-indirect.png" style="width: 500px;" />
            <figcaption>Cross-domain collaboration</figcaption>
          </figure>
        </section>
      </section>
      <section>
        <h2>Summary</h3>
        <p class="ednote" title="TODO">
          The following figure has to be simplified to only show the abstract patterns
          without the implementation and WoT details (inside the gray boxes).
          Instead, common patterns can be listed at the corresponding places.
        </p>
        <figure id="architecture-abstract">
          <img src="images/architecture-abstract.png" style="width: 100%;" />
          <figcaption>Use Case Overview</figcaption>
        </figure>
      </section>
    </section>
    <section id="sec-requirements" class="informative">
      <h1>Requirements</h1>
      <p class="ednote" title="TODO">
        The requirements have to be reviewed, partly merged, and sorted into
        the proper category (functional vs technical).
      </p>
      <section>
        <h2>Functional Requirements</h2>
        <p>This section defines the properties required in an abstract
        Web of Things (WoT) architecture.</p>
        <section id="sec-requirements-principles">
          <h3>Common Principles</h3>
          <ul>
            <li>WoT architecture should enable mutual interworking of
            different eco-systems using web technology.</li>
            <li>WoT architecture should be based on the web architecture
            using RESTful APIs.</li>
            <li>WoT architecture should allow to use multiple payload
            formats which are commonly used in the web.</li>
            <li>
              Flexibility
              <p>There are a wide variety of physical device configurations
          for WoT implementations. The WoT abstract architecture should
          be able to be mapped to and cover all of the variations.</p>
            </li>
            <li>
              Compatibility
              <p>We already have many existing IoT solutions and ongoing IoT
          standardization activities in many business fields. The WoT
          should provide a bridge between these existing and developing
          IoT solutions and Web technology based on WoT concepts. The
          WoT should be upwards compatible with existing IoT solutions
          and current standards.</p>
            </li>
          </ul>
        </section>
        <section id="sec-requirements-thing-functionalities">
          <h3>Thing functionalities</h3>
          <ul>
            <li>
              WoT architecture should allow thing's to have
            functionalities such as
              <ul>
                <li>reading thing's status information</li>
                <li>updating thing's status information which might cause
                actuation</li>
                <li>subscribing to, receiving and unsubscribing to the
                notification of the change of thing's status
                information.</li>
                <li>invoking functions with input and output parameters
                which would cause certain actuation or calculation.</li>
                <li>subscribing to, receiving and unsubscribing to the
                notification which does not directly relate to thing's
                status information.</li>
              </ul>
            </li>
          </ul>
        </section>
        <section id="sec-requirements-search-and-discovery">
          <h3>Search and discovery</h3>
          <ul>
            <li>WoT architecture should allow clients to know thing's
            attributes, functionalities and their access points, prior
            to access to the thing itself.</li>
            <li>WoT architecture should allow clients to search things by
            its attributes and functionalities.</li>
            <li>WoT architecture should allow semantic search of its
            functionalities based on unified vocabulary, regardless of
            naming of its functionalities.</li>
          </ul>
        </section>
        <section id="sec-requirements-description-mechanism">
          <h3>Description mechanism</h3>
          <ul>
            <li>WoT architecture should support common description
            mechanism which enables describing things and their
            functions.</li>
            <li>Such description should be not only human-readable, but
            also machine-readable.</li>
            <li>Such description should allow semantic annotation of its
            structure and described contents.</li>
            <li>Such description should be able to be exchanged using
            multiple formats which are commonly used in the web.</li>
          </ul>
        </section>
        <section id="sec-requirements-description-of-attributes">
          <h3>Description of attributes</h3>
          <ul>
            <li>
              WoT architecture should allow describing thing's
            attributes such as
              <ul>
                <li>name</li>
                <li>explanation</li>
                <li>version of spec, format and description itself</li>
                <li>links to other related things and information</li>
              </ul>
            </li>
            <li>Such description should support internationalization.</li>
          </ul>
        </section>
        <section id="sec-requirements-description-of-functionalities">
          <h3>Description of functionalities</h3>
          <ul>
            <li>WoT architecture should allow describing thing's
            functionalities which is shown in ## Thing functionalities</li>
          </ul>
        </section>
        <section id="sec-requirements-network">
          <h3>Network</h3>
          <ul>
            <li>WoT architecture should support multiple web protocols
            which are commonly used.</li>
            <li>Such protocols include 1)protocols commonly used in the
            internet and 2)protocols commonly used in the local area
            network</li>
            <li>WoT architecture should allow using multiple web protocols
            to access to the same functionality.</li>
            <li>WoT architecture should allow using mixture of multiple
            protocols to the functionalities of the same thing (e.g.
            HTTP and WebSocket).</li>
          </ul>
        </section>
        <section id="sec-requirements-deployment">
          <h3>Deployment</h3>
          <ul>
            <li>WoT architecture should support wide variety of thing
            capability such as edge devices with resource restrictions
            and virtual things on the cloud, based on the same model.</li>
            <li>WoT architecture should support multiple levels of thing
            hierarchy with intermediate entities such as gateways and
            proxies.</li>
            <li>WoT architecture should support accessing things in the
            local network from the outside of the local network (the
            internet or other local network), considering network
            address translation.</li>
          </ul>
        </section>
        <section id="sec-requirements-application">
          <h3>Application</h3>
          <ul>
            <li>WoT architecture should allow describing applications on
            the wide variety of things such as edge device, gateway,
            cloud and UI/UX device, using web standard technology based
            on the same model.</li>
          </ul>
        </section>
        <section id="sec-requirements-legacy-adaption">
          <h3>Legacy adaption</h3>
          <ul>
            <li>WoT architecture should allow mapping of legacy IP and
            non-IP protocols to web protocols, supporting wide variety
            of hierarchy, where such legacy protocols are terminated and
            translated.</li>
            <li>WoT architecture should allow transparent use of existing
            IP protocols without translation, which follow RESTful
            architecture.</li>
          </ul>
        </section>
      </section>
      <section id="sec-technical-requirements">
        <h2>Technical Requirements</h2>
        <p>
          The previous section delineated the Web of Things abstract
          architecture by showing various use cases and enumerating
          patterns for combining architectural components. This section
          describes technical requirements derived from the abstract
          architecture.
        </p>
        <section>
          <h3>Components consisting Web of Things and the Web of Things architecture</h3>
          <p>Observation of the use cases shows that basic components
          such as devices, applications that access and control those
          devices, proxies (e.g. gateways and platforms) that sit
          between devices and applications to link them together,
          directories that provides device search functionality are
          required.</p>
          <p>Those components are connected to the internet or field
          networks in offices, factories or other facilities. Note that
          all components involved may be connected to a single network
          in some cases, however, components can be deployed across
          multiple networks in general.</p>
        </section>
        <section>
          <h3>Devices</h3>
          <p>Access to devices are made based on descriptions of their
          functions and interfaces (i.e. Thing Description). Those
          include general description about devices, information models
          representing functions, transport protocol description for
          operating on information models, and security information, and
          so on.</p>
          <p>General descriptions are about device identifiers (URI) and
          other human readable information. Information models defines
          device attributes, and represent device’s internal settings,
          control functionality and notification functionality. Devices
          that have the same functionality have the same information
          model regardless of the transport protocols used.</p>
          <p>Because many systems based on Web of Things architecture are
          crossing system Domains, vocabularies and meta data (e.g.
          ontologies) used in information models should be commonly
          understood by involved parties. In addition to REST
          transports, PubSub transports are also supported.</p>
          <p>Security information includes descriptions about
          authentication, authorization and secure communications.
          Devices are required to put TDs either inside them or at
          locations external to the devices, and to make TDs accessible
          so that other components can find and access them.</p>
        </section>
        <section>
          <h3>Applications</h3>
          <p>Applications need to generate and utilize program interfaces
          internally based on device descriptions (i.e. TD).</p>
          <p>Applications have to be able to obtain device descriptions
          (i.e. TD) through the network, therefore, need to be able to
          conduct search operation and acquire the necessary TD over the
          network.</p>
        </section>
        <section>
          <h3>Proxying</h3>
          <p>Proxies need to generate program interfaces internally based
          on device descriptions (i.e. TD), and to represent virtual
          devices by using those program interfaces. A proxy then has to
          produce a TD for the virtual device and make it externally
          available.</p>
          <p>Identifiers of virtual devices need to be newly assigned,
          therefore, are different from the original devices. This makes
          sure that virtual devices and the original devices are clearly
          recognized as separate entities. Transport and security
          mechanisms and settings of the virtual devices can be
          different from original devices if necessary. Virtual devices
          are required to have TDs put either inside the proxies or at
          locations external to the proxies, and to make the TDs
          accessible so that other components can find and access them.</p>
        </section>
        <section>
          <h3>Discovery</h3>
          <p>For TDs of devices and virtual devices to be accessible from
          devices, applications and proxies, there needs to be a common
          way to share TDs. Directories can serve this requirement by
          providing functionalities to allow devices and proxies
          themselves automatically or the users to manually register the
          descriptions.</p>
          <p>Descriptions of the devices and virtual devices need to be
          searchable by external entities. Directories have to be able
          to process search operations with search keys such as keywords
          from the general description in the device description or
          information models.</p>
        </section>
        <section>
          <h3>Security</h3>
          <p>Security information related to devices and virtual devices
          needs to be described in device descriptions. This includes
          information for authentication/authorization and payload
          encryptions.</p>
          <p>WoT architecture should support multiple security
          mechanism commonly used in the web, such as Basic, Digest,
          Bearer and OAuth2.0.</p>
        </section>
      </section>
    </section>

    <section id="sec-building-blocks">
      <h1>WoT Architecture</h1>
      <section>
        <h2>Overview</h2>
        <figure id="architecture-abstract">
          <img src="images/architecture-abstract.png" style="width: 100%;" />
          <figcaption>Abstract Architecture of W3C WoT</figcaption>
        </figure>
      </section>
      <section>
        <h2>Architectural Constraints</h2>
        <p class="ednote" title="TODO">URIs, media types, protocols with fixed set of methods (uniform interface)</p>
        <section>
          <h3>Uniform Interface</h3>
          <section>
            <h4>URIs</h4>
            <p>Identify protocols and resources</p>
          </section>
          <section>
            <h4>Media Types and Schemas</h4>
            <p>Identify data formats, potentially augmented by schemas</p>
          </section>
          <section>
            <h4>Known Set of Methods</h4>
            <p>Binding only for protocols with fixed set of methods</p>
          </section>
          <section>
            <h4>Hypermedia Controls</h4>
            <p>Links and Forms</p>
          </section>
        </section>
        <section>
          <h3>Interaction Model</h3>
          <section>
            <h4>Properties</h4>
          </section>
          <section>
            <h4>Actions</h4>
          </section>
          <section>
            <h4>Events</h4>
          </section>
        </section>
      </section>

      <section>
        <h2>Building Blocks</h2>
        <p>This section presents the initial WoT building blocks that
          build up the abstract architecture for the Web of Things. This
          architecture is derived from the use cases in Section and the
          requirements in Section . summarizes the high-level goals and
          requirements and shows the three levels where the WoT building
          blocks can be applied:</p>
        <ul>
          <li>the device level,</li>
          <li>the gateway level (or "edge"), and</li>
          <li>the cloud level.</li>
        </ul>
        
        <p>shows a conceptual view of how a component in the WoT
          Architecture makes use of the WoT building blocks. Each block is
          described in more detail in the following sections.</p>
        <figure id="architecture-concept">
          <img src="images/architecture-concept.png" style="width: 640px;" />
          <figcaption>Conceptional Architecture of the WoT Building Blocks</figcaption>
        </figure>
        <section id="sec-building-blocks-thing">
          <h3>Web Thing</h3>
          <p>
            A
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Thing</a>
            is the abstraction of a physical or virtual entity that needs
            to be represented in IoT applications. This entity can be a
            device, a logical component of a device, a local hardware
            component, or even a logical entity such as a location (e.g.,
            room or building).
          </p>
          <p>
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Things</a>
            provide a network-facing API for interaction (
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-interface">WoT





              Interface</a>
            ) based on a formal model. These
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-interface">WoT





              Interfaces</a>
            are a superset of Web APIs, as
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Things</a>
            can also be available over non-Web protocols such as MQTT or
            ZigBee. The outward-facing
            <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-interface">WoT





              Interface</a>
            is not to be confused with the
            <a href="#user-content-scripting-api">Scripting





              API</a>
            , which is optional and interfaces with application
            scripts inside the software stack of a
            <a href="#user-content-thing">Thing</a>
            .
          </p>
          <p>
            There can be
            <a href="#user-content-thing">Things</a>
            ,
            however, that do not provide a
            <a href="#user-content-wot-interface">WoT





              Interface</a>
            and only consist of metadata that is relevant
            to the application (e.g., the room in which devices are
            located). In W3C WoT however, a
            <a href="#user-content-thing">Thing</a>
            must have a
            <a href="#user-content-thing-description-td">Thing





              Description</a>
            ; therefore, everything that has a
            <a href="#user-content-thing-description-td">Thing





              Description</a>
            is a
            <a href="#user-content-thing">Thing</a>
            .
          </p>
        </section>
        <section id="sec-building-blocks-thing-description">
          <h3>WoT Thing Description</h3>
          <p>
            The
            <a href="https://w3c.github.io/wot-thing-description/">WoT





              Thing Description</a>
            (TD) is structured data that adheres
            to a formal model and closes the gap between Linked Data
            vocabularies and functional APIs of IoT systems. It can be
            seen as the "HTML for Things". A
            <a href="#user-content-td">TD</a>
            provides general metadata of a
            <a href="#user-content-thing">Thing</a>
            as well as metadata about the
            <a href="#user-content-interaction">Interactions</a>
            ,
            data model, communication, and security mechanisms of a
            <a href="#user-content-thing">Thing</a>
            .
            Usually,
            <a href="#user-content-td">TDs</a>
            make use of domain-specific metadata for which WoT provides
            explicit extension points. However, any
            <a href="#user-content-domain-specific-vocabulary">domain-specific





              vocabulary</a>
            is out-of-scope of the W3C standardization
            activity.
          </p>
          <p>
            The
            <a href="#user-content-thing-description-td">WoT





              Thing Description</a>
            is built around a formal
            <a href="#user-content-interaction-model">Interaction





              Model</a>
            that can support multiple messaging paradigms
            (i.e, request-response, publish-subscribe, and message
            passing). The default
            <a href="#user-content-interaction-pattern">Interaction





              Patterns</a>
            are
            <a href="#user-content-property">Property</a>
            ,
            <a href="#user-content-action">Action</a>
            ,
            and
            <a href="#user-content-event">Event</a>
            .
            These were found to be able to cover the network-facing APIs
            provided by most IoT Platforms.
            <a href="#user-content-property">Properties</a>
            abstract data points that can be read and often written.
            <a href="#user-content-action">Actions</a>
            abstract invokable processes that may run for a certain time;
            yet they can also abstract RPC-like interactions in general.
            <a href="#user-content-event">Events</a>
            abstract interactions where the remote endpoint pushes data
            asynchronously.
          </p>
          <p>
            <a href="#user-content-thing-description-td">Thing





              Descriptions</a>
            are serialized to JSON-LD [[!JSON-LD]] by
            default. More serialization formats are planned in the future,
            in particular more concise formats for resource-constrained
            <a href="#user-content-thing">Things</a>
            .
            For now, JSON-LD offers a good trade-off between
            machine-understandable semantics and usability for developers.
          </p>
          <p>
            <a href="#user-content-thing-description-td">Thing





              Descriptions</a>
            can be managed in
            <a href="#user-content-thing-directory">Thing





              Directories</a>
            , which are aligned with the CoRE Resource
            Directory [[CoRE-RD]]. They provide a Web interface for
            registration, registration updates, and removal, and automatic
            removal after a given lifetime expired without registration
            update.
            <a href="#user-content-thing-directory">Thing





              Directories</a>
            also provide a Web interface for lookups,
            usually including a SPARQL endpoint for semantic queries in
            addition to simple CoRE Resource Directory [[CoRE-RD]]
            lookups.
          </p>
          <p>
            The
            <a href="#user-content-thing-description-td">WoT





              Thing Description</a>
            fosters interoperability in two ways:
            First, and foremost,
            <a href="#user-content-td">TDs</a>
            enable machine-to-machine communication in the Web of Things.
            Second,
            <a href="#user-content-td">TDs</a>
            can serve as a common, uniform format for developers to
            document and retrieve all details necessary to access IoT
            devices and make use of their data.
          </p>
        </section>
        <section id="sec-building-blocks-binding-templates">
          <h3>WoT Binding Templates</h3>
          <p>
            A great challenge for the WoT is to enable interactions with
            a myriad of different IoT Platforms (e.g., OCF, oneM2M,
            RESTful devices not following any particular standard but
            providing an HTTP or CoAP interface, etc.). The IoT uses a
            variety of protocols for accessing devices, since no one
            protocol is appropriate in all contexts. W3C WoT is tackling
            this variety by including communication metadata in the
            <a href="#user-content-thing-description-td">Thing





              Description</a>
            . This metadata can be used to configure the
            communication stack to produce compliant messages for a wide
            variety of target
            <a href="#user-content-iot-platform">IoT





              Platforms</a>
            and protocols.
          </p>
          <p>
            The
            <a href="https://w3c.github.io/wot-binding-templates/">WoT





              Binding Templates</a>
            are an informal collection of
            communication metadata blueprints that explain how to interact
            with different
            <a href="#user-content-iot-platform">IoT





              Platforms</a>
            . When creating a
            <a href="#user-content-thing-description-td">Thing





              Description</a>
            for a particular device, the
            <a href="#user-content-binding-templates">Binding





              Template</a>
            for the corresponding
            <a href="#user-content-iot-platform">IoT





              Platform</a>
            can be used and instantiated in the
            <a href="#user-content-thing-description-td">Thing





              Description</a>
            for that device.
          </p>
          <figure id="binding-templates">
            <img src="images/binding-templates.png" style="width: 800px;" />
            <figcaption>From





              Binding Templates to Protocol Bindings</figcaption>
          </figure>
          <p>
            shows how
            <a href="#user-content-binding-templates">Binding





              Templates</a>
            are applied. A
            <a href="#user-content-binding-templates">WoT





              Binding Template</a>
            is created only once for each
            <a href="#user-content-iot-platform">IoT





              Platform</a>
            and then instantiated, and hence reused in all
            <a href="#user-content-td">TDs</a>
            for its devices. The
            <a href="#user-content-wot-client">WoT





              Client</a>
            consuming that
            <a href="#user-content-td">TD</a>
            must implement the corresponding
            <a href="#user-content-protocol-binding">Protocol
              Binding</a>
            to be able to interact with the
            <a href="#user-content-thing">Thing</a>
            described. The communication metadata of a Binding spans four
            dimensions:
          </p>
          <ul>
            <li>
              <b>IoT Platform:</b>
              <a href="#user-content-iot-platform">IoT
                Platforms</a>
              often introduce proprietary tweaks to
              protocols such as platform-specific HTTP header fields or
              CoAP options. This spans another dimension within the
              transfer protocol used. Usually, these tweaks can be
              described with standard
              <a href="#user-content-td-vocabulary">TD
              Vocabulary</a>
              . If not, platform-specific vocabulary along
              with a corresponding
              <a href="#user-content-protocol-binding">Protocol
              Binding</a>
              implementation is required.
            </li>
            <li>
              <b>Transfer Protocol:</b>
              The
              <a href="#user-content-thing-description-td">WoT
              Thing Description</a>
              comes with vocabulary to identify
              standard protocols (e.g., HTTP, CoAP, WebSockets, or MQTT).
              Their configuration (e.g., port or variations such as HTTP
              long-polling [[!RFC6202]] to support event notification) is
              also done through
              <a href="#user-content-td-vocabulary">TD





                Vocabulary</a>
              . If a transfer protocol is not covered by
              the
              <a href="#user-content-td-vocabulary">TD





                Vocabulary</a>
              ,
              <a href="#user-content-domain-specific-vocabulary">domain-specific





                vocabulary</a>
              can be used. This, of course, needs to be
              backed by a corresponding
              <a href="#user-content-protocol-binding">Protocol





                Binding</a>
              implementation in the
              <a href="#user-content-wot-client">WoT





                Client</a>
              .
            </li>
            <li>
              <b>Media Type:</b>
              <a href="#user-content-iot-platform">IoT





                Platforms</a>
              often differ in the representation formats
              (or serializations) used for exchanging data. The Internet
              Meda Type [[!RFC6838]] identifies these formats.
            </li>
            <li>
              <b>Security:</b>
              Security can be applied at different
              places of the communication, and hence opens another
              dimension of variability. Examples are (D)TLS
              [[!RFC5246]]/[[!RFC6347]], IPSec [[!RFC6071]], OAuth
              [[!RFC6749]], and ACE [[!RFC7744]].
            </li>
          </ul>
        </section>
        <section>
          <h3>WoT Scripting API</h3>
          <p class="ednote" title="TODO">Need to introdcue Scripting API under the condition that it might not become REC, but WG Note.</p>
        </section>
        <section>
          <h3>WoT Security and Privacy Guidelines</h3>
          <p class="ednote" title="TODO">Explain how to use and apply guidelines.</p>
        </section>
      </section>
      <section>
        <h2>Servient Implementation</h2>
        <p>
          A <a href="#user-content-servient">Servient</a>
          is a software stack that implements the WoT building blocks presented in the previous section.
          <a href="#user-content-servient">Servients</a>
          can host and expose <a href="#user-content-thing">Things</a>
          and/or consume <a href="#user-content-thing">Things</a>.
          Thus, <a href="#user-content-servient">Servients</a>
          can perform in both the server and client roles; the name (a
          portmanteau of server and client) is based on this dual role.
        </p>
        <p>
          The previous shows how the WoT building blocks conceptionally relate to each other.
          When implementing these concepts, a more detailed view is necessary that takes certain technical aspects into account.
          The detailed architecture of a <a href="#user-content-servient">Servient</a> is shown in .
        </p>
        <figure id="architecture-implementation">
          <img src="images/architecture-implementation.png" style="width: 640px;" />
          <figcaption>Implementation View of a Servient</figcaption>
        </figure>
        <p>The role and functionality of each module shown in is as follows:</p>

        <section>
          <h3>Application</h3>
          <p>
            <a href="#user-content-application">Applications</a>
            running on a <a href="#user-content-servient">Servient</a>
            are usually implemented through scripts (i.e., JavaScript).
            The application scripts must be provided along with security
            metadata that defines their <a href="#user-content-execution-environment">Execution Environment</a>
            and consequently how scripts must be isolated.
            The security metadata also needs to include keying material or certificates to authenticate the <a href="#user-content-thing">Things</a>
            the script exposes.
          </p>
          <p>
            Note that the <a href="#user-content-scripting-api">WoT Scripting API</a> building block is optional. There can be
            minimal <a href="#user-content-servient">Servient</a>
            implementations where applications are implemented natively for the software stack.
            These do not have the <a href="#user-content-scripting-api">Scripting API</a>
            and <a href="#user-content-wot-runtime">WoT Runtime</a> modules.
          </p>
          <section>
            <h4>Native</h4>
            <p class="ednote" title="TODO">
              Explain native implementation against custom API in programming language of choice.
            </p>
          </section>
          <section>
            <h4>WoT Scripting API</h4>
            <p>
              The standardized <a href="#user-content-scripting-api">WoT Scripting API</a>
              is the contract between applications and the runtime system of a
              <a href="#user-content-servient">Servient</a>,
              the so-called <a href="#user-content-wot-runtime">WoT Runtime</a>.
              The <a href="#user-content-scripting-api">WoT Scripting API</a>
              is equivalent to any platform API, and
              hence there must be mechanisms to prevent malicious access to
              the system. As mentioned above, this building block, including
              the underlying WoT Runtime implementation, is optional.
            </p>
            <p>
              The <a href="https://w3c.github.io/wot-scripting-api/">WoT
              Scripting API</a> is an optional building block that eases
              IoT application development. Traditionally, device logic is
              implemented in firmware, which underlies the productivity
              constraints of embedded development. The
              <a href="#user-content-scripting-api">WoT Scripting API</a> enables having a runtime system for IoT
              applications similar to a Web browser, and aims to improve
              productivity and reduce integration costs. Furthermore,
              standardized APIs enable portability for application modules,
              for instance, to move compute-intense logic from a device up
              to a local gateway, or to move time-critical logic from the
              cloud down to a gateway or edge node.
            </p>
            <p>
              The <a href="#user-content-scripting-api">Scripting API</a> is built on top of the <a href="#user-content-thing">Thing</a>
              abstraction and the TD <a href="#user-content-interaction-model">Interaction Model</a>. There are three sub APIs:
            </p>
            <ul>
              <li><b><code>WoT</code> object</b> as API entry point to
                discover, consume, and expose <a href="#user-content-thing">Things</a></li>
              <li><b><code>ConsumedThing</code> interface</b> as Client API
                to consume <a href="#user-content-thing">Things</a>
                over the network or locally (e.g., physically attached
                hardware)</li>
              <li><b><code>ExposedThing</code> interface</b> as Server API
                to configure and expose <a href="#user-content-thing">Things</a>
                over the network</li>
            </ul>
            <p>
              See <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting API</a> for details.
            </p>
          </section>
        </section>
        <section>
          <h2>WoT Runtime</h2>
          <p>
            The <a href="#user-content-thing">Thing</a>
            abstraction and <a href="#user-content-interaction-model">Interaction Model</a>
            is implemented in a runtime system that offers the application-facing <a href="#user-content-scripting-api">WoT Scripting API</a>.
            This <a href="#user-content-wot-runtime">WoT Runtime</a> interfaces with the <a href="#user-content-protocol-binding">Protocol Bindings</a> to access remote <a href="#user-content-thing">Things</a>
            and with the system API to access local hardware and
            proprietary means for communication. Note that both local
            hardware and devices behind proprietary communications
            protocols are also represented as <a href="#user-content-thing">Things</a>
            in the runtime environment, that is, they are also accessed
            through the <a href="#user-content-client-api">Client API</a>.
            The <a href="#user-content-wot-runtime">WoT Runtime</a>
            is also tasked with generating the <a href="#user-content-thing-description-td">Thing Description</a> based on the <a href="#user-content-servient">Servient</a>
            metadata (e.g., location), application metadata (e.g., provided <a href="#user-content-interaction">Interactions</a>),
            and available <a href="#user-content-protocol-binding">Protocol Bindings</a>
            (e.g., implemented <a href="#user-content-binding-templates">WoT Binding Templates</a>).
          </p>
        </section>
        <section>
          <h2>Protocol Bindings</h2>
          <p>
            <a href="#user-content-protocol-binding">Protocol Bindings</a>
            are implementations of the <a href="#user-content-binding-templates">Binding Templates</a>.
            They produce the messages to interact with <a href="#user-content-thing">Things</a>
            over the network based on the information given in the
            <a href="#user-content-thing-description-td">Thing Description</a>
            of the <a href="#user-content-consumed-thing">Consumed Thing</a>. <a href="#user-content-servient">Servients</a>
            usually have multiple <a href="#user-content-protocol-binding">Protocol Bindings</a> to enable interaction with different <a href="#user-content-iot-platform">IoT Platforms</a>.
          </p>
          <p>
            In many cases, where standard protocols are used, generic
            protocol stacks can be used to produce the platform-specific
            messages (e.g., one for HTTP(S) dialects, one for CoAP(S)
            dialects, and one for MQTT solutions, etc.). In this case, the
            communication metadata from the <a href="#user-content-thing-description-td">Thing Description</a>
            is used to select and configure the right
            stack (e.g., HTTP with the right header fields or CoAP with
            the right options). Parsers and serializers for the expected
            representation format identified by the Internet Media Type
            can also be shared across these generic protocol stacks.
          </p>
          <p>
            In some cases, where no aspects can be shared, the <a href="#user-content-protocol-binding">Protocol Binding</a> is more comparable to a platform-specific driver
            that is selected and configured through the communication
            metadata in similar way as above.
          </p>
          <p>
            See <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a> for details.
          </p>
        </section>
        <section>
          <h2>System API</h2>
          <p> The implementation of a <a href="#user-content-thing">Thing</a>
            may access local hardware or system services (e.g. storage)
            through proprietary APIs or other means. This block is out of
            scope of WoT standardization.
          </p>
          <p>
            A <a href="#user-content-wot-runtime">WoT Runtime</a> may provide local hardware or system services to
            application scripts through the <a href="#user-content-thing">Thing</a>
            abstraction, as if they were accessible over a network
            protocol. In this case the implementation should be optimized
            to avoid the overhead that would be involved in a literal
            implementation of a network protocol while maintaining a
            consistent <a href="#user-content-wot-interface">WoT Interface</a>.
            The details of such "System Things" are out
            of the scope of standardization at present, although W3C WoT
            will document several informational examples. </p>
          <p> A device may be physically external to a <a href="#user-content-servient">Servient</a>,
            but connected via proprietary protocols. In this case, the
            implemented runtime environment may access legacy devices with
            such protocols (e.g., Echonet Lite, X10, I2C, SPI) through
            proprietary APIs, but again exposes them to applications as <a href="#user-content-thing">Things</a>
            through the <a href="#user-content-scripting-api">Scripting API</a>. A script can then act as gateway to the legacy
            devices. This should only be done if the legacy device cannot
            be described using the <a href="#user-content-thing-description-td">WoT Thing Description</a>.
          </p>
        </section>
      </section>
    </section>

    <section id="sec-WoT-servient-architecture-rm">
      <h1>? WoT Servient Implementation ?</h1>
      <p class="ednote" title="TODO">
        This section already talks about cross-Servient interactions.
        Text most likely needs to be moved to WoT Deployments section.
      </p>

      <p>This section defines components that make a Web of Things
        entity, clarifies each component’s functions, and then shows how
        a web of Things as a whole works. The architecture described
        here is derived from the Web of Things use cases as well as
        technical requirements extracted from them.</p>
      <section id="sec-WoT-servient-architecture-high-level">
        <h2>High-level architecture</h2>
        <p>Overview of WoT component’s behavior is explained using a
          couple of system configuration diagrams. First, shown below is
          a configuration that consists of a device and an application
          shown below.</p>
        <figure id="high-level-application-device">
          <img src="images/arch-high-level-application-device.png" />
          <figcaption>High




            level architecture of appliation and device</figcaption>
        </figure>
        <p>Functions of a device is described by a Thing Description
          (TD). A TD describes, among other things, a device’s
          identifier, functions and attributes of a device implemented
          internally, communication protocols (i.e. transport layer)
          information. Details of TD format are defined the Thing
          Description specification.</p>
        <p>Each Web of Things device MUST have a corresponding TD.
          Applications can recognize a device by obtaining a TD of the
          device. Conceptually, a device can be thought to have an
          ExposedThing that provides an interface that conforms to the
          TD. On the other hand, an application can be conceptually
          considered to have a ConsumedThing that provides an interface
          functionality for an application to utilize. An application
          can generate a ConsumedThing upon a receipt of a TD.
          Communication between an application and a device are realized
          by ConsumedThing and ExposedThing connect to each other and
          exchange messages.</p>
        <p>Next, in the below configuration, an application and a
          device connect to each other via a proxy.</p>
        <figure id="high-level-application-proxy-device">
          <img src="images/arch-high-level-application-proxy-device.png" />
          <figcaption>High




            level architecture with proxy</figcaption>
        </figure>
        <p>A proxy contains both ExposedThing and ConsumedThing
          functionality, and relay messages that are exchanged between
          an application and a device. In a proxy, a ConsumedThing
          creates a shadow of the device, and an application can access
          the shadow device through the proxy’s ExposedThing.</p>
        <p>Proxy’s ExposedThing and ConsumedThing can communicate in
          different protocols. For example, a device and an application
          can use separate protocols, CoAP and HTTP, respectively. Even
          when there are multiple devices and they use different
          protocols, an application can communicate with those devices
          using a single protocol through the proxy. The same is true
          for device authentication. An application only need to handle
          a single authentication method even when multiple devices
          connected to a proxy use different authentication methods.</p>
        <p>A proxy creates a ConsumedThing based on a TD and generates
          another TD for a shadow device. The TD for a shadow device
          uses a new identifier different from the original device TD’s,
          and changes communication protocols if necessary. A proxy then
          creates an ExposedThing that serves as the Thing for the TD.
          An application communicates with a device via a proxy through
          a ConsumedThing that works according to the TD for the shadow
          device.</p>
      </section>
      <section id="sec-WoT-servient-architecture-simple-config">
        <h2>Simple configuration of WoT servient</h2>
        <p>The remainder of this section discusses and clarifies the
          inner structure of a servient.</p>
        <p>First, inner structure of a servient is explained based on
          the structure of an application servient and a device
          servient. WoT runtime defines an abstract interface that
          contains methods such as READ, WRITE, INVOKE, SUBSCRIBE,
          NOTIFY through which to access devices. When a servient
          communicates over a network, those methods are bound to
          concrete protocols. For example, in the case of HTTP, HTTP
          methods such as PUT and GET are assigned to implement the
          abstract methods. WoT clients can retrieve and change device
          settings or device attributes defined in TDs through those
          abstract methods. In a device servient, TD manager creates an
          ExposedThing based on TD. TD manager also advertises a TD to
          other servients, or provides other servients with a TD upon
          request. A device servient’s functions are usually implemented
          as hardware, and those functions are accessible through its
          firmware. An ExposedThing’s abstract interface is translated
          into hardware commands by a device interface adapter. A device
          interface adapter is a custom software developed for each
          specific type of hardware. In an application servient, on the
          other hand, a TD manager obtains TDs by getting one from
          location advertised by other servients or requesting other
          servients of TDs, and creates a ConsumedThing based on the
          obtained TD. Functions of an application servient are usually
          implemented as an application. The abstract interface of a
          ConsumedThing is provided as a programming language (such as
          JavaScript) interface, and the application achieves its
          functions by using this interface.</p>
        <figure id="simple-conf-application-device">
          <img src="images/arch-simple-conf-application-device.png" />
          <figcaption>Simple




            configuration of application and device</figcaption>
        </figure>
        <p>Next, inner structure of a servient is explained based on
          the structure of a proxy servient that connects a device
          servient and application servient together.</p>
        <p>A runtime in a proxy servient has both ExposedThing and
          ConsumedThing functionality. A TD manager, similar to that of
          an application servient, obtains a TD of a device servient,
          and creates a ConsumedThing. At the same time, a TD manager
          creates a shadow of the device as well as a TD for the shadow
          device where the identifier is a new one and protocol bindings
          are appropriately described to serve for the application. An
          ExposedThing is created based on this TD, and a TD manager
          notifies other servients of the TD.</p>
        <figure id="simple-conf-application-proxy-device">
          <img src="images/arch-simple-conf-application-proxy-device.png" />
          <figcaption>Simple configuration with proxy</figcaption>
        </figure>
        <p>Below is a WoT architecture diagram that summarizes the
          inner structure of a WoT servient. A runtime creates
          ExposedThing or ConsumedThing based on TDs, provides an
          abstract interface that through protocol binding can interact
          with other servients. Note that the diagram also contains a
          legacy device that does not by itself support WoT abstract
          interface. A device interface adapter converts legacy
          interface into an abstract interface to allow them to interact
          with the runtime.</p>
        <figure id="simple-conf-wot-servient">
          <img src="images/arch-simple-conf-wot-servient.png" />
          <figcaption>Simple




            configuration of WoT servient</figcaption>
        </figure>
      </section>
    </section>

    <!-- DEPLOYMENT SCENARIOS  -->
    <section id="sec-deployment-scenario-rm">
      <h1>WoT Deployments</h1>
      <p>In the previous sections, how WoT servients connect to each
        other and their roles and basic behaviors were described based
        on two simple structures; one with an application and a device,
        and the other with a proxy connecting an application and a
        device together. These simple structures can be used as is for
        use cases involving relatively small numbesr of devices. However,
        they are too simple per se to describe those more complex uses
        cases where the number of connected devices are not small, or
        devices are physically located in multiple remote sites. This
        section illustrates more advanced structures that can be applied
        to those non-simple use cases.</p>

      <section>
        <h2>Device Servients</h2>
        <p class="ednote" title="TODO">
          Move content from sections further down here and potentially other places here.
        </p>
      </section>
      <section>
        <h2>Application Servients</h2>
        <p class="ednote" title="TODO">
          Move content from sections further down here and potentially other places here.
        </p>
      </section>
      <section>
        <h2>Proxy Servients</h2>
        <p class="ednote" title="TODO">
          Move content from sections further down here and potentially other places here.
        </p>
      </section>
      <section>
        <h2>Thing Directories</h2>
        <p class="ednote" title="TODO">
          Try to explain this component in open way, as specification is not available yet.
        </p>
      </section>

      <section id="sec-deployment-cloud-rm">
        <h2>Devices in a Local Network Controlled from a Cloud</h2>
        <p>In smart home cloud service use cases, sensors and home
          appliances connected to a home network are monitored as well
          as in some cases operated by cloud applications. There is a
          firewall between the home network to which the devices are
          connected and the cloud. The WoT servients in this case can
          communicate each other only if the communication successfully
          goes through the firewall.</p>
        <p>The figure below shows a typical structure that is adopted
          in ITU-T Recommendation Y.2070. As described in previous
          sections, a proxy can aggregate multiple device servients into
          common ExposedThing(s), and provide the applications with a
          simple access interface. For example, even when the connected
          devices each uses a different protocol such as REST, WebSocket
          and CoAP, the ExposedThing can converge them into a single
          protocol so that applications do not need to be aware of the
          various protocols the devices use. In the figure, there are
          two applications connected to a proxy. Those applications use
          a single protocol (e.g. REST) to communicate with the proxy,
          which makes the development of an application much simpler.</p>
        <p>There is a firewall between applications and devices. There
          is a proxy on each side of the firewall; one in the home
          network and the other in the internet. These two proxies work
          together to tunnel all communications to go through the
          firewall. The local proxy which is on the home network side
          aggregates all connected devices, and the remote proxy on the
          internet side aggregates the applications. Applications and
          devices need to know nothing about the firewall.</p>
        <figure id="deployment-clodu-device">
          <img src="images/arch-deploy-cloud-device.png" />
        </figure>
        <p>Note: An example structure adopted in ITU-T Recommendation
          Y.2070</p>
      </section>
      <section id="sec-deployment-service-to-service-rm">
        <h2>Service-to-Service connections across multiple Domains</h2>
        <p>Once devices can be monitored or operated by cloud
          applications, a variety of services can be built on top of
          that. For example, a cloud application can change a device’s
          operating condition based on analysis of collected data. When
          the remote proxy is a part of a cloud platform servicing
          applications, an application needs to be able to find device
          information by, for example, accessing a directory of
          connected devices. In the figure below, information of all
          devices connected to the remote proxy via a local proxy is
          registered in a directory. An application needs to obtain the
          information of the device(s) that it needs to communicate with
          to achieve its application functionality. It can do so by
          querying the directory of device information.</p>
        <figure id="deployment-cloud-directory">
          <img src="images/arch-deploy-service-directory.png" />
          <figcaption>Cloud
            service with directory</figcaption>
        </figure>
        <p>Multiple cloud eco-systems each based on a different
          platform can work together to make a larger,
          systems-of-systems eco-system. Built on the previously
          discussed structure of a cloud application eco-system, the
          figure below shows two eco-systems connected each other to
          make a system-of-systems. Consider a case in which an
          application servient in one eco-system (i.e. Application
          Servient A in below) uses a device servient in another
          eco-system (i.e. Device Servient B in below). There are more
          than one mechanisms to achieve this cross eco-systems
          application-device integration. Below, two mechanisms of doing
          this are explained each using a figure to help understand how
          it can be achieved.</p>
        <p>In the first figure below, two directories synchronize
          device information, which makes it possible for Application
          Servient A to obtain the information of Device Servient B
          through TD directory A. As described in previous sections,
          Remote Proxy Servient B holds a shadow device of Device
          servient B. By obtaining the TD of this shadow device,
          Application servient A is able to use Device Servient B
          through the shadow device on Remote Proxy Servient B.</p>
        <figure id="deployment-service-sync-directory">
          <img src="images/arch-deploy-service-sync-directory.png" />
          <figcaption>Multiple
           cloud connect through directory synchronization</figcaption>
        </figure>
        <p>In the second figure below, two remote proxy servients
          synchronize device information. When a shadow of Device
          Servient B is created in Remote proxy servient B, the shadow’s
          TD is simultaneously synchronized into Remote proxy servient
          A. Remote proxy servient A in turn creates its own shadow of
          Device servient B, and registers the TD to TD directory A.
          With this mechanism, synchronization between TD directories is
          not necessary.</p>
        <figure id="deployment-service-sync-proxy">
          <img src="images/arch-deploy-service-sync-proxy.png" />
          <figcaption>Multiple
           cloud connect through proxy synchronization</figcaption>
        </figure>
      </section>
      <h1>SNIPPETS: (was WoT Deployment Scenarios and Guidelines)</h1>
      <p>There are many possibilities for deploying the abstract WoT
        Architecture and mapping the functions to physical devices and
        network structures. This section, which is informative but not
        normative, lists a number of design patterns that may be used
        when implementing the Web of Things.</p>
      <section>
        <h2>WoT Client</h2>
        <figure id="wot-existing">
          <img src="images/wot-existing.png" style="width: 500px;" />
          <figcaption>Servient Consuming Thing</figcaption>
        </figure>
        <p>
          shows the basic scenario, where a
          <a href="#user-content-servient">Servient</a>
          in client role, a
          <a href="#user-content-wot-client">WoT
            Client</a>
          , is consuming an existing device that is
          augmented with a
          <a href="#user-content-thing-description-td">Thing
            Description</a>
          (TD). The latter could be generated from
          digital descriptions already available for the device within
          the corresponding the
          <a href="#user-content-iot-platform">IoT
            Platform</a>
          . It could also be written by a developer using
          tools or even manually.
        </p>
        <p>
          The Application Script is loaded and executed by the
          <a href="#user-content-wot-runtime">WoT
            Runtime</a>
          . Scripts can be manually configured with the URI
          of the device
          <a href="#user-content-td">TD</a>
          located on a reachable Web server. Using the
          <a href="#user-content-wot-object">
            <code>WoT</code>
            object
          </a>
          , the Application Script retrieves the
          <a href="#user-content-td">TD</a>
          and instantiates a corresponding
          <a href="#user-content-consumed-thing">Consumed
            Thing</a>
          . The Application Script can use the metadata of
          the
          <a href="#user-content-thing">Thing</a>
          and inspect what
          <a href="#user-content-interaction">Interactions</a>
          it provides. The communication metadata within the
          <a href="#user-content-td">TD</a>
          is used by the
          <a href="#user-content-servient">Servient</a>
          to select the matching
          <a href="#user-content-protocol-binding">Protocol
          Binding</a>
          and to configure its protocol stack. These
          communication details are hidden from the Application Script.
          However, the script can only interact with the
          <a href="#user-content-thing">Thing</a>
          ,
          if the
          <a href="#user-content-servient">Servient</a>
          implements a
          <a href="#user-content-protocol-binding">Protocol
		  Binding</a>
          that matches the communication metadata given in
          the
          <a href="#user-content-td">TD</a>
          .
        </p>
        <p>
          Using the
          <a href="#user-content-client-api">Client
		  API</a>
          (i.e.,
          <code>ConsumedThing</code>
          interface), the
          Application Script can read or write a
          <a href="#user-content-property">Property</a>
          ,
          invoke an
          <a href="#user-content-action">Action</a>
          ,
          or subscribe for
          <a href="#user-content-event">Events</a>
          offered by the
          <a href="#user-content-thing">Thing</a>
          .
          The selected
          <a href="#user-content-protocol-binding">Protocol
		  Binding</a>
          maps these
          <a href="#user-content-interaction">Interactions</a>
          to the low-level protocol operations and serializations
          understood by the remote
          <a href="#user-content-thing">Thing</a>
          .
          When a message is returned by the
          <a href="#user-content-thing">Thing</a>
          ,
          the
          <a href="#user-content-protocol-binding">Protocol Binding</a>
          parses the response and maps it back to the
          <a href="#user-content-interaction">Interaction</a>
          abstraction. The
          <a href="#user-content-interaction">Interaction</a>
          output is delivered back to the Application Script by
          resolving a (JavaScript) Promise.
        </p>
        <p class="ednote">Each sub-section shall describe the technical
          details to realize the scenario. They shall describe how to
          discover the involved WoT components, how to realize
          connectivity, and what security mechanisms can be used. For
          now, the draft only contains strawman proposals and
          placeholders that will be replaced as the draft progresses.</p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>Manual (Application Script is configured with TD URI)</li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>Local over (W)LAN or LPWANs (ZigBee, Z-Wave, etc.)</li>
              <li>Remote over globally reachable IP address of the Thing</li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>Security metadata to sandbox the Application Script</li>
              <li>Access control implemented on the Thing</li>
              <li>Integrity protection when retrieving the TD</li>
              <li>Potentially confidentiality and integrity protection
                when interacting with the Thing</li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Servient on Device</h2>
        <figure id="wot-on-device">
          <img src="images/wot-on-device.png" style="width: 640px;" />
          <figcaption>Servient on Device
            Itself</figcaption>
        </figure>
        <p>
          In this case, a
          <a href="#user-content-servient">Servient</a>
          is running on the device itself. The right most
          <a href="#user-content-servient">Servient</a>
          in shows an LED Light, whose controller has a powerful CPU and
          a large memory and is able to provide web server functionality
          connected directly to the Internet. Then the leftmost browser
          and/or another application on the internet can access the LED
          light through the Internet directly.
        </p>
        <figure id="wot-on-device-minimal">
          <img src="images/wot-on-device-minimal.png" style="width: 640px;" />
          <figcaption>Resource-constrained Device as Thing</figcaption>
        </figure>
        <p>
          Devices that are not powerful enough to host a
          <a href="#user-content-servient">Servient</a>
          can still act as
          <a href="#user-content-thing">Things</a>
          .
          In this case, a classic firmware is providing a
          <a href="#user-content-thing-description-td">Thing
		  Description</a>
          that describes the functionality and
          protocols implemented. The right most
          <a href="#user-content-servient">Servient</a>
          in shows a legacy device that has a constrained CPU and a
          small memory and is able to provide web server functionality
          connected directly to the internet. Then the leftmost browser
          and/or another application on the internet can access the
          device through the Internet directly like .
        </p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>
                WoT Client discovers
                <a href="#user-content-servient">Servient</a>
                on the same network [network discovery].
              </li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>(W)LAN</li>
              <li>LPWANs (ZigBee, Z-Wave, etc.)</li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Servient on Smartphone</h2>
        <p>
          This example uses a
          <a href="#user-content-servient">Servient</a>
          running on a Smartphone. Smartphones are not only popular but
          have enough performance to provide gateway functionality. This
          functionality can be used to bridge between the internet and a
          legacy device without any intermediate hardware.
        </p>
        <figure id="wot-on-smartphone">
          <img src="images/wot-on-smartphone.png" style="width: 640px;" />
          <figcaption>Servient





            on Smartphone</figcaption>
        </figure>
        <p>
          shows an example of a
          <a href="#user-content-servient">Servient</a>
          on a smartphone, which can act as a gateway to existing
          devices (e.g., via Bluetooth or local Wi-Fi). The Web browser
          with the user interface can either run on the smartphone
          directly or remotely on a separate device (such as a laptop).
        </p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>WoT Client discovers an electronic appliance when the
                remote controller is nearby [nearby discovery].</li>
              <li>
                WoT Client discovers
                <a href="#user-content-servient">Servient</a>
                remotely when the remote controller is outside [remote
                discovery].
              </li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Servient on Gateway</h2>
        <figure id="wot-on-gateway">
          <img src="images/wot-on-gateway.png" style="width: 640px;" />
          <figcaption>Servient





            on Gateway</figcaption>
        </figure>
        <p>
          shows an example of a
          <a href="#user-content-servient">Servient</a>
          on a gateway. Gateway are often introduced as a home
          automation and/or home energy management solution. In the case
          of consumer electronics, there are very wide variety of
          physical communication formats such as WiFi, 802.15.4g,
          Bluetooth Low Energy, HDPLC and so on. In order to normalize
          those variations, almost all home automation systems introduce
          a gateway. In , a
          <a href="#user-content-servient">Servient</a>
          wraps various mechanisms for communicating with legacy devices
          and provides to other clients a universal device accessing
          method. Inside the home, HTTP/TCP/IP/WiFi can then be used as
          the sole unfied communication method between the
          <a href="#user-content-servient">Servient</a>
          on the gateway and a user interface device such as a Web
          broswer.
        </p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>
                <a href="#user-content-servient">Servient</a>
                discovers electronic appliances nearby [nearby
                discovery].
              </li>
              <li>
                WoT Client discovers
                <a href="#user-content-servient">Servient</a>
                remotely [remote discovery].
              </li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Servient on Cloud and Gateway</h2>
        <p>
          Client Apps can control devices at home through a
          <a href="#user-content-servient">Servient</a>
          on a gateway. But in this case the location of client apps is
          restricted to the home, because physical communication path
          "WiFi" and/or wired Ethernet between gateway and client apps
          such as a Web browser is limited to the physical domain
          provided by the WiFi signal. To provide for controlling
          devices at home from outside the house, a HTTP/TCP/IP
          interface to a
          <a href="#user-content-servient">Servient</a>
          running in the cloud with a globally reachable address could
          be used. However, in this case the
          <a href="#user-content-servient">Servient</a>
          in the cloud cannot generally access devices running in the
          home through only local interfaces such as Bluetooth.
        </p>
        <figure id="wot-on-cloud">
          <img src="images/wot-on-cloud.png" style="width: 800px;" />
          <figcaption>Servient on Cloud Server
            and Gateway</figcaption>
        </figure>
        <p>
          shows an example of
          <a href="#user-content-servient">Servient</a>
          running on a cloud server paired with another
          <a href="#user-content-servient">Servient</a>
          running on a gateway. In the case of , a browser accesses the
          <a href="#user-content-servient">Servient</a>
          on the cloud Server named "Cloud". This
          <a href="#user-content-servient">Servient</a>
          provides its interface through the Internet globally. So,
          wherever a browser user is, they can access this
          <a href="#user-content-servient">Servient</a>
          .
          The
          <a href="#user-content-servient">Servient</a>
          on "Cloud" can accept the request of the browser and/or other
          application through HTTP, CoAP, and so on. Then the
          <a href="#user-content-servient">Servient</a>
          on the cloud server finds out the route to access another
          <a href="#user-content-servient">Servient</a>
          on the gateway. After finding out the route, the
          <a href="#user-content-servient">Servient</a>
          on the cloud server transfers the request from the browser to
          the
          <a href="#user-content-servient">Servient</a>
          on the gateway. After that, the gateway processes the request
          according the use case. The
          <a href="#user-content-thing-description-td">Thing
 Description</a>
          of the
          <a href="#user-content-servient">Servient</a>
          on the cloud server can be just a mirror of that on the
          gateway, since it will generally just pass interactions
          directly through. More generally, though, one or both
          <a href="#user-content-servient">Servients</a>
          can provide services such as privacy filtering or sub-setting.
          When the user is home, they can also access the
          <a href="#user-content-servient">Servient</a>
          in the gateway directly.
        </p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>
                <a href="#user-content-servient">Servient</a>
                discovers WoT Server remotely [remote discovery].
              </li>
              <li>
                WoT Client discovers
                <a href="#user-content-servient">Servient</a>
                remotely [remote discovery].
              </li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Servient on Cloud Server</h2>
        <figure id="wot-on-cloud-legacy">
          <img src="images/wot-on-cloud-legacy.png" style="width: 800px;" />
          <figcaption>Servient on Cloud Server Only</figcaption>
        </figure>
        <p>
          shows a second example of
          <a href="#user-content-servient">Servients</a>
          in the cloud. In this case, a browser accesses a
          <a href="#user-content-servient">Servient</a>
          on a cloud server, similar to . This
          <a href="#user-content-servient">Servient</a>
          provides access through the global Internet. So, wherever the
          browser user is, they can access this
          <a href="#user-content-servient">Servient</a>
          .
          The cloud
          <a href="#user-content-servient">Servient</a>
          accepts the requests of the browser and/or other applications
          through HTTP, CoAP, etc. Then it finds out the route to access
          a proprietry discovery service running on a gateway. In , the
          <a href="#user-content-servient">Servient</a>
          running in the cloud could talk to another
          <a href="#user-content-servient">Servient</a>
          running on the gateway. However, many service providers have
          already provided IoT services using proprietary IoT interfaces
          or some other IoT standard. In this case, the gateway can
          still support the same functionalities, as in the previous
          case, but using methods outside of the WoT definitions.
        </p>
        <dl>
          <dt>Discovery</dt>
          <dd>
            <ul>
              <li>Servient1 discovers Servient2 remotely [remote
                discovery].</li>
              <li>Servient2 discovers electronic appliances nearby
                [nearby discovery].</li>
              <li>WoT Client discovers Servient1 remotely [remote
                discovery].</li>
            </ul>
          </dd>
          <dt>Connectivity</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
          <dt>Security</dt>
          <dd>
            <ul>
              <li>
                <span style="color:red">t.b.d.</span>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
    </section>
    <section id="sec-security-considerations">
      <h1>Security and Privacy Considerations</h1>
      <p class="ednote">
        This section will likely undergo
            significant revision and reorganization. Please see the
        <a href="https://github.com/w3c/wot-security/">WoT Security
              and Privacy</a>
        repository for work in progress. In
            particular, the
        <a href="https://github.com/w3c/wot-security/blob/master/wot-threat-model.md">WoT
		   Threat Model</a>
        defines the main WoT security
            stakeholders, assets, attack surfaces, and threats.
      </p>
      <p>The functional WoT architecture should enable the use of
            best practices in security and privacy. Generally, the WoT
            security architecture must support the goals and mechanisms
            of the IoT protocols and systems it connects to. These
            systems vary in their security requirements and risk
            tolerance, so security mechanisms will also vary based on
            these factors. However, the WoT architecture needs to do no
            harm: it should support security and privacy at least as
            well as the systems it connects to.</p>
      <p>Security means the system should preserve its integrity
            and functionality even when subject to attack. Privacy means
            that the system should maintain the confidentiality of
            personally identifiable information. In general, security
            and privacy cannot be guaranteed but the WoT architecture
            should support best practices.</p>
      <p>Security and privacy are especially important in the IoT
            domain since IoT devices need to operate autonomously and in
            many cases have access to both personal data and/or can be
            in control of safety-critical systems. Compared to personal
            systems, IoT devices are subject to different and in some
            cases higher risks than IT systems. It is also important to
            protect IoT systems so that they can not be used to launch
            attacks on other computer systems.</p>
      <p class="ednote">
        Security and privacy considerations are still
        under discussion and development; the content below should be
        considered preliminary. Due to the complexity of the subject we
        are considering producing a separate document containing a
        detailed security and privacy considerations discussion
        including a risk analysis, threat model, recommended
        mitigations, and appropriate references to best practices. A
        summary will be included here. Work in progress is located in
        the
        <a href="https://github.com/w3c/wot-security/">WoT Security
          and Privacy</a>
        repository. Please file any security or
        privacy considerations and/or concerns using the
        <a href="https://github.com/w3c/wot-security/issues">GitHub Issue</a>
        feature.
      </p>
      <p>
        <!-- Security requirements for the the WoT -->
        Security is a
        cross-cutting issue that needs to be taken into account in all
        <a href="#sec-building-blocks">WoT building blocks</a>
        . The W3C
        WoT does not define any new security mechanisms, but provides
        guidelines to apply the best practices from Web security, IoT
        security, and information security for general software and
        hardware considerations.
      </p>
      <p>
        The
        <a href="#user-content-thing-description-td">WoT





          Thing Description</a>
        must be used together with integrity
        protection mechanisms and access control policies. Users must
        ensure that no sensitive information is included in the
        <a href="#user-content-td">TDs</a>
        themselves.
      </p>
      <p>
        The
        <a href="#user-content-binding-templates">WoT





          Binding Templates</a>
        must correctly cover the security
        mechanisms employed by the underlying
        <a href="#user-content-iot-platform">IoT





          Platform</a>
        . Due to the automation of network interactions
        necessary in the IoT, operators need to ensure that
        <a href="#user-content-thing">Things</a>
        are exposed and consumed in a way that is compliant with their
        security policies.
      </p>
      <section id="sec-security-consideration-runtime-risks">
        <h2>WoT Runtime Security and Privacy Risks</h2>
        <p>
          The
          <a href="#user-content-wot-runtime">WoT





            Runtime</a>
          implementation for the
          <a href="#user-content-scripting-api">WoT





            Scripting API</a>
          must at least have mechanisms to prevent
          malicious access to the system and isolate scripts in
          multi-tenant
          <a href="#user-content-servient">Servients</a>
          .
          More specifically the
          <a href="#user-content-wot-runtime">WoT





            Runtime</a>
          implementation for the
          <a href="#user-content-scripting-api">WoT





            Scripting API</a>
          should take into account the below
          security and privacy risks and implement the recommended
          mitigations.
        </p>
        <section id="sec-security-consideration-cross-script">
          <h5>Cross-Script Security and Privacy Risk</h5>
          <p>
            In basic WoT setups, all scripts running inside the
            <a href="#user-content-wot-runtime">WoT Runtime</a>
            are considered trusted, and therefore
            there is no strong need to perform strict isolation between
            each running script instance. However, depending on device
            capabilities and deployment use case scenario risk level it
            might be desirable to do so. For example, if one script
            handles sensitive privacy-related data and well-audited, it
            might be desirable to separate it from the rest of the
            script instances to minimize the risk of data exposure in
            case some other script inside WoT gets compromised during
            runtime. Another example is mutual co-existence of different
            tenants on a single WoT device. In this case each WoT
            runtime instance will be hosting a different tenant, and
            isolation between them is required.
          </p>
          <dl>
            <dt>Mitigation:</dt>
            <dd>
              The WoT runtime should perform isolation of script
              instances and their data in cases when scripts handle
              privacy-related or other critical security data.
              Similarly, the
              <a href="#user-content-wot-runtime">WoT





                Runtime</a>
              implementation should perform isolation of
              <a href="#user-content-wot-runtime">WoT





                Runtime</a>
              instances and their data if a WoT device has
              more than one tenant. Such isolation can be performed
              within the
              <a href="#user-content-wot-runtime">WoT





                Runtime</a>
              using platform security mechanisms available
              on the device. For more information see Sections "WoT
              Servient Single-Tenant" and "WoT Servient Multi-Tenant" of
              [[!WOT-SECURITY-CONSIDERATIONS#]].
            </dd>
          </dl>
        </section>
        <section id="sec-security-consideration-device-direct-access">
          <h5>Physical Device Direct Access Security and Privacy Risk</h5>
          <p>In case a script is compromised or misbehaving, the
            underlying physical device (and potentially surrounded
            environment) can be damaged if a script can use directly
            exposed native device interfaces. If such interfaces lack
            safety checks on their inputs, they might bring the
            underlying physical device (or environment) to an unsafe
            state (i.e. device overheats and explodes).</p>
          <dl>
            <dt>Mitigation:</dt>
            <dd>
              The
              <a href="#user-content-wot-runtime">WoT





                Runtime</a>
              should avoid directly exposing the native
              device interfaces to the script developers. Instead a
              <a href="#user-content-wot-runtime">WoT





                Runtime</a>
              implementation should provide a hardware
              abstraction layer for accessing the native device
              interfaces. Such hardware abstraction layer should refuse
              to execute commands that might put the device (or
              environment) to an unsafe state. Additionally, in order to
              reduce the damage to a physical WoT device in cases a
              script gets compromised, it is important to minimize the
              number of interfaces that are exposed or accessible to a
              particular script based on its functionality.
            </dd>
          </dl>
        </section>
        <section id="sec-security-consideration-update-provisioning">
          <h5>Provisioning and Update Security Risk</h5>
          <p>
            If the
            <a href="#user-content-wot-runtime">WoT Runtime</a>
            implementation supports post-manufacturing
            provisioning or updates of itself, WoT scripts, or any
            related data (including security credentials), it can be a
            major attack vector. An attacker can try to modify any above
            described element during the update or provisioning process
            or simply provision attacker's code and data directly.
          </p>
          <dl>
            <dt>Mitigation:</dt>
            <dd>
              Post-manufacturing provisioning or update of scripts,
              the
              <a href="#user-content-wot-runtime">WoT Runtime</a>
              itself or any related data should be
              done in a secure fashion. A set of recommendations for
              secure update and post-manufacturing provisioning can be
              found in [[!WOT-SECURITY-CONSIDERATIONS]].
            </dd>
          </dl>
        </section>
        <section id="sec-security-consideration-credentials-storage">
          <h5>Security Credentials Storage Security and Privacy Risk</h5>
          <p>
            Typically the
            <a href="#user-content-wot-runtime">WoT





              Runtime</a>
            needs to store the security credentials that
            are provisioned to a WoT device to operate in WoT network.
            If an attacker can compromise the confidentiality or
            integrity of these credentials, then it can obtain access to
            the WoT assets, impersonate WoT things or devices or create
            Denial-Of-Service (DoS) attacks.
          </p>
          <dl>
            <dt>Mitigation:</dt>
            <dd>
              The
              <a href="#user-content-wot-runtime">WoT Runtime</a>
              should securely store the provisioned
              security credentials, guaranteeing their integrity and
              confidentiality. In case there are more than one tenant on
              a single WoT-enabled device, a
              <a href="#user-content-wot-runtime">WoT Runtime</a>
              implementation should guarantee
              isolation of each tenant provisioned security credentials.
              Additionally, in order to minimize a risk that provisioned
              security credentials get compromised, the
              <a href="#user-content-wot-runtime">WoT Runtime</a>
              implementation should not expose any API
              for scripts to query the provisioned security credentials.
            </dd>
          </dl>
        </section>
      </section>
    </section>
    <section class="appendix">
      <h1>Example Sequences of interaction patterns (Informative)</h1>
      <p>
        <em>This section is non-normative.</em>
      </p>
      <p>This section illustrates example sequences of interaction
        patterns such as read propery, invoke action and event, among
        WoT client and WoT server.</p>
      <p>For the sake of simplicity, remote and local proxies between
        client and server are omitted from following sequences.</p>
      <section>
        <h2>Property</h2>
        <section>
          <h3>Read property (binding = HTTP)</h3>
          <p>Following sequence illustrates example sequence of read
            property operation with HTTP binding.</p>
          <p>
            <img src="images/A_1_1_readProperty.png" alt="Read property               (binding = HTTP)" />
          </p>
        </section>
        <section>
          <h3>Write property (binding = HTTP)</h3>
          <p>Following sequence illustrates example sequence of write
            property operation with HTTP binding.</p>
          <p>
            <img src="images/A_1_2_writeProperty.png" alt="Write               property (binding = HTTP)" />
          </p>
        </section>
        <section>
          <h3>Observe property (binding = HTTP Long Polling)</h3>
          <p>Following sequence illustrates example sequence of observe
            property operation with HTTP Long Polling binding.</p>
          <p>
            <img src="images/A_1_3a_observePropertyLongPoll.png" alt="Observe property (binding = HTTP Long Polling)" />
          </p>
        </section>
        <section>
          <h3>Observe property (binding = HTTP Server Sent Event)</h3>
          <p>Following sequence illustrates example sequence of observe
            property operation with HTTP Server Sent Event binding.</p>
          <p>
            <img src="images/A_1_3b_observePropertySSE.png" alt="Observe property (binding = HTTP Server Sent Event)" />
          </p>
        </section>
        <section>
          <h3>Observe property (binding = Simple WebSocket)</h3>
          <p>Following sequence illustrates example sequence of observe
            property operation with simple WebSocket binding.</p>
          <p>
            <img src="images/A_1_3c_observePropertyWebSocket.png" alt="Observe property (binding = simple WebSocket)" />
          </p>
        </section>
      </section>
      <section>
        <h2>Action</h2>
        <section>
          <h3>Invoke action (binding = HTTP)</h3>
          <p>Following sequence illustrates example sequence of invoke
            action operation with HTTP binding, where operation is
            synchronous and the request to server is blocked until
            action completes.</p>
          <p>
            <img src="images/A_2_1_invokeAction.png" alt="Invoke action               (binding = HTTP)" />
          </p>
          <p>Note: Action with asynchronous operation is subject to
            further study.</p>
        </section>
      </section>
      <section>
        <h2>Event</h2>
        <section>
          <h3>Subscribe, notify and unsubscribe event (binding = HTTP
            Long Polling)</h3>
          <p>Following sequence illustrates example sequence of
            subscribe, notify and unsubscribe event operation with HTTP
            Long Polling binding.</p>
          <p>
            <img src="images/A_3_1a_eventLongPoll.png" alt="Subscribe,               notify and unsubscribe event (binding = HTTP Long               Polling)" />
          </p>
        </section>
        <section>
          <h3>Subscribe, notify and unsubscribe event (binding = HTTP
            Server Sent Event)</h3>
          <p>Following sequence illustrates example sequence of
            subscribe, notify and unsubscribe event operation with HTTP
            Server Sent Event.</p>
          <p>
            <img src="images/A_3_1b_eventSSE.png" alt="Subscribe,               notify and unsubscribe event (binding = HTTP Server Sent               Event)" />
          </p>
        </section>
        <section>
          <h3>Subscribe, notify and unsubscribe event (binding = Simple
            WebSocket)</h3>
          <p>Following sequence illustrates example sequence of
            subscribe, notify and unsubscribe event operation with
            simple WebSocket binding.</p>
          <p>
            <img src="images/A_3_1c_eventWebSocket.png" alt="Subscribe,               notify and unsubscribe event (binding = simple WebSocket)" />
          </p>
        </section>
      </section>
    </section>
    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>Special thanks to all active Participants of the W3C Web of
        Things Interest Group and Working Group for their technical
        input and suggestions that led to improvements to this document.</p>
    </section>
    <!--
    <section class="appendix">
      <h2>Change History</h2>
      <p>
        This is the First Public Working Draft.
      </p>
    </section>
-->
    <script id="dstimer" language="javascript">//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]></script>
  </body>
</html>
