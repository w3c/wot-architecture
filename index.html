<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta charset="utf-8" />
<title>Web of Things (WoT) Architecture</title>
<script class="remove"
    src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
<script class="remove">
        var respecConfig = {
        lint: {
            "check-punctuation": true,
            "local-refs-exist": true,
            "no-http-props": true
        },
        specStatus : "ED",
        processVersion : 2017,
        shortName : "wot-architecture",
        copyrightStart : 2017,
        wg : "Web of Things Working Group",
        wgURI : "https://www.w3.org/WoT/WG/",
        wgPublicList : "public-wot-wg",
        edDraftURI : "https://w3c.github.io/wot-architecture/",
        githubAPI : "https://api.github.com/repos/w3c/wot-architecture",
        issueBase : "https://www.github.com/w3c/wot-architecture/issues",
        editors : [ {
            name : "Matthias Kovatsch",
            w3cid : "75998",
            company : "Huawei",
            companyURL : "https://www.huawei.com/"
        }, {
            name : "Kazuo Kajimoto",
            w3cid : "74112",
            company : "Panasonic Corp.",
            companyURL : "https://www.panasonic.com/"
        }, {
            name : "Ryuichi Matsukura",
            w3cid : "64284",
            company : "Fujitsu Ltd.",
            companyURL : "https://www.fujitsu.com/"
        }, {
            name : "Michael Lagally",
            w3cid : "47166",
            company : "Oracle Corp.",
            companyURL : "https://www.oracle.com/"
        }, {
            name : "Toru Kawaguchi",
            w3cid : "79307",
            company : "Panasonic Corp.",
            companyURL : "https://www.panasonic.com/"
        } ],
        otherLinks : [
                {
                    key : "Contributors",
                    data : [ {
                        value : "In the GitHub repository",
                        href : "https://github.com/w3c/wot-architecture/graphs/contributors"
                    } ]
                }, {
                    key : "Repository",
                    data : [ {
                        value : "We are on GitHub",
                        href : "https://github.com/w3c/wot-architecture/"
                    }, {
                        value : "File a bug",
                        href : "https://github.com/w3c/wot-architecture/issues"
                    } ]
                } ],
        localBiblio : {
            "CoRE-RD" : {
                href : "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11",
                title : "CoRE Resource Directory",
                status : "Internet-Draft",
                publisher : "IETF",
                date : "03 July 2017"
            },
/* ReSpec will pick up the citation it is officially published
            "wot-security" : {
                href : "https://www.w3.org/TR/wot-security/",
                // href: "https://cdn.staticaly.com/gh/w3c/wot-security/master/index.html?env=dev",
                title : "Web of Things (WoT) Security and Privacy Considerations",
                // status: "Editor's Draft (will be W3C NOTE in final version)",
                status: "W3C Note",
                publisher : "W3C"
            },
*/
            "TAG-REVIEW-WOT-THING-DESCRIPTION" : {
                href: "https://cdn.staticaly.com/gh/w3c/wot-thing-description/TD-TAG-review/index.html?env=dev",
                title : "Web of Things (WoT) Thing Description",
                status: "Editor's Draft for TAG Review",
                publisher : "W3C"
            },
            "WOT-SECURITY-BEST-PRACTICES" : {
                // href : "https://www.w3.org/TR/wot-security-best-practices/",
                href: "https://cdn.staticaly.com/gh/w3c/wot-security-best-practices/master/index.html?env=dev",
                title : "Web of Things (WoT) Security Best Practices",
                status: "Editor's Draft (will be W3C NOTE in final version)",
                publisher : "W3C"
            },
            "WOT-SECURITY-TESTING-PLAN" : {
                // href : "https://www.w3.org/TR/wot-security-testing-plan/",
                href: "https://cdn.staticaly.com/gh/w3c/wot-security-testing-plan/master/index.html?env=dev",
                title : "Web of Things (WoT) Security Best Practices",
                status: "Editor's Draft (will be W3C NOTE in final version)",
                publisher : "W3C"
            },
            "IEC-FOTF" : {
                href : "https://www.iec.ch/whitepaper/pdf/iecWP-futurefactory-LR-en.pdf",
                title : "Factory of the future",
                publisher : "IEC",
                date : "October 2015"
            },
            "iot-schema-org" : {
                href : "https://iot.schema.org/",
                title : "iot.schema.org"
            },
            "REST" : {
                title : "REST: Architectural Styles and the Design of Network-based Software Architectures",
                author : "Roy Thomas Fielding",
                status : "PhD thesis",
                publisher : "University of California, Irvine",
                date : "2000"
            },
            "SAREF" : {
                href : "https://sites.google.com/site/smartappliancesproject/ontologies/reference-ontology",
                title : "Smart Appliances REFerence (SAREF) ontology",
                publisher : "ETSI",
                date : "November 2015"
            },
            "SSN" : {
                href : "https://www.w3.org/TR/vocab-ssn/",
                title : "Semantic Sensor Ontology",
                publisher : "W3C",
                date : "October 2017"
            },
            "HCI" : {
                title : "The Encyclopedia of Human-Computer Interaction, 2nd Ed",
                author : "Mads Soegaard, Rikke Friis Dam",
                publisher : "Interaction Design Foundation",
                date : "2013"
            },
            "NORMAN" : {
                title : "The Psychology of Everyday Things",
                author : "Donald A. Norman",
                publisher : "Basic Books",
                date : "1988"
            },
            "MQTT" : {
                title : "MQTT Version 3.1.1",
                author : "Andrew Banks, Rahul Gupta",
                publisher : "OASIS Standard",
                date : "2014"
            },
            "FORMS" : {
                href : "https://tools.ietf.org/html/draft-hartke-t2trg-coral",
                title : "The Constrained RESTful Application Language (CoRAL)",
                author : "Klaus Hartke",
                publisher : "IETF",
                status : "Internet-Draft",
                date : "2019"
            }
        }
    };
</script>
<style type="text/css">
a[href].internalDFN {
        color: inherit;
        border-bottom: 1px solid #99c;
        text-decoration: none;
}
</style>
</head>
<body>
    <section id="abstract">
        <p>The W3C Web of Things (WoT) was created to enable
            interoperability across IoT Platforms and application
            domains.</p>
        <p>WoT provides mechanisms to formally describe IoT
            interfaces to allow IoT devices and services to communicate
            with each other, independent of their underlying
            implementation, and across multiple networking protocols. In
            addition WoT offers a standardized way to define and program
            IoT behavior.</p>

        <p>This WoT Architecture document describes the abstract
            architecture for the W3C Web of Things. It is derived from a
            set of requirements that were derived from use cases for
            multiple application domains. The architecture can be mapped
            onto a variety of concrete deployment scenarios, several
            examples of which are given.</p>
        <p>The document is focused on the scope of W3C WoT
            standardization, which consists of three initial building
            blocks. These are described by additional WoT
            specifications:</p>
        <ul>
            <li>the <em>Web of Things (WoT)
                    Thing Description</em> [[wot-thing-description]],
            </li>
            <li>the <em>Web of Things (WoT)
                    Binding Templates</em> [[wot-binding-templates]], and
            </li>
            <li>the <em>Web of Things (WoT)
                    Scripting API</em> [[wot-scripting-api]].
            </li>
        </ul>

        <p>
            The <a>WoT Thing Description</a> is the primary building
            block, as it describes the network-facing interface of a
            Thing (<a>WoT Interface</a>).
        </p>
        <p>
            The optional <a>WoT Binding Templates</a> can be used to
            describe multiple protocol bindings, so that a <a>Thing</a>
            can communicate with different <a>IoT Platforms</a> (i.e.,
            IoT ecosystems or standards).
        </p>
        <p>
            The optional <a>WoT Scripting API</a> enables implementation of
            the application logic of a Thing using a standardized
            contract for JavaScript. This simplifies IoT application
            development and enables portability across vendors and WoT
            network components.
        </p>

        <p>Other non-normative architectural blocks and conditions
            underlying the Web of Things are also described in the
            context of deployment scenarios. In particular,
            recommendations for security and privacy are included in:
        <ul>
            <li>the <em>Web of Things (WoT)
                    Security and Privacy Considerations</em> [[wot-security]],
            </li>
            <li>the <em>Web of Things (WoT)
                    Security Best Practices</em> [[WOT-SECURITY-BEST-PRACTICES]], and
            </li>
            <li>the <em>Web of Things (WoT)
                    Security Testing Plan</em> [[WOT-SECURITY-TESTING-PLAN]].
            </li>
        </ul>
        </p>
        <p>Overall, the goal is to preserve and support existing
            security mechanisms and properties. In general, W3C WoT is
            designed to describe what exists rather than to prescribe
            what to implement.</p>

    </section>
    <section id="sotd">
        <p class="ednote" title="The W3C WoT WG is asking for feedback">
            Please contribute to this draft using the <a
                href="https://github.com/w3c/wot-architecture/issues">GitHub
                Issue</a> feature of the <a
                href="https://github.com/w3c/wot-architecture/">WoT
                Architecture</a> repository. For feedback on security and
            privacy considerations, please use the <a
                href="https://github.com/w3c/wot-security/issues">WoT
                Security and Privacy</a> Issues, as they are cross-cutting
            over all our documents.
        </p>
    </section>
    <section id="introduction">
        <h1>Introduction</h1>
        <p>
            The "Web of Things" (WoT) started as an academic initiative
            in the form of publications and, starting in 2010, a yearly
            <a href="https://webofthings.org/events/">International
                Workshop on the Web of Things</a> . Its goal is to improve
            interoperability as well as usability in the Internet of
            Things (IoT). With the increasing role of IoT services using
            other web standards in commercial and industrial
            applications, the W3C chartered an <a
                href="https://www.w3.org/WoT/IG/">Interest Group</a> in
            2015 to identify technological building blocks for
            Recommendation Track standardization. With the WoT <a
                href="https://www.w3.org/WoT/WG/">Working Group</a>
            chartered end of 2016, the first set of WoT building blocks
            has now being standardized:
        </p>
        <ul>
            <li>the <em>Web of Things (WoT)
                    Thing Description</em> [[wot-thing-description]],
            </li>
            <li>the <em>Web of Things (WoT)
                    Binding Templates</em> [[wot-binding-templates]], and
            </li>
            <li>the <em>Web of Things (WoT)
                    Scripting API</em> [[wot-scripting-api]].
            </li>
        </ul>

        <p>This document serves as an umbrella for the W3C WoT draft
            specifications and defines the basics such as terminology
            and the underlying abstract architecture of the W3C Web of
            Things. In particular, the purpose of this document is to
            provide:</p>
        <ul>
            <li>a set of use cases that lead to the W3C WoT
                Architecture in chapter <a href="#sec-use-cases"></a>,
            </li>
            <li>a set of requirements for WoT implementations in
                chapter <a href="#sec-requirements"></a>,
            </li>
            <li>a description of the high level architecture in
                chapter <a href="#sec-wot-architecture"></a>
            </li>
            <li>an overview of the WoT building blocks being
                standardized and their interplay in chapter <a
                href="#sec-building-blocks"></a>,
            </li>
            <li>a guideline to map the abstract architecture to
                software stacks and hardware components in chapter <a
                href="#sec-servient-implementation"></a>,
            </li>
            <li>deployment scenarios in chapter <a
                href="#sec-deployment-scenario"></a>,
            </li>
            <li>and security considerations to be aware of when
                implementing WoT building blocks in chapter <a
                href="#sec-security-considerations"></a>.
            </li>
        </ul>
    </section>
    <section id="conformance"></section>
    <section id="terminology">
        <h1>Terminology</h1>
        <p>
            <em>This section is normative.</em>
        </p>

        <p>This document uses the following terms as defined here.
            The WoT prefix is used to avoid ambiguity for terms that are
            defined specifically for Web of Things concepts.</p>
        <dl>
            <dt>
                <dfn>Action</dfn>
            </dt>
            <dd>An Interaction Affordance that allows to invoke a
                function of the Thing, which manipulates state
                (e.g., toggling a lamp on or off)
                or triggers a process on the Thing (e.g., dimm a lamp over time).</dd>
            <dt>
                <dfn>Application</dfn>
            </dt>
            <dd>A running or periodically running process that
                consumes one or more Things (read and processes there
                data, control their state) and/or exposes one or more
                Things (provide access to locally gathered data or
                computed from consumed Things, provide remote control
                and management interfaces). The application can be
                implemented using the Scripting API or native platform
                APIs. The application may also be distributed over
                multiple Things and other hosts.</dd>
            <dt>
                <dfn data-lt="WoT Binding Templates">Binding
                    Templates</dfn>
            </dt>
            <dd>A re-usable collection of blueprints for the
                communication with different IoT platforms. The
                blueprints includes the required vocabulary for the
                Thing Description to map Interactions to
                platform-specific messages as well as implementation
                notes for the required protocol stacks or dedicated
                communication drivers.</dd>
            <dt>
                <dfn>to consume a Thing</dfn>
            </dt>
            <dd>To read a Thing Description and create a Consumed
                Thing software object for the application in the local
                runtime environment.</dd>
            <dt>
                <dfn>Consumed Thing</dfn>
            </dt>
            <dd>A software abstraction that represents a remote
                Thing used by the local application. The abstraction might be
                created by a native WoT Runtime, or instantiated
                as an object by a Scripting API implementation.</dd>
            <dt>
                <dfn>Consumer</dfn>
            </dt>
            <dd>An entity that can process the WoT Thing Description format
                and interact with Things (i.e., consume Things).</dd>
            <dt>
                <dfn>Digital Twin</dfn>
            </dt>
            <dd>A digital twin is a virtual representation of a
                device or a group of devices that resides on a cloud
                server, edge device, or proxy. It can be used to represent
                real-world devices which may not be continuously online,
                or to run simulations of new applications and services,
                before they get deployed to the real devices.</dd>
            <dt>
                <dfn>Domain-specific vocabulary</dfn>
            </dt>
            <dd>Linked Data vocabulary that can be used in the WoT
                Thing Description, but is not defined by W3C WoT.</dd>
            <dt>
                <dfn>Edge device</dfn>
            </dt>
            <dd>a device which provides an entry point into
                enterprise or service provider core networks. Examples
                include gateways, routers, switches, multiplexers, and a
                variety of other access devices.</dd>
            
            <dt>
                <dfn>Event</dfn>
            </dt>
            <dd>An Interaction Affordance that describes an event source,
                which asynchronously pushes event data to Consumers
                (e.g., overheating alerts).</dd>
            <dt>
                <dfn>Execution Environment</dfn>
            </dt>
            <dd>A sandbox within the WoT Runtime that isolates scripts
                running on the same Servient.</dd>
            <dt>
                <dfn>to expose a Thing</dfn>
            </dt>
            <dd>To create an Exposed Thing software object in the
                local runtime environment that enables the application
                to provide local state and calls as Interactions over
                the network.</dd>
            <dt>
                <dfn>Exposed Thing</dfn>
            </dt>
            <dd>A software abstraction that represents a Thing 
                implemented locally that be accessed over the network by remote
                Consumers. 
                The abstraction might be
                created by a native WoT Runtime, or instantiated
                as an object by a Scripting API implementation.</dd>
            <dt>
                <dfn>Hypermedia Control</dfn>
            </dt>
            <dd>A serialization of a Protocol Binding in hypermedia, that is,
                either a Web link [[!RFC8288]] for navigation or a Web form for
                performing other operations. Forms can be seen as request templates
                provided by the Thing to be completeted and sent by the Consumer.</dd>
            <dt>
                <dfn>Interaction Affordance</dfn>
            </dt>
            <dd>
                Metadata of a Thing that shows and describes the possible choices to Consumers,
                thereby suggesting how Consumers may interact with the Thing.
                There are many types of potential affordances, but 
                W3C WoT defines three types of Interaction Affordances:
                Properties, Actions, and Events.</dd>
            <dt>
                <dfn>Interaction Model</dfn>
            </dt>
            <dd>An intermediate abstraction that formalizes the
                mapping from application intent to concrete protocol
                bindings, which are used to interact with Web resources.</dd>
            <dt>
                <dfn>IoT platform</dfn>
            </dt>
            <dd>A specific IoT ecosystem such as OCF, oneM2M, or
                Mozilla Project Things with its own specifications for
                application-facing APIs, data model, and protocols or
                protocol configurations.</dd>
            <dt>
                <dfn>Property</dfn>
            </dt>
            <dd>An Interaction Affordance that exposes state of the Thing.
                This state can then be retrieved (read) and optionally updated (write).
                Things can also choose to make Properties observable by pushing the new
                state after a change.</dd>
            <dt>
                <dfn data-lt="WoT Protocol Binding">Protocol Binding</dfn>
            </dt>
            <dd>The mapping from an Interaction Affordance to concrete messages of a specific protocol,
                thereby informing Consumers how to activate the Interaction Affordance.
                W3C WoT serializes Protocol Bindings as hypermedia controls.</dd>
            <dt>
                <dfn>Scripting Runtime</dfn>
            </dt>
            <dd>A runtime system that is used for implementing an
                API in a scripting language (e.g. using ECMAScript, LUA,
                Python etc.).</dd>
            <dt>
                <dfn>Servient</dfn>
            </dt>
            <dd>A software stack that implements the WoT building
                blocks. A Servient can host and expose Things and/or host Consumers that consume Things.
                Servients can support multiple Protocol Bindings to enable
                interaction with different IoT platforms.</dd>
            <dt>
                <dfn>Subprotocol</dfn>
            </dt>
            <dd>An extension mechanism to a transfer protocol that
                must be known to interact successfully.</dd>
            <dt>
                <dfn>TD</dfn>
            </dt>
            <dd>Short for Thing Description.</dd>
            <dt>
                <dfn>TD Vocabulary</dfn>
            </dt>
            <dd>A controlled Linked Data vocabulary by W3C WoT to
                tag the metadata of Things in the WoT Thing Description
                including communication metadata of WoT Binding
                Templates.</dd>
            <dt>
                <dfn>Thing</dfn> or <dfn>Web Thing</dfn>
            </dt>
            <dd>An abstraction of a physical or a virtual entity
                whose metadata and interfaces are described by a WoT
                Thing Description, whereas a virtual entity is the
                composition of one or more Things.</dd>
            <dt>
                <dfn data-lt="WoT Thing Description">Thing
                    Description</dfn>
            </dt>
            <dd>Structured data describing a Thing. A TD includes
                metadata, domain-specific metadata, a list of offered
                interactions, the supported protocol bindings for each
                interaction, and links to related Things. The Thing
                Description is built around a formal Interaction Model.</dd>
            <dt>
                <dfn>Thing Directory</dfn>
            </dt>
            <dd>A directory service for TDs that provides a Web
                interface to register TDs (see [[CoRE-RD]]) and look
                them up (e.g., using SPARQL queries or CoRE Link
                Format).</dd>
            <dt>
                <dfn>Transfer Protocol</dfn>
            </dt>
            <dd>The underlying, standardized application layer
                protocol without application-specific options or
                subprotocol mechanisms.</dd>
            <dt>
                <dfn>Virtual Thing</dfn>
            </dt>
            <dd>An instance of a Thing that represents a Thing that is located 
                on another system component.</dd>
            <dt>
                <dfn>WoT Interface</dfn>
            </dt>
            <dd>The network-facing interface of a Thing
                that is described by a Thing Description.</dd>
            <dt>
                <dfn>WoT Runtime</dfn>
            </dt>
            <dd>A runtime system that maintains an execution
                environment for applications, and is able to expose and
                optionally consume TDs, offers a protocol binding to one
                or more protocols, and maintains private security
                metadata.</dd>
            <dt>
                <dfn>WoT Scripting API</dfn>
                or the
                <dfn>Scripting API</dfn>
            </dt>
            <dd>The application-facing programming interface
                optionally provided by a Servient in order to to ease
                the implementation of applications running in a WoT
                Runtime. It is comparable to the Web browser APIs.</dd>
            <dt>
                <dfn>WoT Server</dfn>
            </dt>
            <dd>An entity that exposes a network interface
                consistent with a WoT Thing Description. WoT Server is
                also used to refer to a Servient in server role only.</dd>  
            <dt>
                <dfn>WoT Servient</dfn>
                <dd>Synonym for Servient.</dd>
            </dt>
            <dd>
        </dl>
    </section>

    <section id="sec-use-cases" class="informative">
        <h1>Use Cases</h1>

        <p>
            This section presents the application domains and use cases
            targeted by the W3C WoT and which are used to derive the
            abstract architecture discussed in <a
                href="#sec-building-blocks"></a>.
        </p>
        <p>The Web of Things architecture does not put any
            limitations on use cases and application domains. Various
            application domains have been considered to collect common
            patterns that have to be satisfied by the abstract
            architecture.</p>
        <p>The following sections are not exhaustive. Rather they
            serve as illustrations, where connected things can provide
            additional benefit or enable new scenarios.</p>
        <section id="sec-application-domains">
            <h2>Application Domains</h2>
            <section id="consumer-use-cases">
                <h3>Consumer</h3>
                <p>In the consumer space there are multiple assets
                    that benefit from being connected. Lights and air
                    conditioners can be turned off based on room
                    occupancy. Window blinds can be closed automatically
                    based on weather conditions and presence. Energy and
                    other resource consumption can be optimized based on
                    usage patterns and predictions.</p>
                <p>The consumer use cases in this section includes
                    Smart Home use case.</p>
                <p>
                    <a href="#smart-home"></a> shows an example of a
                    Smart Home. In this case, gateways are connected to
                    edge devices such as sensors, cameras and home
                    appliances through corresponding local communication
                    protocols such as KNX, ECHONET, ZigBee, DECT ULE and
                    Wi-SUN. Multiple gateways can exist in one home,
                    while each gateway can support multiple local
                    protocols.
                </p>
                <p>Gateways can be connected to the cloud through
                    the internet, while some appliances can be connected
                    to the cloud directly. Services running in the cloud
                    collect data from edge devices and analyze the data,
                    then provide value to users through the edge devices
                    and other UX devices.</p>
                <figure id="smart-home">
                    <img src="images/wot-use-cases/smart-home.png"
                        style="width: 640px;" />
                    <figcaption>Smart Home</figcaption>
                </figure>
                <p>Smart home provides consumer benefits such as
                    remote access and control, voice control and home
                    automation. Smart home also enables device
                    manufacturers to monitor and maintain devices
                    remotely. Smart home can realizes added value
                    services such as energy management and security
                    surveillance.</p>
            </section>
            <section id="industrial-iot-usecases">
                <h3>Industrial</h3>
                <p>
                    The industrial use cases in this section are
                    applicable to different industry verticals. <br />
                    Due to the nature of overlaps in the application
                    scenarios, different verticals have similar use
                    cases.
                </p>
                <section>
                    <h4>Example: Smart Factory</h4>
                    <p>
                        <a href="#smart-factory"></a> shows an example
                        of a Smart Factory. In this case, field-level,
                        cell and line controllers automate different
                        factory equipment based on industrial
                        communication protocols such as Profinet,
                        Modbus, OPC UA TSN, EtherCAT, or CAN. An
                        industrial edge device collects selected data
                        from various controllers and makes it available
                        to a cloud backend service, e.g. for remote
                        monitoring via a dashboard or analyzes it for
                        preventive maintenance.
                    </p>
                    <figure id="smart-factory">
                        <img
                            src="images/wot-use-cases/smart_factory_new.png"
                            style="width: 640px;" />
                        <figcaption>Smart Factory</figcaption>
                    </figure>
                </section>
                <p>Smart factories require advanced monitoring of
                    the connected manufacturing equipment as well of the
                    manufactured products. They benefit from predictions
                    of machine failures and early discovery of anomalies
                    to prevent costly downtime and maintenance efforts.</p>
                <p>Additionally, monitoring of connected
                    manufacturing equipment and the environment at the
                    production facility for the presence of poisonous
                    gases, excessive noise or heat increases the safety
                    of the workers and reduces the risks of incidents or
                    accidents.</p>
                <p>Real-time monitoring and KPI calculations of
                    production equipment helps to detect productivity
                    problems and optimize the supply chain.</p>
            </section>
            <section id="sec-transportationlogistics">
                <h4 id="transportationlogistics">Transportation
                    &amp; Logistics</h4>
                <p>Monitoring of vehicles, fuel costs, maintenance
                    needs and assignments helps to optimize the full
                    utilization of the vehicle fleet.</p>
                <p>Shipments can be tracked to be en-route to ensure
                    consistent quality and condition of the transported
                    goods. This is especially useful to assert the
                    integrity of the cold-chain from warehouses to
                    refrigerated trucks to delivery.</p>
                <p>Centralized monitoring and management of stock in
                    warehouses and yards can prevent out of stock and
                    excessive stock situations.</p>
            </section>
            <section id="sec-utilities">
                <h4 id="utilities">Utilities</h4>
                <p>Automated reading of residential and C&amp;I
                    (Commercial and Industrial) meters, and billing
                    offers continuous insights into resource consumption
                    and potential bottlenecks.</p>
                <p>Monitoring the condition and output of
                    distributed renewable energy generation equipment
                    enables optimization of distributed energy
                    resources.</p>
                <p>Monitoring and remote-controlling of distribution
                    equipment helps to automate the distribution
                    process.</p>
                <p>Continuous monitoring of generation and
                    distribution infrastructure is improving safety of
                    utilities crew in the field.</p>
            </section>
            <section id="sec-oilandgas">
                <h4 id="oilandgas">Oil and Gas</h4>
                <p>Offshore platform monitoring, leakage detection
                    and prediction of pipelines as well as monitoring
                    and controlling the levels in tanks and reservoirs
                    helps to improve the industrial safety for the
                    workforce as well as for the environment.</p>
                <p>Automated calculation of a distributed stock
                    through various storage tanks and delivery
                    pipes/trucks allows for improved planning and
                    resource optimization.</p>
            </section>
            <section id="sec-insurance">
                <h4 id="insurance">Insurance</h4>
                <p>Proactive Asset Monitoring of high value assets
                    such as connected structures, fleet vehicles, etc.
                    mitigates the risk of severe damage and high costs
                    due to predictions and early detection of incidents.</p>
                <p>Usage based insurance can be offered with usage
                    tracking and customized insurance policies.</p>
                <p>Predictive weather monitoring and re-routing
                    fleet vehicles to covered garages can limit loss due
                    to hail damage, tree damage.</p>
            </section>
            <section id="sec-engineering-and-construction">
                <h4 id="engineering-and-construction">Engineering
                    and Construction</h4>
                <p>Monitoring for industrial safety reduces the
                    risks of security hazards. Monitoring of assets at
                    construction site can prevent damage and loss.</p>
            </section>

            <section id="sec-agriculture">
                <h3 id="agriculture">Agriculture</h3>
                <p>Soil condition monitoring and creating optimal
                    plans for watering, fertilizing as well as
                    monitoring the produce conditions optimize the
                    quality and output of agricultural produce.</p>
            </section>
            <section id="sec-healthcare">
                <h3 id="healthcare">Healthcare</h3>
                <p>Data collection and analytics of clinical trial
                    data helps to gain insights into new areas.</p>
                <p>Remote patient monitoring mitigates the risk of
                    undetected critical situations for elderly people
                    and patients after hospitalization.</p>
            </section>
            <section id="sec-environmentmonitoring">
                <h3 id="environmentmonitoring">Environment
                    Monitoring</h3>
                <p>Environment monitoring typically relies on a lot
                    of distributed sensors that send their measurement
                    data to common gateways, edge devices and cloud
                    services.</p>
                <p>Monitoring of air pollution, water pollution and
                    other environmental risk factors such as fine dust,
                    ozone, volatile organic compound, radioactivity,
                    temperature, humidity to detect critical environment
                    conditions can prevent unrecoverable health or
                    environment damages.</p>
            </section>
            <section id="sec-smart-cities">
                <h3 id="smartcities">Smart Cities</h3>
                <p>Monitoring of Bridges, Dams, Levees, Canals for
                    material condition, deterioration, vibrations
                    discovers maintenance repair work and prevents
                    significant damage. Monitoring of highways and
                    providing appropriate signage ensures optimized
                    traffic flow.</p>
                <p>Smart Parking is optimizing and tracking the
                    usage and availability of parking spaces and
                    automates billing/reservations.</p>
                <p>Smart control of street lights based on presence
                    detection, weather predictions, etc reduced cost.</p>
                <p>Garbage containers can be monitored to optimize
                    the waste management and the trash collection route.</p>
            </section>
            <section id="sec-smart-buildings">
                <h3 id="smartbuildings">Smart Buildings</h3>
                <p>Monitoring the energy usage throughout the
                    building helps to optimize resource consumption and
                    reduce waste.</p>
                <p>Monitoring the equipment in the buildings such as
                    HVAC, Elevators, etc. and fixing problems early
                    improves the satisfaction of occupants.</p>
            </section>
            <section id="sec-connected-car">
                <h3 id="connectedcar">Connected Car</h3>
                <p>Monitoring of operation status, prediction of
                    service needs optimizes maintenance needs and costs.
                    Driver safety is enhanced with notifications of an
                    early warning system for critical road and traffic
                    conditions.</p>
                <section id="connected car example">
                    <h4 id="connectedcar-example">Connected Car
                        Example</h4>
                    <p>
                        <a href="#connected-car"></a> shows an example
                        of a Connected Car. In this case, a gateway
                        connects to car components through CAN and to
                        the car navigation system through a proprietary
                        interface. Services running in the cloud collect
                        data pushed from car components and analyze the
                        data from multiple cars to determine traffic
                        patterns. The gateway can also consume cloud
                        services, in this case, to get traffic data and
                        show it to the driver through the car navigation
                        system.
                    </p>
                    <figure id="connected-car">
                        <img
                            src="images/wot-use-cases/connected-car.png"
                            style="width: 500px;" />
                        <figcaption>Connected Car</figcaption>
                    </figure>
                </section>
                <p>Monitoring of operation status, prediction of
                    service needs optimizes maintenance needs and costs.
                    Driver safety is enhanced with notifications of an
                    early warning system for critical road and traffic
                    conditions.</p>
            </section>
        </section>



        <section id="sec-common-usecase-patterns">
            <h1>Common Patterns</h1>
            <p>
            This section introduces common use case patterns that
            illustrate how devices/things interact with controllers,
            other devices, agents and servers.
            In this section, we use the term 'client roles' as an
            initiator of a transport protocol, and the term 'server roles'
            as a passive component of a transport protocol.
            </p>
        
            <section id="device-controllers">
                <h3>Device Controllers</h3>
                <p>
                    The first use case is a local device controlled by a
                    user-operated remote controller as depicted in <a
                        href="#smart-home-device"></a>. A remote
                    controller can access an electronic appliance
                    through the local home network directly. In this
                    case, the remote controller can be implemented by a
                    browser or native application.
                </p>
                <p>In this pattern, at least one device like the
                    electronic appliance has a server role that can
                    accept a request from the other devices and responds
                    to them, and sometimes initiates a mechanical
                    action. The other device like the remote controller
                    has a client role that can send a message with a
                    requests, like to read a sensor value or to turn on
                    the device.
                    Moreover, to emit a current state or event notification of a device,
                    the device may have a client role that can send a message
                    to another device, which has server roles.
                </p>
                <figure id="smart-home-device">
                    <img
                        src="images/wot-use-cases/smart-home-device.png"
                        style="width: 500px;" />
                    <figcaption>Device Control</figcaption>
                </figure>
            </section>
            <section>
                <h3>Thing-to-Thing</h3>
                <p>
                    <a href="#smart-home-t2t"></a> shows an example of a
                    direct Thing-to-Thing interaction. The scenario is
                    as follows: a sensor detects a change of the room
                    condition, for example the temperature exceeding a
                    threshold, and issues a control message like "turn
                    on" to the electronic appliance. The sensor unit can
                    issue some trigger messages to other devices.
                </p>
                <p>In this case, when two devices that have server
                    roles are connected, at least one device must have
                    also a client role that issues a message to the
                    other to actuate or notify.</p>
                <figure id="smart-home-t2t">
                    <img src="images/wot-use-cases/smart-home-t2t.png"
                        style="width: 500px;" />
                    <figcaption>Control Agent</figcaption>
                </figure>
            </section>
            <section>
                <h3>Remote Access</h3>
                <p>
                    This use case contains a mobile remote controller
                    (e.g., on a smartphone) as shown in <a
                        href="#smart-home-multi"></a>. The remote
                    controller can switch between different network
                    connections and protocols, e.g. between a cellular
                    network and a home network, which is using protocols
                    such as Wi-Fi and Bluetooth. When the controller is
                    in the home network it is a trusted device and no
                    additional security or access control is required.
                    When it is outside of the trusted network,
                    additional access control and security mechanisms
                    must be applied to ensure a trusted relationship.
                    Note that in this scenario the network connectivity
                    may change due to switching between different
                    network access points or cellular base stations.
                </p>
                <p>
                    In this pattern, the remote controller and the
                    electronic appliance have a client and a server role
                    as in the related scenario in <a
                        href="#smart-home-device"></a>.
                </p>
                <figure id="smart-home-multi">
                    <img src="images/wot-use-cases/smart-home-multi.png"
                        style="width: 500px;" />
                    <figcaption>Multiple Network Interfaces</figcaption>
                </figure>
            </section>
            <section>
                <h3>Smart Home Gateways</h3>
                <p>
                    <a href="#smart-home-gateway"></a> shows a use case
                    using a Smart Home gateway. The smart home gateway
                    is placed between a home network and the Internet.
                    The gateway manages electronic appliances inside the
                    house and can receive commands from a remote
                    controller over the Internet, e.g., from a
                    smartphone as in the previous use case. It is also
                    is a virtual representation of a device. The smart
                    home gateway typically offers proxy and firewall
                    functionality.
                </p>
                <p>In this pattern, the home gateway has both a
                    client and a server role. When the remote controller actuates the electronic appliance,
                    it can connect to the
                    electronic appliance in the client role and to the
                    remote controller with the server role.
                    When the electronic appliance emits a message to the
                    remote controller, the gateway act as server roles
                    for the electric appliance, and it act as client roles
                    for the remote controller.
                 </p>
                <figure id="smart-home-gateway">
                    <img
                        src="images/wot-use-cases/smart-home-gateway.png"
                        style="width: 500px;" />
                    <figcaption>Smart Home Gateway</figcaption>
                </figure>
            </section>
            <section>
                <h3>Edge Devices</h3>
                <p>
                    An Edge Device or Edge Gateway is similar to a Smart
                    Home gateway. We use the term to indicate additional
                    tasks that are carried out by the edge gateway.
                    Whereas the home gateway in <a
                        href="#edge-device"></a> primarily just
                    bridges between the public and the trusted network,
                    the edge device has local compute capabilities and
                    typically bridges between different protocols. Edge
                    devices are typically used in industrial solutions,
                    where they can provide preprocessing, filtering and
                    aggregation of data provided by connected devices
                    and sensors.
                </p>
                <figure id="edge-device">
                    <img src="images/wot-use-cases/edge-device.png"
                        style="width: 500px;" />
                    <figcaption>Edge device</figcaption>
                </figure>
            </section>
            <section>
                <h3>Digital Twins</h3>
                <p>A digital twin is a virtual representation, i.e.
                    a model of a device or a group of devices that
                    resides on a cloud server or edge device. It can be
                    used to represent real-world devices which may not
                    be continuously online, or to run simulations of new
                    applications and services, before they get deployed
                    to the real devices.</p>
                <figure id="digital-twin">
                    <img src="images/wot-use-cases/digital-twin.png"
                        style="width: 500px;" />
                    <figcaption>Digital Twin</figcaption>
                </figure>
                <p>Digital twins can model a single device, or they
                    can aggregate multiple devices in a virtual
                    representation of the combined devices.</p>
                <figure id="digital-twin-multiple-devices">
                    <img
                        src="images/wot-use-cases/digital-twin-multiple-devices.png"
                        style="width: 500px;" />
                    <figcaption>Digital Twin for Multiple
                        Devices</figcaption>
                </figure>

                <p>Digital twins can be realized in different ways,
                    depending on whether a device is already connected
                    to the cloud, or whether it is connected to a
                    gateway, which itself is connected to the cloud.</p>
                <section>
                    <h4>Cloud-ready Devices</h4>
                    <p>
                        <a href="#smart-home-cloud1"></a> shows an
                        example where electronic appliances are
                        connected directly to the cloud. The cloud
                        mirrors the appliances and, acting as a digital
                        twin, can receive commands from remote
                        controllers (e.g., a smartphone). Authorized
                        controllers can be located anywhere, as the
                        digital twin is globally reachable.

                    </p>
                    <figure id="smart-home-cloud1">
                        <img
                            src="images/wot-use-cases/smart-home-cloud1a.png"
                            style="width: 500px;" />
                        <figcaption>Appliance twin for a
                            Cloud-ready Devices</figcaption>
                    </figure>
                </section>
                <section>
                    <h3>Legacy Devices</h3>
                    <p>
                        <a href="#smart-home-cloud2"></a> shows an
                        example where legacy electronic appliances
                        cannot directly connect to the cloud. Here, a
                        gateway is needed to relay the connection. The
                        gateway works as:
                    </p>
                    <ul>
                        <li>integrator of a variety of legacy
                            communication protocols both in the physical
                            and logical view</li>
                        <li>firewall toward the Internet</li>
                        <li>privacy filter which substitutes real
                            image and/or speech, and logs data locally</li>
                        <li>local agent in case the network
                            connection is interrupted</li>
                        <li>emergency services running locally when
                            fire alarms and similar events occur</li>
                    </ul>
                    <p>The cloud mirrors the gateway with all
                        connected appliances and acts as a digital twin
                        that manages them in the cloud in conjunction
                        with the gateway. Furthermore, the cloud can
                        receive commands from remote controllers (e.g.,
                        a smartphone), which can be located anywhere.</p>
                    <figure id="smart-home-cloud2">
                        <img
                            src="images/wot-use-cases/smart-home-cloud2.png"
                            style="width: 500px;" />
                        <figcaption>A Digital Twin for a
                            Legacy Device</figcaption>
                    </figure>
                </section>
            </section>
            <section>
                <h3>Multi-Cloud</h3>
                <p>Typical IoT deployments consist of multiple
                    (thousands) of devices. Without a standardized
                    mechanism, the management of firmware updates for
                    specific clouds require a lot of effort and hinders
                    wider scale IoT adoption.</p>
                <p>The primary benefit of a standardized mechanism
                    for describing devices and device types is the
                    capability of deploying devices to different cloud
                    environments without the need of doing customization
                    at device software / firmware level, i.e. installing
                    cloud specific code to a device. This implies that
                    the solution is flexible enough to describe devices
                    in a way that allows on-boarding and using devices
                    in multiple IoT cloud environments.</p>
                <p>This drives adoption of Web of Things devices,
                    since it enables easy usage of new devices in an
                    existing deployment, as well as migration of
                    existing devices from one cloud to the other.</p>
            </section>

            <section>
                <h3>Cross-domain Collaboration</h3>
                <p>
                    <a href="#cross-domain"></a> show an example of a
                    cross-domain collaboration. In this case, each
                    system involves other systems in other domains, such
                    as Smart Factory with Smart City, Smart City with
                    Smart Home. This type of system is called
                    "Symbiotic" ecosystem, as shown in [[IEC-FOTF]].
                    There are two collaboration models: direct
                    collaboration and indirect collaboration. In the
                    direct collaboration model, systems exchange
                    information directly with each other in a
                    peer-to-peer manner. In the indirect collaboration,
                    systems exchange information via some collaboration
                    platform. In order to maintain and continue this
                    collaboration, each system provides the metadata of
                    their capabilities and interfaces and adapts itself
                    to others.
                </p>
                <figure id="cross-domain">
                    <img src="images/cross-domain-direct.png"
                        style="width: 500px;" />
                    <img src="images/cross-domain-indirect.png"
                        style="width: 500px;" />
                    <figcaption>Cross-domain collaboration</figcaption>
                </figure>
            </section>
        </section>
        <section id="sec-use-case-summary">
            <h2>Summary</h2>
            <p>
                The previous section described various architecture
                patterns. In these patterns, some functional entities
                such as the devices including the legacy devices,
                controllers, gateways and cloud servers are located at
                physical locations such as inside building, outside
                buildings, and data centers. <a href="#usecase-overview"></a>
                is an overview that shows the combinations and
                communication paths of these entities.
            </p>
            <p>
                In a transport protocol layer, each entity arbitrarily
                selects a suitable role for communications.  For example,
                a device may act as a server when the device provides a service
                to indefinite number of applications.  On the other hand,
                if a device has limited or intermittent network connectivity,
                they may act as a client and actively send message to an application
                when network is available.  Regardless of this,
                in application layer, an application sees that a device provides abstract
                interfaces to interact and the application can interact with the device
                using their abstract interfaces.
            </p>
            <figure id="usecase-overview">
                <img src="images/wot-use-cases/use-case-summary.png" />
                <figcaption>Use Case Overview</figcaption>
            </figure>
        </section>
    </section>
    <section id="sec-requirements" class="normative">
        <h1>Requirements</h1>
        <p>
            <em>This section is normative.</em>
        </p>

        <section id="sec-functional-requirement">
            <h2>Functional Requirements</h2>
            <p>This section defines the properties required in an
                abstract Web of Things (WoT) architecture.</p>
            <section id="sec-requirements-principles">
                <h3>Common Principles</h3>
                <ul>
                    <li>WoT architecture should enable mutual
                        interworking of different eco-systems using web
                        technology.</li>
                    <li>WoT architecture should be based on the web
                        architecture using RESTful APIs.</li>
                    <li>WoT architecture should allow to use
                        multiple payload formats which are commonly used
                        in the web.</li>
                    <li>WoT architecture must enable different device 
                        architectures and must not force a client or server 
                        implementation of system components.</li>
                    <li>Flexibility
                        <p>There are a wide variety of physical
                            device configurations for WoT
                            implementations. The WoT abstract
                            architecture should be able to be mapped to
                            and cover all of the variations.</p>
                    </li>
                    <li>Compatibility
                        <p>There are already many existing IoT
                            solutions and ongoing IoT standardization
                            activities in many business fields. The WoT
                            should provide a bridge between these
                            existing and developing IoT solutions and
                            Web technology based on WoT concepts. The
                            WoT should be upwards compatible with
                            existing IoT solutions and current
                            standards.</p>
                    </li>
                    <li>Scalability
                        <p>WoT must be able to scale for IoT
                            solutions that incorporate thousands to
                            millions of devices. These devices may offer
                            the same capabilities even though they are
                            created by different manufacturers.</p>
                    </li>
                    <li>Interoperability
                        <p>WoT must provide interoperability across
                            device and cloud manufacturers. It must be
                            possible to take a WoT enabled device and
                            connect it with a cloud service from
                            different manufacturers out of the box.</p>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-thing-functionalities">
                <h3>Thing functionalities</h3>
                <ul>
                    <li>WoT architecture should allow things to
                        have functionalities such as
                        <ul>
                            <li>reading thing's status information</li>
                            <li>updating thing's status information
                                which might cause actuation</li>
                            <li>subscribing to, receiving and
                                unsubscribing to notifications of
                                changes of the thing's status
                                information.</li>
                            <li>invoking functions with input and
                                output parameters which would cause
                                certain actuation or calculation.</li>
                            <li>subscribing to, receiving and
                                unsubscribing to event notifications 
                                that are more general than just reports 
                                of state transitions.
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-search-and-discovery">
                <h3>Search and discovery</h3>
                <ul>
                    <li>WoT architecture should allow clients to
                        know thing's attributes, functionalities and
                        their access points, prior to access to the
                        thing itself.</li>
                    <li>WoT architecture should allow clients to
                        search things by its attributes and
                        functionalities.</li>
                    <li>WoT architecture should allow semantic
                        search of things providing required
                        functionalities based on a unified vocabulary,
                        regardless of naming of the functionalities.</li>
                </ul>
            </section>
            <section id="sec-requirements-description-mechanism">
                <h3>Description mechanism</h3>
                <ul>
                    <li>WoT architecture should support a common
                        description mechanism which enables describing
                        things and their functions.</li>
                    <li>Such descriptions should be not only
                        human-readable, but also machine-readable.</li>
                    <li>Such descriptions should allow semantic
                        annotation of its structure and described
                        contents.</li>
                    <li>Such description should be able to be
                        exchanged using multiple formats which are
                        commonly used in the web.</li>
                </ul>
            </section>
            <section id="sec-requirements-description-of-attributes">
                <h3>Description of attributes</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        thing's attributes such as
                        <ul>
                            <li>name</li>
                            <li>explanation</li>
                            <li>version of spec, format and
                                description itself</li>
                            <li>links to other related things and
                                metadata information</li>
                        </ul>
                    </li>
                    <li>Such descriptions should support
                        internationalization.</li>
                </ul>
            </section>
            <section
                id="sec-requirements-description-of-functionalities">
                <h3>Description of functionalities</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        thing's functionalities which is shown in <a
                        href="#sec-requirements-thing-functionalities"></a>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-network">
                <h3>Network</h3>
                <ul>
                    <li>WoT architecture should support multiple
                        web protocols which are commonly used.</li>
                    <li>Such protocols include
                        <ol>
                            <li>protocols commonly used in the
                                internet and</li>
                            <li>protocols commonly used in the
                                local area network</li>
                        </ol>
                    </li>
                    <li>WoT architecture should allow using
                        multiple web protocols to access to the same
                        functionality.</li>
                    <li>WoT architecture should allow using a
                        combination of multiple protocols to the
                        functionalities of the same thing (e.g. HTTP and
                        WebSocket).</li>
                </ul>
            </section>
            <section id="sec-requirements-deployment">
                <h3>Deployment</h3>
                <ul>
                    <li>WoT architecture should support a wide
                        variety of thing capabilities such as edge
                        devices with resource restrictions and virtual
                        things on the cloud, based on the same model.</li>
                    <li>WoT architecture should support multiple
                        levels of thing hierarchy with intermediate
                        entities such as gateways and proxies.</li>
                    <li>WoT architecture should support accessing
                        things in the local network from the outside of
                        the local network (the internet or another local
                        network), considering network address
                        translation.</li>
                </ul>
            </section>
            <section id="sec-requirements-application">
                <h3>Application</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        applications for a wide variety of things such
                        as edge device, gateway, cloud and UI/UX device,
                        using web standard technology based on the same
                        model.</li>
                </ul>
            </section>
            <section id="sec-requirements-legacy-adaption">
                <h3>Legacy adaption</h3>
                <ul>
                    <li>WoT architecture should allow mapping of
                        legacy IP and non-IP protocols to web protocols,
                        supporting various topologies, where
                        such legacy protocols are terminated and
                        translated.
                    </li>
                    <li>WoT architecture should allow transparent
                        use of existing IP protocols without
                        translation, which follow RESTful architecture.</li>
                        
                    <li>WoT architecture must not enforce client or server 
                        roles on devices and services. 
                        An IoT device can be either a client or a server, 
                        or both, depending on the system architecture; 
                        the same is true of edge and cloud services.
                    </li>
                </ul>
            </section>
        </section>
        <section id="sec-technical-requirements">
            <h2>Technical Requirements</h2>
            <p>
                <a href="#sec-common-usecase-patterns"></a> defines the
                Web of Things abstract architecture by showing various
                use cases and enumerating patterns for combining
                architectural components. This section describes
                technical requirements derived from the abstract
                architecture.
            </p>
            <section>
                <h3>Components consisting Web of Things and the Web
                    of Things architecture</h3>
                <p>The use cases help to identify basic components
                    such as devices and applications, that access and
                    control those devices, proxies (i.e. gateways and
                    edge devices) that are located between devices.
                    An additional component useful in some use cases 
                    is the directory, which assists with discovery.</p>
                <p>Those components are connected to the internet or
                    field networks in offices, factories or other
                    facilities. Note that all components involved may be
                    connected to a single network in some cases,
                    however, in general components can be deployed
                    across multiple networks.</p>
            </section>
            <section>
                <h3>Devices</h3>
                <p>
                    Access to devices is made using a descriptions of
                    their functions and interfaces. This description is
                    called <em>Thing Description (TD)</em>. A <em>Thing
                        Description</em> includes a general metadata about
                    the device, information models representing
                    functions, transport protocol description for
                    operating on information models, and security
                    information.
                </p>
                <p>General metadata contains device identifiers
                    (URI), device information such as serial number,
                    production date, location and other human readable
                    information.</p>
                <p>Information models defines device attributes, and
                    represent devices internal settings, control
                    functionality and notification functionality.
                    Devices that have the same functionality have the
                    same information model regardless of the transport
                    protocols used.</p>
                <p>Because many systems based on Web of Things
                    architecture are crossing system Domains,
                    vocabularies and meta data (e.g. ontologies) used in
                    information models should be commonly understood by
                    involved parties. In addition to REST transports,
                    PubSub transports are also supported.</p>
                <p>Security information includes descriptions about
                    authentication, authorization and secure
                    communications. Devices are required to put TDs
                    either inside them or at locations external to the
                    devices, and to make TDs accessible so that other
                    components can find and access them.</p>
            </section>
            <section>
                <h3>Applications</h3>
                <p>Applications need to be able to generate and use network 
                    and program interfaces based on metadata (descriptions).</p>
                <p>Applications have to be able to obtain these 
                    descriptions through the network,
                    therefore, need to be able to conduct search
                    operations and acquire the necessary descriptions over the
                    network.</p>
            </section>
            <section>
                <h3>Digital Twins</h3>
                <p>Digital Twins need to generate program interfaces
                    internally based on metadata (descriptions),
                    and to represent virtual devices by using those
                    program interfaces. A twin has to produce a description for
                    the virtual device and make it externally available.</p>
                <p>Identifiers of virtual devices need to be newly
                    assigned, therefore, are different from the original
                    devices. This makes sure that virtual devices and
                    the original devices are clearly recognized as
                    separate entities. Transport and security mechanisms
                    and settings of the virtual devices can be different
                    from original devices if necessary. Virtual devices
                    are required to have descriptions provided either directly by
                    the twin or to have them available at external
                    locations. In either case it is required to make the
                    descriptions available so that other components can find and
                    use the devices associated with them.</p>
            </section>
            <section>
                <h3>Discovery</h3>
                <p>For TDs of devices and virtual devices to be
                    accessible from devices, applications and twins,
                    there needs to be a common way to share TDs.
                    Directories can serve this requirement by providing
                    functionalities to allow devices and twins
                    themselves automatically or the users to manually
                    register the descriptions.</p>
                <p>Descriptions of the devices and virtual devices
                    need to be searchable by external entities.
                    Directories have to be able to process search
                    operations with search keys such as keywords from
                    the general description in the device description or
                    information models.</p>
            </section>
            <section>
                <h3>Security</h3>
                <p>Security information related to devices and
                    virtual devices needs to be described in device
                    descriptions. This includes information for
                    authentication/authorization and payload
                    encryption.</p>
                <p>WoT architecture should support multiple security
                    mechanism commonly used in the web, such as Basic,
                    Digest, Bearer and OAuth2.0.</p>
            </section>
            <section>
                <h3>Accessibility</h3>
                <p>The Web of Things primarily targets
                    machine-to-machine communication. The humans
                    involved are usually developers that integrate
                    Things into applications. End-users will be faced
                    with the front-ends of the applications or the
                    physical user interfaces provided by devices
                    themselves. Both are out of scope of the W3C WoT
                    specifications. Given the focus on IoT instead of
                    users, accessibility is not a direct requirement,
                    and hence is not addressed within this document.</p>
                <p>There is, however, an interesting aspect on
                    accessibility: Fulfilling the requirements above
                    enables machines to understand the network-facing
                    API of devices. This can be utilized by
                    accessibility tools to provide user interfaces of
                    different modality, thereby removing barriers to
                    using physical devices and IoT-related applications.</p>
            </section>
        </section>
    </section>

    <section id="sec-wot-architecture">
        <h1>WoT Architecture</h1>
        <p>
            <em>This section is normative.</em>
        </p>

        <section id="sec-architecture-overview">
            <h2>Overview</h2>
            <p>
                To address the use cases in Section 4 and fulfill the requirements in Section 5,
                the Web of Things builds on top of the concept of Web Things -- usually simply called <a>Things</a> -- that can be used by so-called <a>Consumers</a>.
                A Thing is the abstraction of a physical or virtual entity (e.g., a device or a room, resp.)
                and is described by standardized metadata.
                In W3C WoT, the description metadata MUST be a WoT Thing Description [[!wot-thing-description]].
                A Thing Description (TD) is instance-specific (i.e., describes an individual Thing, not types of Things)
                and is the default Web representation of a Thing.
                There MAY be other Web representations of a Thing such as an HTML-based user interface or simply an image of the physical entity.
                However, the WoT Thing Description is a standardized, machine-understandable representation format
                that allows <a>Consumers</a> to discover and interpret the capabilities of a Thing (through semantic annotations)
                and to adapt to different implementations (e.g., different protocols or data structures) when interacting with a Thing,
                thereby enabling interoperability across different <a>IoT platforms</a>, i.e., different ecosystems and standards.
            </p>
            <p class="ednote" title="TODO">
                Simple figure to illustrate Consumer--Thing interaction.
            </p>
            <p>
                A Thing can also abstract a virtual entity, which is the composition of one or more Things (e.g., a room consisting of several sensors and actuators).
                One option for the composition is to provide a single, consolidated <a>Thing Description</a> that contains the superset of capabilities for the virtual entity.
                In cases where the composition is rather complex, its <a>Thing Description</a> may <emph>link</emph> to hierarchical sub-Things within the composition.
                The main <a>Thing Description</a> acts as entry point and only contain general metadata and potentially overarching capabilities.
                This allows grouping of certain aspects of more complex Things.
            </p>
            <p>
                Linking does not only apply to hierarchical Things, but relations between Things and other resources in general.
                Link relation types express how Things relate, for instance, a switch controlling a light or a room monitored by a motion sensor.
                Other resources related to a Thing can be manuals, catalogs for spare parts, CAD files, a graphical UI, or any other document on the Web.
                Overall, Web linking among Things makes the Web of Things browsable.
                This can be further facilitated by providing Thing directories that manage an index of available Things, usually by caching their TD representation.
                In summary, <a>Thing Descriptions</a> MAY link to other <a>Things</a> and other resources on the Web to form a Web of Things.
                Links in <a>Thing Descriptions</a> MUST have a relation type.
            </p>
            <p class="ednote" title="TODO">
                Figure to illustrate linked Things.
            </p>
            <p>
                Things must be hosted on networked system components with a software stack to realize interaction through a network-facing interface, the <a>WoT Interface</a> of a <a>Thing</a>.
                One example of this is an HTTP server running on an embedded device with sensors and actutors interfacing the physical entity behind the Thing abstraction.
                However, W3C WoT does not mandate where <a>Things</a> are hosted; it can be on the IoT device directly, an <a>Edge device</a> such as a gateway box, or the cloud.
            </p>
            <p>
                A typical deployment challenge is that local networks are not reachable from the Internet, usually because of IPv4 NATs or firewalls.
                To remedy this situation, W3C WoT allows for <a>Intermediaries</a> between <a>Things</a> and <a>Consumers</a>.
                <a>Intermediaries</a> can act as proxies for <a>Things</a>, where the <a>Intermediary</a> has a <a>Thing Description</a> similar to the original <a>Thing</a>,
                but which points to the <a>WoT Interface</a> provided by the <a>Intermediary</a>.
                <a>Intermediaries</a> may also augment existing <a>Things</a> with additional capabilities or compose a new <a>Thing</a> out of multiple available <a>Things</a>,
                thereby forming a virtual entity.
                To <a>Consumers</a>, <a>Intermediaries</a> look like <a>Things</a>, as they possess <a>Thing Descriptions</a> and provide a <a>WoT Interface</a>,
                and hence might be indistinguishable from <a>Things</a> in a layered system architecture like the Web [[?REST]].
                An identifier in the <a>Thing Description</a> MUST allow for the correlation of multiple <a>Thing Descriptions</a> representing the same original <a>Thing</a> or ultimately unique physical entity.
            </p>
            <p class="ednote" title="TODO">
                Figure to illustrate intermediaries.
            </p>
            <p>
                Another remedy for unreachable local networks would be to bind the <a>WoT Interface</a> to a protocol that establishes the connection from the <a>Thing</a> within the local network to a publicly reachable <a>Consumer</a>.
            </p>
            <p>
                Things MAY be bundled together with a Consumer to enable Thing-to-Thing interaction.
                Usually, the Consumer behavior is embedded in the software also implementing the behavior of the Thing.
                The configuration of the Consumer behavior MAY be exposed through the Thing.
            </p>
            <p>
                <a href="#architecture-abstract"></a> summarizes how the WoT concepts introduced above can be applied and combined to address the use cases summarized in <a href="#sec-use-case-summary"></a>.
                In particular, W3C WoT is applicable to all levels relevant for IoT applications: the device level, edge level, and cloud level.
            </p>
            <figure id="architecture-abstract">
                <img src="images/architecture-abstract-new.png"
                    style="width: 100%;" />
                <figcaption>Abstract Architecture of W3C WoT</figcaption>
            </figure>
        </section>
        <section>
            <h2>Affordances</h2>
            <p>
                A central aspect in the concept of Web Things is the provision of machine-understandable metadata.
                Ideally, such metadata is self-descriptive, so that <a>Consumers</a> are able to identify
                <emph>what</emph> capabilities a Thing provides and <emph>how</emph> they can make use the provided capabilities.
                A key to this self-descriptiveness lies in the concept of affordances.
            </p>
            <p>The term affordance originates in ecological
                psychology, but was adopted in the field of
                Human-Computer Interaction [[?HCI]] based on the
                definition by Donald Norman: "'Affordance' refers to
                the perceived and actual properties of the thing,
                primarily those fundamental properties that
                determine just how the thing could possibly be
                used." [[?NORMAN]]</p>
            <p>
                An example for this is a door having a handle.
                The door handle is an affordance, which suggests that the door can be opened.
                For humans, a door handle usually also suggests how the door is opened;
                an American knob suggests twisting, a European lever handle suggests pressing down.
            </p>
            <p>
                The hypermedia principle, which is one of the
                bedrock foundations of the REST architectural style [[?REST]],
                demands that any piece of information available on
                the Web be linked to other pieces of information so
                that the consumer of the information gets explicit
                knowledge about how to navigate the Web and control
                Web applications.
                Here, the simultaneous presentation of
                information and control (provided in
                the form of hyperlinks) is a mechanism that affords
                Web clients the means to drive Web applications. In this
                context, an affordance is the description of a
                hyperlink (e.g. via a link relation type and link
                target attributes) suggesting Web clients how to navigate
                and possibly how act on the linked resource.
            </p>
            <p>
                Drawn from this hypermedia principle,
                the Web of Things defines <a>Interaction Affordances</a> as metadata of a Thing
                that shows and describes the possible choices to <a>Consumers</a>, thereby suggesting how <a>Consumers</a> may interact with the Thing.
                A general <a>Interaction Affordances</a> is navigation, which is activated by following links, thereby browsing the Web of Things.
                <a href="#sec-interaction-model"></a> defines three more types of Interaction Affordances for W3C WoT: <a>Properties</a>, <a>Actions</a>, and <a>Events</a>.
            </p>
            <p>
                This definition is thereby aligned with HCI and interaction designers, who create physical Things,
                as well as the REST and microservice community, who is working on Web services in general.
            </p>
        </section>
        <section id="sec-web-thing">
            <h2>Web Thing</h2>
            <p>
                A Web Thing has four architectural
                aspects of interest: its behavior, its <a>Interaction Affordances</a>, and its security
                configuration. See <a href="#arch-aspects"></a>. The
                behavior aspect of a Thing includes both lifecycle
                management (onboarding, updating, decommissioning, etc.)
                but also the operational behavior of the Thing, which
                can include both autonomous behavior and support for
                interactions. Interactions have two parts, the
                interaction affordances which are presented externally,
                and the interaction implementation, which defines the
                actual behavior corresponding to the interaction. The
                interaction affordances provide a model of the network
                API using a set of abstract operations, but without
                reference to a specific network protocol or payload
                encoding. The protocol binding adds the additional
                detail needed to map each interaction affordance to
                operations in a particular concrete protocol. In
                general, different concrete protocols may be used to
                support different subsets of interaction affordances
                even within a single Thing. The security configuration
                aspect of a Thing represents the mechanisms used to
                control access to the affordances and the management of
                related public and private metadata. <a
                    href="#arch-aspects"></a> shows these aspects in a
                diagram.
            </p>
            <figure id="arch-aspects">
                <img src="images/wot-abstract-arch.png" />
                <figcaption>Architectural Aspects of a Thing</figcaption>
            </figure>
        </section>
        <section id="sec-interaction-model">
            <h2>Interaction Model</h2>
            <p>Originally, a Web resource usually represented a
                document on the World Wide Web that can simply be
                fetched by a Web client. With the introduction of Web
                services, resources became more generic interaction
                endpoints that can implement any kind of behavior. This
                very high level of abstraction makes it hard to provide
                a loose coupling between applications and the manifold
                interaction possibilities of resources. As a result,
                typical API descriptions consist of a static mapping
                from an application intent to a resource address,
                method, request payload structure, response payload
                structure, and expected errors.</p>
            <p>The interaction model of WoT introduces an
                intermediate abstraction that formalizes the mapping
                from application intent to concrete protocol bindings,
                which are used to interact with Web resources. Instead
                of generic resources, WoT applications use three types
                of so-called Interaction Affordances: Properties,
                Actions, and Events. While constraining Web resources
                into three different behaviors, the three types are
                still able to cover virtually all functionality found in
                IoT devices and services.</p>
            <section>
                <h3>Properties</h3>
                <p>A Property is an Interaction Affordance that
                    exposes internal state of the Thing that can be
                    directly accessed (read) and optionally manipulated
                    (write). Things can also choose to make Properties
                    observable by pushing the new state after a change
                    (cf. CoAP Observe [[?RFC7641]]).</p>
                <p>Properties may contain one data schema if the
                    data is not fully specified by the Protocol Binding
                    used (e.g., through a Media Type).</p>
                <p>Examples of Properties are sensor values
                    (read-only), stateful actuators (read-write),
                    configuration parameters (read-write), Thing status
                    (read-only), or computation results (read-only).</p>
            </section>
            <section>
                <h3>Actions</h3>
                <p>An Action is an Interaction Affordance that
                    allows to invoke a function of the Thing, which
                    manipulates internal state that is not directly
                    exposed (cf. Properties) based on internal logic or
                    triggers a process on the Thing.</p>
                <p>Actions may contain up to two data schemas, one
                    for optional input parameters, one for output
                    results, if the data is not fully specified by the
                    Protocol Binding used (e.g., through a Media Type).</p>
                <p>Examples of Actions are changing multiple
                    Properties simultaneously, changing Properties over
                    time or with a process that shall not be disclosed,
                    or invoking a long-lasting process such as actuator
                    control.</p>
            </section>
            <section>
                <h3>Events</h3>
                <p>An Event Interaction Affordance describes
                    asynchronous push interactions initiated by the
                    Thing. Here not state, but state transitions (i.e.,
                    events) are communicated. Events may be triggered
                    through conditions that are not exposed as
                    Properties.</p>
                <p>Events may contain up to three data schemas, one
                    for the event data and optionally one for the
                    subscription data and/or one for the cancellation
                    data, if the data is not fully specified by the
                    Protocol Binding used (e.g., through a Media Type).</p>
                <p>Examples of Events are discrete events such as an
                    alarm or samples of a time series that are pushed
                    regularly.</p>
            </section>
        </section>
        <section id="sec-hypermedia-controls">
            <h2>Hypermedia Controls</h2>
            <p>Interaction Affordances showing the possible choices
                to clients must originate from the Thing itself and are
                shared during discovery or in-band during the
                interaction with the Thing. This is opposed to
                out-of-band interface descriptions that need to be
                preinstalled or hardcoded into clients (e.g., RPC, WS-*
                Web services, HTTP services with fixed
                URI-method-response definitions).</p>
            <p>To suggest how clients may interact with the Thing,
                WoT makes use of hypermedia controls known from REST.
                Besides the well-established Web links [[!RFC8288]], WoT
                defines the concept of Web forms. They allow to adapt to
                the diverse choices with which clients are faced in the
                Internet of Things [[?FORMS]].</p>
            <section id="sec-hypermedia-links">
                <h3>Links</h3>
                <p>
                    Web links enable clients to change the current
                    context (e.g., the set of resource representations
                    currently rendered in the Web browser) or to include
                    further resources in the current context, depending
                    on the relation between context and link target.
                    Clients do so by <i>dereferencing</i> the target
                    URI, that is, fetching the resource representation.
                </p>
                <p>
                    A link is comprised of a link context, relation
                    type, target, and optionally target attributes The
                    underlying model for the relationships between
                    resources on the Web (i.e., links) is defined in
                    [[!RFC8288]]. link relation types are either
                    IANA-registered tokens adhering to the ABNF
                    <code style="white-space: nowrap;">LOALPHA *(
                        LOALPHA / DIGIT / "." / "-" )</code>
                    (e.g.,
                    <code>stylesheet</code>
                    ) or extension types in form of absolute URIs.
                    [[!RFC8288]]
                </p>
                <p>In the Web of Things, links are used for
                    discovery and to express relations between Things
                    (e.g., hierarchical or functional) and relations to
                    other documents on the Web (e.g., manuals or
                    alternative representations such as CAD models).</p>
            </section>
            <section id="sec-hypermedia-forms">
                <h3>Forms</h3>
                <p>Forms enable clients to perform interactions that
                    go beyond dereferencing a URI such as manipulating
                    resource state at the server. This usually requires
                    more detailed information about the necessary
                    request such as the method and header fields or
                    protocol options. Forms can be seen as a request
                    template, where the server prefilled part of the
                    information according to its own interface and left
                    parts blank to be filled by the client.</p>
                <p>In the Web of Things, a form provides
                    instructions to perform an operation on a resource
                    and is comprised of:</p>
                <ul>
                    <li>a form context,</li>
                    <li>a submission target,</li>
                    <li>an operation type,</li>
                    <li>a request method, and</li>
                    <li>optionally form fields</li>
                </ul>
                <p>
                    A form can be viewed as a statement of "To perform a
                    <code>operation type</code>
                    operation on
                    <code>form context</code>
                    , make a
                    <code>request method</code>
                    request to
                    <code>submission target</code>
                    " where form fields may further describe the
                    required request.
                </p>
                <p>Form contexts and submission targets are both
                    Internationalized Resource Identifiers (IRIs)
                    [[!RFC3987]]. However, in the common case, they will
                    also be URIs [[!RFC3986]], because many protocols
                    (such as HTTP) do not support IRIs.</p>
                <p>Form context and submission target may point to
                    the same resource or different resources, where the
                    submission target resource implements the operation
                    for the context resource.</p>
                <p>The operation type identifies the semantics of
                    the operation. Operation types are denoted similar
                    to link relation types:</p>
                <ul>
                    <li><span class="rfc2119-assertion"
                        id="arch-op-wellknown">Well-known
                            operation types MUST have a name that
                            follows the ABNF <code
                                style="white-space: nowrap;">LOALPHA
                                *( LOALPHA / DIGIT / "." / "-" )</code>.
                    </span> <span class="rfc2119-assertion"
                        id="arch-op-wellknown-compare">Names MUST
                            be compared character by character in a
                            case-insensitive fashion.</span> The well-known
                        operation types for the Web of Things defined by
                        this specification are given in the following
                        table.</li>
                    <li><span class="rfc2119-assertion"
                        id="arch-op-extension">Extension
                            operation types MAY be chosen by
                            applications.</span> <span
                        class="rfc2119-assertion"
                        id="arch-op-extension-iri">Extension
                            operation type names MUST be absolute URIs
                            [[!RFC3986]] that uniquely identify the
                            type.</span></li>
                </ul>
                <figure id="table-operation-types">
                <table class="def">
                    <thead>
                        <tr>
                            <th>Operation Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>readproperty</td>
                            <td>Identifies the read operation on
                                Property Affordances to retrieve the
                                corresponding data.</td>
                        </tr>
                        <tr>
                            <td>writeproperty</td>
                            <td>Identifies the write operation on
                                Property Affordances to update the
                                corresponding data.</td>
                        </tr>
                        <tr>
                            <td>observeproperty</td>
                            <td>Identifies the observe operation on
                                Property Affordances to be notified with
                                the new data when the Property was
                                updated.</td>
                        </tr>
                        <tr>
                            <td>unobserveproperty</td>
                            <td>Identifies the unobserve
                                operation on Property Affordances to stop
                                the corresponding notifications.</td>
                        </tr>
                        <tr>
                            <td>invokeaction</td>
                            <td>Identifies the invoke operation on
                                Action Affordances to perform the
                                corresponding action.</td>
                        </tr>
                        <tr>
                            <td>subscribeevent</td>
                            <td>Identifies the subscribe operation
                                on Event Affordances to be notified by
                                the Thing when the event occurs.</td>
                        </tr>
                        <tr>
                            <td>unsubscribeevent</td>
                            <td>Identifies the unsubscribe
                                operation on Event Affordances to stop
                                the corresponding notifications.</td>
                        </tr>
                    </tbody>
                </table>
                    <figcaption>Well-known Operation Types for
                        the Web of Things</figcaption>
                </figure>
                <p class="ednote">As of this specification, the
                    well-known operation types form a fixed set that
                    results from the WoT interaction model. Other
                    specifications may define further well-known
                    operation types that are valid for their respective
                    document format or form serialization. Updates to
                    this specification may set up an IANA registry in
                    the future to enable extension and a more
                    generic Web form model that may be applied beyond
                    WoT specifications.</p>
                <p>The request method MUST identify one method of
                    the standard set of the protocol identified by the
                    submission target URI scheme.</p>
                <p>Form fields may further specify the request
                    expected by the server for the given operation. Form
                    fields may depend on the protocol used for the
                    submission target. Examples are HTTP header fields,
                    CoAP options, the protocol-independent Media Type(s)
                    for the submission payload, or information about the
                    expected response.</p>
            </section>
        </section>
        <section id="sec-protocol-bindings">
            <h2>Protocol Bindings</h2>
            <p>
                A Protocol Binding is the mapping from an Interaction Affordance to concrete messages of a specific protocol such as HTTP [[!RFC7231]], CoAP [[!RFC7252]], or MQTT [[!MQTT]].
                The Protocol Bindings follow the Uniform Interface constraint of REST [[?REST]] to support interoperability
                and are serialized as hypermedia controls to be self-descriptive.
            </p>
            <section>
                <h3>Hypermedia-driven</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-hypermedia">Interaction
                        Affordances MUST use hypermedia controls (see <a
                        href="#sec-hypermedia-controls"></a>) to
                        describe their usage.
                    </span> <span class="rfc2119-assertion"
                        id="arch-hypermedia-origin">The
                        hypermedia controls MUST originate from the
                        Thing providing the corresponding Interaction
                        Affordance.</span> This enables a loose coupling
                    between Things and clients, allowing for an
                    independent lifecycle and evolution. <span
                        class="rfc2119-assertion"
                        id="arch-hypermedia-caching">The
                        hypermedia controls MAY be cached outside the
                        Thing and used for offline processing if
                        corresponding caching metadata is available to
                        determine the freshness.</span>
                </p>
            </section>
            <section id="sec-arch-URIs">
                <h3>URIs</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-uri-scheme">Eligible
                        protocols for the Web of Things MUST have an
                        associated URI scheme that is registered with IANA
                        [[!RFC4395]].</span> Hypermedia controls rely on URIs to
                    identify target resources and submission targets.
                    Thereby, the URI scheme (the first component up to ":")
                    identifies the communication protocol to be used for
                    interaction with the Thing. The Web of Things refers to
                    these protocols as <a>transfer protocols</a>.
                </p>
            </section>
            <section id="sec-standard-method">
                <h3>Standard Set of Methods</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-methods">Eligible
                        protocols for the Web of Things MUST be based on a
                        standard set of methods that can be shared a priori.</span>
                    The standard set of methods makes messages
                    self-descriptive to enable intermediate processing of
                    interactions, for instance by proxies or to translate
                    between Protocol Bindings [[?REST]]. Furthermore, it
                    allows clients to have application-agnostic protocol
                    stack, avoiding Thing-specific code or plugins.
                </p>
            </section>
            <section id="media-types">
                <h3>Media Types</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-media-type">All
                        data (a.k.a. content) exchanged within Interaction
                        Affordances MUST be identified by a Media Type
                        [[!RFC6838]].</span> Media Types are IANA-managed labels to
                    identify representation formats, for instance
                    <code>application/json</code>
                    for JSON [[!RFC7159]] or
                    <code>application/cbor</code>
                    for CBOR [[!RFC7049]].
                </p>
                <p>
                    Note that many Media Types only identify a generic
                    serialization format that does not provide further
                    semantics for its elements (e.g., XML, JSON, CBOR). <span
                        class="rfc2119-assertion" id="arch-schema">Thus,
                        the corresponding Interaction Affordances SHOULD
                        declare a data schema to provide more detailed
                        semantic metadata for the data exchanged.</span>
                </p>
            </section>
        </section>
        <section id="sec-WoT-servient-architecture-high-level">
            <h2>System Configurations</h2>

            <p>This section illustrates the behavior of WoT
                components using system configuration diagrams.</p>

            <section>
                <h3>Direct Communication</h3>
                <p>
                    <a href="#high-level-application-device"></a> shows
                    direct communication between a <a>WoT Server</a>, that is
                    exposing a thing and a <a>WoT Client</a> that is using it.
                    Direct communication applies when both components
                    use the same network protocol(s) and are accessible
                    to each other.
                </p>
                <figure id="high-level-application-device">
                    <img
                        src="images/arch-high-level-application-device-alt2.png" />
                    <figcaption>High level architecture of
                        application and device</figcaption>
                </figure>

                Conceptually, a <a>WoT Server</a> can be thought to have an <a>Exposed Thing</a>
                that provides an interface that conforms to the TD. A
                <a>WoT Client</a> can be considered to contain a <a>Consumed Thing</a>
                for each of the <a>WoT Servers</a> it connects to
                that provides a programming interface that can be used
                by applications. A <a>WoT Client</a> can generate a
                <a>Consumed Thing</a> instance by interpreting a TD.
                Communication between the <a>WoT Client</a> and the <a>WoT Server</a>
                is performed by exchanging messages over a direct
                network connection between a <a>Consumed Thing</a> and an
                <a>Exposed Thing</a>.

            </section>
            <section>
                <h3>Indirect Communication</h3>

                <p>
                    In <a
                        href="#high-level-application-proxy-device-new"></a>
                    a <a>WoT Client</a> and a <a>WoT Server</a> connect to each other
                    via a proxy. A proxy is required as an intermediary
                    if the components use different protocols (gateway)
                    or if they are on different networks that require
                    authentication and provide access control (e.g.
                    firewalls).
                </p>

                <figure id="high-level-application-proxy-device-new">
                    <img
                        src="images/arch-high-level-application-proxy-device-alt2.png" />
                    <figcaption>High level architecture
                        with proxy</figcaption>
                </figure>

                <p>
                    A proxy combines <a>Exposed Thing</a> and <a>Consumed Thing</a>
                    functionality, and relays messages that are exchanged
                    between a <a>WoT Client</a> and a <a>WoT Server</a>. In a proxy,
                    a <a>Consumed Thing</a> creates a <em>shadow thing
                        instance</em> of the <a>Exposed Thing</a> of a <a>WoT Server</a>, and
                    a <a>WoT Client</a> can access the shadow instance through
                    the <a>Exposed Thing</a> of the proxy.
                </p>
                <p>The <a>Exposed Thing</a> and <a>Consumed Thing</a> of a proxy can
                    communicate with the <a>WoT Client</a> and the <a>WoT Server</a>
                    in different protocols. For example, a proxy can
                    provide a bridge between a device that uses CoAP and
                    an application that uses HTTP. Even when there are
                    multiple devices and they use different protocols,
                    an application can communicate with those devices
                    using a single protocol through the proxy. The same
                    is true for device authentication. A client only
                    needs to handle a single authentication method even
                    when multiple devices connected to a proxy use
                    different authentication methods.</p>
                <p>A proxy creates a <a>Consumed Thing</a> based on a TD and
                    generates another TD for a shadow thing instance.
                    The TD for a shadow device uses a new identifier
                    different from the original device TDs, and
                    contains interfaces for other communication
                    protocols if necessary. A proxy then creates an
                    <a>Exposed Thing</a> that implements the bridge to the
                    originating thing. A client communicates with a
                    device via a proxy through a <a>Consumed Thing</a> that
                    conforms to the TD for the shadow thing instance.</p>
            </section>
        </section>
    </section>

    <section id="sec-building-blocks">
        <h1>WoT Building Blocks</h1>
        <p>
            <em>This section is normative.</em>
        </p>
        <p> The Web of Things (WoT) Building Blocks allow the
            implementation of systems that conform with the abstract WoT
            Architecture. The specifics of these building blocks are
            defined in separate documents; this chapter provides an
            overview and a summary.
        </p>
        <p> The WoT Building Blocks support each of the architectural
            aspects of a Thing discussed in <a href="#sec-arch-aspects"></a>
            and diagrammed in <a href="#arch-aspects"></a>. The building
            blocks themselves are shown in the context of an abstract Thing in 
            <a href="#arch-building-blocks"></a>. This is an abstract
            view and is not meant to represent any particular
            implementation; instead it is meant to illustrate the  
            relationship between the building blocks and the main
            architectural aspects of a Thing. 
            In this figure the WoT Building Blocks
            are highlighted with black outlines.
            Security, a cross-cutting concern, 
            is separated into public and protected private components. 
            The WoT Scripting API is optional and the
            Binding Templates are informative.
        </p>
        <figure id="arch-building-blocks">
            <img src="images/wot-building-blocks-abstract.png" />
            <figcaption>Relationship of WoT Building Blocks 
            to the Architectural Aspects of a Thing.</figcaption>
        </figure>
        <p> The <a>WoT Thing Description</a> (TD) contains metadata describing the
            interaction affordances of the Thing, the mapping of these
            affordances onto concrete network protocols (the
            communication metadata), the <em>public</em> security data
            needed by authorized users to understand how to access the
            Thing, and other general metadata such as IDs, names, and
            descriptions. The <a>Binding Templates</a> are another WoT building
            block that provides guidance on how to provide the correct
            communications metadata in a TD to support
            specific target protocols.
        </p>
        <p> The interaction implementation specifies how a Thing
            actually responds to an interaction, including how state is
            stored and modified. The behavior implementation specifies
            how other behavior of a Thing is implemented, which may or
            may not be directly related to an interaction. For example,
            a thermostat may need to execute a control loop to control a
            furnace based on a sensor reading. This does not directly
            relate to a specific interaction, although it might be
            controlled by a property (such as target temperature) that
            can be modified by an interaction.
        </p>
        <p> For specifying behavior and interaction implementations, an
            optional WoT Scripting API building block is provided which
            supports the definition and consumption of WoT Thing
            Descriptions. This is useful to define application behavior
            using an easy-to-use scripting language. It is however
            possible to implement a WoT Thing <em>without</em> using the
            WoT Scripting API. In this case the externally visible
            interactions and network interface still needs to be
            consistent with the Thing Description defined for the Thing.
        </p>
        <p> Internally to a Thing, it is also generally important to
            provide secure storage for <em>private</em> security data
            such as encryption keys and identity material. This information is
            never directly shared with entities outside the Thing, and ideally
            should not even be available to the behavior and interaction
            implementations. Instead an abstract set of operations
            should support security functions such as signing,
            authorization, certificate validation, as well as encryption and
            decryption. Technology such as asymmetric public encryption
            schemes are generally used to provide these functions
            without disclosing the secret private security data. In
            general, explicitly managing secrets in a form that is
            easily updated if necessary and keeping them clearly
            separated from public information is considered a security
            best practice.  In particular storing secrets as random
            numeric values rather than attempting to obfuscate the
            implementation or network interface is strongly recommended.
            If a numeric value is disclosed it is easily changed.
            This is not true of an implementation or network interface.
        </p>
        <p> In the following sections we will provide additional
            information on each WoT Building Block: the WoT Thing
            Description, the WoT Binding Templates, and the WoT
            Scripting API.
            Security, although it is a cross-cutting concern, can
            be considered a fourth building block.
        </p>

        <section id="sec-thing-description">
            <h2>WoT Thing Description</h2>
            <p> The WoT Thing Description (TD) document
                [[!wot-thing-description]] defines an information model
                based on a semantic vocabulary and a serialized
                representation based on JSON. TDs provide rich metadata
                for Things in a way that is both human-readable and
                machine-understandable. Both the information model and
                the representation format of TDs are aligned with Linked
                Data [[?LINKED-DATA]], so that besides raw JSON
                processing, implementations may choose to make use of
                JSON-LD [[?JSON-LD11]] and graph databases to enable
                powerful semantic processing of the metadata.
            </p> 
            <p> A <a>Thing Description</a> (TD) describes Thing
                instances with general metadata such as name, ID,
                descriptions, and also can provide relation metadata
                through links to related Things or other documents. TDs
                also provide interaction affordance metadata based on
                the interaction model defined in <a
                    href="#sec-interaction-model"></a>; public security
                configuration metadata; and communications metadata
                defining protocol bindings. The TD can be seen as the <i>index.html
                    for Things</i>, as it provides the entry point to learn
                about the provided services and related resources, both
                of which are described using hypermedia controls.
            </p>
            <p> Ideally, the TD is created and/or hosted by the Thing
                itself and retrieved upon discovery. Yet it can also be
                hosted externally when a Thing has resource restrictions
                (e.g., limited memory space, limited power) or when an existing device
                is retrofitted to become part of the Web of Things. A
                common pattern is to register TDs with a directory to improve
                discovery (e.g., for constrained devices) and to
                facilitate device management. It is recommended that
                clients should use TD caching combined with
                notifications when they are paired with a Thing, meaning
                that they will be notified to fetch a fresh TD
                representation in case the Thing is updated.
            </p>
            <p> For semantic interoperability, <a>TDs</a> may make use
                of a domain-specific vocabulary, for which explicit
                extension points are provided. However, development of
                any particular domain-specific vocabulary is currently
                out-of-scope of the W3C WoT standardization activity.
            </p>
            <p> Three examples of potentially useful external IoT
                vocabularies are SAREF [[?SAREF]], iot.schema.org
                [[?iot-schema-org]], and the W3C Semantic Sensor Network
                ontology [[?SSN]]. Use of such external vocabularies in TDs is
                optional. In the future additional domain-specific
                vocabularies may be developed and used with TDs.
            </p>
            <p> Overall, the WoT Thing Description building block
                fosters interoperability in two ways: First, <a>TDs</a>
                enable machine-to-machine communication in the Web of
                Things. Second, <a>TDs</a> can serve as a common,
                uniform format for developers to document and retrieve
                all the details necessary to create applications that
                can access IoT devices and make use of their data.
            </p>
        </section>
        <section id="sec-binding-templates" class="informative">
            <h3>WoT Binding Templates</h3>
            <p> The IoT uses a variety of protocols for accessing
                devices, since no one protocol is appropriate in all
                contexts. Thus, a central challenge for the Web of
                Things is to enable interactions with the plethora of
                different <a>IoT platforms</a> (e.g., OCF, oneM2M, OMA
                LWM2M, OPC UA) and devices that do not follow any
                particular standard, but provide an eligible interface
                over a suitable network protocol. WoT is tackling this
                variety through Protocol Bindings, which must meet a
                number of constraints (see <a href="#protocol-bindings"></a>).
            </p>
            <p> The non-normative WoT Binding Templates document
                [[?wot-binding-templates]] provides a collection of
                communication metadata blueprints that provide guidance on 
                how to interact with different <a>IoT platforms</a>. 
                When describing a particular IoT device or service, 
                the <a>Binding Template</a> for the corresponding <a>IoT Platform</a>
                can be used to look up the communication metadata that
                must be provided in the <a>Thing Description</a> to
                support that platform.
            </p>
            <figure id="fig-binding-templates">
                <img src="images/binding-templates.png"
                    style="width: 800px;" />
                <figcaption>From Binding Templates to Protocol Bindings</figcaption>
            </figure>
            <p> <a href="#fig-binding-templates"></a> shows how <a>Binding
                Templates</a> are applied. A <a>WoT Binding Template</a>
                is created only once for each <a>IoT Platform</a> and
                can then be reused in all <a>TDs</a> for devices of that
                platform. Clients consuming a <a>TD</a> must implement
                the corresponding <a>Protocol Binding</a> by including a
                corresponding protocol stack and by configuring the
                stack (or its messages) according to the information
                given in the <a>TD</a>. The communication metadata of
                Protocol Bindings spans five dimensions:
            </p>
            <ul>
                <li><b>IoT Platform:</b> <a>IoT Platforms</a> often
                    introduce proprietary modifications at the
                    application layer such as platform-specific HTTP
                    header fields or CoAP options. Forms (see <a
                    href="sec-hypermedia-forms"></a>) may contain the
                    necessary information to apply these tweaks in
                    additional form fields defined for the
                    application-layer protocol used.</li>
                <li><b>Media Type:</b> <a>IoT Platforms</a> often
                    differ in the representation formats (or
                    serializations) used for exchanging data. The Media
                    Type [[!RFC6838]] identifies these formats, while
                    parameters may specify them further. Forms may
                    contain the Media Type and optional parameters in
                    additional form fields.</li>
                <li><b>Transfer Protocol:</b> The Web of Things
                    uses the term <a>transfer protocol</a> for the
                    underlying, standardized application layer protocol
                    without application-specific options or subprotocol
                    mechanisms. The URI scheme of the form submission
                    target contains the necessary information to
                    identify the transfer protocol, e.g., HTTP, CoAP, or
                    WebSockets.</li>
                <li><b>Subprotocol:</b> Transfer protocols may have
                    extension mechanisms that must be known to interact
                    successfully. Such <a>subprotocols</a> cannot be
                    identified from the URI scheme and must be declared
                    explicitly. Examples are the push notification
                    workarounds for HTTP such as long polling
                    [[?RFC6202]] or Server-Sent Events [[?EVENTSOURCE]].
                    Forms may contain the necessary information to
                    identify the subprotocol in additional form fields.</li>
                <li><b>Security:</b> Security mechanisms can be
                    applied at different layers of the communication
                    stack and might be used together, often to
                    complement each other. Examples are (D)TLS
                    [[?RFC5246]]/[[?RFC6347]], IPSec [[?RFC6071]], OAuth
                    [[?RFC6749]], and ACE [[?RFC7744]]. Due to the
                    cross-cutting nature of security, the necessary
                    information to apply the right mechanism may be
                    given within the general metadata of the Thing.</li>
            </ul>
        </section>
        <section id="sec-scripting-api" class="informative">
            <h3>WoT Scripting API</h3>
            <p> The <a>Scripting API</a> is an optional "convenience"
                building block in WoT that eases IoT application
                development and is implemented using a Scripting Runtime
                (such as a Python, Lua or ECMAScript implementation)
                that is used in combination with a <a>WoT Runtime</a>.
                The Scripting API enables writing WoT applications by
                user-defined scripts.
            </p>
            <p> Traditionally, IoT device logic is implemented in
                firmware, which results in productivity constraints
                similar to that of embedded development, including a
                relatively complex update process. The <a>WoT
                Scripting API</a> in contrast supports enables
                implementing device logic by reusable scripts executed
                in a runtime system for IoT applications not dissimilar
                to that of a Web browser, and aims to improve
                productivity and reduce integration costs. Furthermore,
                standardized APIs enable portability for application
                modules, for instance, to move compute-intense logic
                from a device up to a local gateway, or to move
                time-critical logic from the cloud down to a gateway or
                edge node.
            </p>
            <p> The non-normative WoT Scripting API document defines
                the structure and algorithms of the programming
                interface that allows scripts to discover, consume
                (retrieve) and produce (define) Thing Descriptions. The
                implementation of the Scripting API instantiates local
                objects that act as an interface to other Things and
                represents their Interaction Affordances (Properties,
                Actions, and Events). It also allows scripts to expose
                Things, i.e. to specify and implement Interaction
                Affordances and publish a Thing Description.
            </p>
            <p> The standardized <a>WoT Scripting API</a> provides a
                contract between application scripts and the <a>WoT
                Runtime</a> in a <a>Servient</a> and is built on top of
                the <a>Thing</a> abstraction and the TD <a>Interaction
                Model</a>.
            </p>
        </section>
        <section id="sec-security-guidelines" class="informative">
            <h3>WoT Security and Privacy Guidelines</h3>
            <p> Security is a cross-cutting concern and should be
                considered in all aspects of system design. In the WoT
                architecture, security is supported by certain explicit
                features, such as support for public security metadata in TDs
                and by separation of concerns in the design of the
                Scripting API. The documents defining each building
                block also include a discussion of particular security
                and privacy considerations for each building block.
                Another set of documents, the WoT Security and Privacy
                Considerations [[?wot-security]], the WoT
                Security Best Practices
                [[?WOT-SECURITY-BEST-PRACTICES]], and the WoT Security
                Testing Plan [[?WOT-SECURITY-TESTING-PLAN]], provide
                additional non-normative security and privacy guidance.
            </p>
        </section>
    </section>

    <section id="sec-servient-implementation" class="informative">
        <h1>Servient Implementation</h1>
        <p> A <a>Servient</a> is a software stack that implements the
            WoT building blocks presented in the previous section. <a>Servients</a>
            can host and expose <a>Things</a> and/or consume <a>Things</a>.
            Thus, <a>Servients</a> can perform in both the <a>WoT Server</a> and
            <a>WoT Client</a> roles; the name (a portmanteau of server and client)
            is based on this dual role.
        </p>
        <p> The previous sections and 
            chapter <a href="#sec-wot-architecture"></a> 
            describes how the WoT
            building blocks conceptually relate to each other and to the
            abstract architecture. When implementing these concepts, a
            more detailed view is necessary that takes certain technical
            aspects into account. The detailed architecture of a <a>Servient</a>
            implementation using the (optional) WoT Scripting API is
            shown in <a href="#architecture-implementation"></a>.
            This figure shows and implementation that is using the optional 
            WoT Scripting API. 
            Scripts are actually executed by a nested Scripting Runtime, 
            while WoT-specific Servient Implementation aspects are managed
            by the WoT Runtime. 
            <a>Consumed Thing</a> and <a>Exposed Thing</a>
            objects provide abstract interfaces to the Things
            described in related Thing Descriptions. Scripts can
            operate on Things using these abstractions by performing
            abstract Interactions while the details of the Protocol Bindings are
            managed automatically by the WoT Runtime.
        </p>
        <figure id="architecture-implementation">
            <img src="images/wot-thing-scripting.png"
                style="width: 640px;" />
            <figcaption>Implementation of a Servient
                Using the Optional WoT Scripting API.
            </figcaption>
        </figure>
        <p> The role and functionality of each additional module shown
            in <a href="#architecture-implementation"></a> is given in
            the following sections.
        </p>

        <section>
            <h2>Applications</h2>
            <p> <a>Applications</a> running on a <a>Servient</a> provide
                implementations of interactions (for example, what the
                Servient actually does when a certain action is invoked)
                and optionally other behaviors, such as control loops or
                support for local user interfaces. 
                The <a>WoT Scripting API</a> is one way to
                implement an application using an application script,
                and is described in more detail below. Application
                scripts run inside a <a>Scripting Runtime</a> nested
                inside the <a>WoT Runtime</a> but have access to objects and
                interfaces defined by <a>WoT Runtime</a>.
            </p>
        </section>
        <section>
            <h2>Exposed Thing and Consumed Thing Abstractions</h2>
            <p> The <a>WoT Runtime</a> and <a>WoT Scripting API</a> provide
                <a>Exposed Thing</a> abstractions that represent Things exposed by
                the <a>Servient</a> (network interfaces presented to the outside when the
                Servient is acting as a server) and <a>Consumed Thing</a>
                abstractions representing other Things the Servient can
                communicate with in a client role.
            </p>
            <p> In the <a>WoT Scripting API</a> these abstractions are
                represented by actual object instances.
                These objects provide an abstract interface at the
                level of interactions, not specific protocols. 
                The <a>WoT Runtime</a> manages the translation of 
                these higher-level interactions to
                concrete protocol transactions using the Protocol Binding.
            </p>
        </section>
        <section>
            <h2>Private Security Metadata</h2>
            <p> Private security metadata is also conceptually
                managed by the <a>WoT Runtime</a> but is intentionally not made
                directly accessible to the application. In fact, in the
                most secure hardware implementations, such private
                security data is stored in a separate, isolated memory
                and only an abstract set of operations (possibly even
                implemented by an isolated processor and software stack)
                is provided that limit the attack surface and prevent
                external disclosure of this data. Private security data
                is used transparently by the <a>Protocol Binding</a> to
                authorize and protect the integrity and confidentiality
                of interactions.</p>
        </section>
        <section>
            <h3>WoT Scripting API</h3>
            <p> The <a href="https://w3c.github.io/wot-scripting-api/">WoT Scripting
                    API specification</a> describes a low level <a
                    href="https://www.ecma-international.org/default.htm">ECMAScript</a>
                API that follows the <a
                    href="https://w3c.github.io/wot-thing-description">WoT Thing
                    Description specification</a> closely. Other, simpler
                APIs may be implemented on top of it.
            </p>
            <p>In principle, any programming language and API can be
                used in order to define the behavior of a Thing, as long
                as the <a>Interaction Affordances</a> are presented externally
                through <a>Protocol Bindings</a> and (optionally) access
                to the information encoded in <a>Thing Descriptions</a> is
                provided. (Ideally via <a>Consumed Thing</a> and <a>Exposed Thing</a>
                abstractions, which are providing similar functionality to the objects
                in the <a>WoT Scripting API</a>).
            </p>
            <p class="ednote"
                title="The node-wot Reference Implementation">
                The current reference implementation of the <a>Scripting
                    API</a> is the open-source <a
                    href="https://github.com/eclipse/thingweb.node-wot">
                    Eclipse ThingWeb (node-wot)</a> project. This API is the
                only one at the moment that currently ensures "de facto"
                portability of WoT scripts.
            </p>
            <p> See <a href="https://w3c.github.io/wot-scripting-api/">
                    WoT Scripting API</a> for more details.
            </p>
        </section>
        <section>
            <h2>WoT Runtime</h2>
            <p> At a low level, the <a>Thing</a> abstraction and <a>Interaction
                    Model</a> is implemented in a runtime system that is
                independent of but supports the <a>WoT Scripting API</a>.
                This <a>WoT Runtime</a> also interfaces with the <a>Protocol
                    Bindings</a> subsystem to access remote <a>Things</a>
                and (optionally) with the system API to access local
                hardware and proprietary communication protocols. Both
                local hardware and devices behind proprietary
                communications protocols may also represented as <a>Things</a>
                in the runtime environment, that is, they can be made
                accessible via <a>Consumed Thing</a> abstractions. The <a>WoT
                    Runtime</a> is also tasked with generating and exposing a <a>Thing
                    Description</a> based on general metadata (e.g.,
                location), application metadata (e.g., <a>Interaction
                    Affordance</a>), and communication metadata for the
                available <a>Protocol Bindings</a>
                (e.g., based on <a>WoT Binding Templates</a>).
            </p>
        </section>
        <section>
            <h2>Scripting Runtime</h2>
            <p> When the <a>WoT Scripting API</a> is used an additional
                nested <a>Scripting Runtime</a> is needed, which is a
                language runtime to actually manage and execute scripts.
                The <a>Scripting Runtime</a> runs inside of but is
                distinct from the <a>WoT Runtime</a>.
            </p>
        </section>
        <section>
            <h2>Life Cycle Management</h2>
            <p> Certain operations are needed to manage the lifecycle
                of an exposed Thing such as retrieving and/or serving
                a Thing Description, instantiating an <a>Exposed Thing</a> abstraction based
                on the Thing Description, and terminating an
                <a>Exposed Thing</a>. The details of such operations vary among
                different kinds of devices. A WoT Servient Life Cycle
                Management (LCM) system encapsulates those lifecycle
                operations. It uses internal interfaces to realize the
                lifecycle management of exposed Things. The LCM is a
                system component that integrates with the <a>WoT Runtime</a>.
                The <a>WoT Scripting API</a> provides one implementation of the
                LCM functionality.
             </p>
             <p> For a <a>WoT Client</a> or <a>Servient</a>, the lifecycle management of 
                 <a>Consumed Things</a> is realized in the same manner as that
                 of <a>Exposed Things</a>.
             </p>
        </section>
        <section>
            <h2>Protocol Bindings</h2>
            <p> <a>Protocol Bindings</a> are implementations of the 
                <a>Binding Templates</a>. 
                They produce the concrete protocol transactions to interact
                with other <a>Things</a> over the network based on the
                communication metadata given in the <a>Thing
                    Description</a> of the <a>Consumed Thing</a>. 
                <a>Servients</a> may have multiple <a>Protocol Bindings</a> to
                enable interaction with different <a>IoT Platforms</a>.
            </p>
            <p> In many cases, where standard protocols are used,
                generic protocol stacks can be used to produce the
                platform-specific messages (e.g., one for HTTP(S)
                dialects, one for CoAP(S) dialects, and one for MQTT
                solutions, etc.). In this case, the communication
                metadata from the <a>Thing Description</a> is used to
                select and configure the right stack (e.g., HTTP with
                the right header fields or CoAP with the right options).
                Parsers and serializers for the expected payload representation
                format (JSON, CBOR, XML, etc.)
                as identified by the Internet Media Type can also be
                shared across these generic protocol stacks.
            </p>
            <p> In some cases, where no aspects can be shared, the <a>Protocol
                    Binding</a> is more comparable to a platform-specific
                driver that is selected and configured through the
                communication metadata in similar way as above.
            </p>
            <p> See <a
                    href="https://w3c.github.io/wot-binding-templates/">WoT
                    Binding Templates</a> for details.
            </p>
        </section>
        <section>
            <h2>System API</h2>
            <p> The implementation of a <a>Thing</a> may access local
                hardware or system services (e.g. storage) through
                proprietary APIs or other means. This block is out of
                scope of WoT standardization.
            </p>
            <p> However, a given implementation of a <a>WoT Runtime</a>
                may provide local hardware or system services to
                application scripts through a <a>Thing</a>
                abstraction, as if they were accessible over a network
                protocol. In this case the implementation should be
                optimized to avoid the overhead that would be involved
                in a literal implementation of a network protocol while
                maintaining a consistent <a>WoT Interface</a>.
            </p>
            <p> A device may also be physically external to a <a>Servient</a>,
                but connected via a proprietary protocols or a protocol
                not eligible for direct support as part of the WoT. In
                this case, the implemented runtime environment may
                access legacy devices with such protocols (e.g., Echonet
                Lite, BACNET, X10, I2C, SPI, etc.) through proprietary APIs,
                but may again choose to expose them to applications via
                a <a>Thing</a> abstraction. A <a>Servient</a> can then act
                as gateway to the legacy devices. This should only be
                done if the legacy device cannot be described directly
                using a <a>WoT Thing Description</a>.
            </p>
        </section>
        <section id="alt-servient-impl">
            <h3>Alternative Servient Implementations</h3>
            <p> The <a>WoT Scripting API</a> building block is optional.
                Alternative <a>Servient</a> implementations are possible
                where applications are implemented using alternative
                APIs internally. There are two possibilities for such
                implementations: those that use the <a>WoT Runtime</a> but use
                an alternative API and programming language for defining
                an application; and those that do not use a <a>WoT Runtime</a>
                but are implemented using a separate software stack. The
                second case can still be incorporated into a WoT system
                if they use a WoT-supported protocol and a Thing
                Description can be provided for such devices or services.
            </p>
            <section id="native-impl">
                <h3>Native WoT API</h3>
                <p>
                    There are various reasons why a developer may choose
                    to implement a <a>Servient</a> without using the <a>WoT
                        Scripting API</a>. This may be due to insufficient 
                    memory or computing resources, so the developer can't use
                    the required software stack or a fully-featured scripting
                    engine. Alternatively, to support their use case (for
                    example, a proprietary communications protocol) 
                    the developer may have to use
                    specific functions or libraries only available
                    through a particular programming environment or
                    language.
                </p>
                <p> In this case, a <a>WoT Runtime</a> can still be
                    used, but with the equivalent abstraction and functionality 
                    exposed using an alternative WoT API instead of through
                    the <a>WoT Scripting API</a>.
                </p>
                <figure id="architecture-implementation-native">
                    <img src="images/wot-thing-native.png"
                        style="width: 640px;" />
                    <figcaption>Implementation of a
                        Servient using an Alternative Native WoT API</figcaption>
                </figure>
            </section>
            <section id="existing-impl">
                <h3>Existing Device Described with a Thing
                    Description</h3>
                <p> It is also possible to support <em>existing</em> IoT devices
                    or services in the WoT and integrate them with other
                    WoT Things by writing a <a>Thing Description</a> for them.
                    This can only be done however if the target device
                    is using protocols eligible for WoT <a>Protocol
                    Bindings</a>. If the device itself cannot be modified, a
                    <a>Thing Description</a> may also have to be provided
                    separately using a service such as a <a>Thing Directory</a>
                    or some other external distribution mechanism. 
                    Providing a <a>Thing Description</a> for
                    a device also only allows it to be used in the
                    <a>WoT Server</a> role. 
                    Using such a device in the <a>WoT Client</a> role
                    may also be possible if the device can be modified to
                    consume <a>Thing Descriptions</a> itself or if a separate
                    management system can be used to configure it using
                    information found in <a>Thing Descriptions</a>.
                </p>
                <figure id="architecture-implementation-existing">
                    <img src="images/wot-thing-existing.png"
                        style="width: 640px;" />
                    <figcaption>Integration of Existing IoT
                        Devices into the WoT</figcaption>
                </figure>
            </section>
        </section>
    </section>

    <section id="sec-deployment-scenario" class="informative">
        <h1>WoT Deployments</h1>

        <p> This section discusses how the Web of Things as a whole works
            when <a>Things</a> implementing IoT devices and services are 
            connected together in various topologies and deployment scenarios.
            These are only examples and other interconnection topologies are possible. 
            The interconnection topologies 
            described here are derived from the Web of Things use cases 
            (<a href="#sec-use-cases"></a>)
            as well as the technical requirements extracted from them
            (<a href="#sec-requirements"></a>).
            Before discussing specific topologies, we will
            first review the roles that WoT <a>Things</a> can
            play in a network and the relationship of these roles to the 
            <a>Consumed Thing</a> and <a>Exposed Thing</a> abstractions
            presented internally to each <a>Thing</a>'s internal
            behavior implementation.
        </p>

        <section id="sec-client-server-roles">
            <h2>Client and Server Roles</h2>
            <p> A <a>WoT Server</a> creates an <a>Exposed Thing</a> abstraction based on a TD. 
                The TD is published to make it available to 
                other <a>WoT Clients</a> or <a>Servients</a>.
                Such publication can be done in various ways: the TD
                might be registered with a <a>Thing Directory</a> service, 
                or the <a>WoT Server</a>
                may provide requesters with the TD upon receiving a discovery request.
                It is also possible in some application scenarios for TDs to be associated with
                <a>WoT Servers</a> statically or via a management system.
            </p>
            <p> A <a>WoT Client</a> obtains the TDs of <a>WoT Servers</a> 
                via a discovery process appropriate to the deployment scenario
                in which it is used (<a>Thing Directory</a>, discovery protocol,
                static assignment, management system, etc.)
                and creates <a>Consumed Thing</a> abstractions for each based on the
                obtained TDs. 
                Internal system functions of a device such as attached sensors and actuators
                can also optionally be represented as <a>Consumed Thing</a> abstractions.
            </p>
            <p> The functions supported by the 
                <a>Exposed Thing</a> and <a>Consumed Thing</a> abstractions
                are provided internally to the <a>Thing</a>'s behavior implementation
                via a programming language interface.
                In the <a>WoT Scripting API</a>, these abstractions are represented by objects.
                The behavior implementation (that is, the application logic)
                running in the <a>Thing</a> can then
                achieve its functions, such as appropriately responding to
                interactions, by using this interface.
            </p>
            <p> A <a>WoT Server</a> may or may not be a device associated with physical
                sensors and actuators; 
                it may also be a service running in a gateway 
                or in the cloud.  
                Likewise a <a>WoT Client</a> may or may not be 
                an application service running on a gateway or cloud, it
                may in some cases be necessary to implement <a>WoT Client</a>
                functionality on edge devices.  
                In some cases a single <a>Thing</a>
                simultaneously performs both roles using a single <a>WoT Runtime</a>,
                in which case we call it a <a>Servient</a>.
            </p>
        <section id="sec-deployment-app-dev">
            <h2>Client and Server on the Same Network</h2>
            <p> In the simplest interconnection topology, illustrated by <a href="#simple-conf-application-device"></a>,
                the <a>WoT Client</a> and <a>WoT Server</a> are on the same network and can communicate
                directly with each other without any intermediaries.
                One use case where this topology arises is when the <a>WoT Client</a> is an orchestration
                service or some other IoT application running on a gateway and the <a>WoT Server</a> is a device interfacing to 
                a sensor or actuator.  However, the client/server relationship could easily be reversed;
                the client could be a device in the <a>WoT Client</a> role accesses
                a service running as a <a>WoT Server</a> on a gateway or in the cloud.
            </p>
            <figure id="simple-conf-application-device">
                <img src="images/arch-simple-conf-application-device.png" />
                <figcaption>Client and Server on the Same Network</figcaption>
            </figure>
            <p> If the <a>WoT Server</a> is in the cloud and the <a>WoT Client</a> is on a local network
                (for example, in a Smart Home use case) the actual network topology may be more complex, 
                for example requiring NAT traversal and disallowing certain forms of discovery.  
                In such cases one of the more complex
                topologies discussed later may be more appropriate.
            </p>
        </section>
        <section id="sec-deployment-app-proxy-dev">
            <h2>Servient Acting as a Proxy</h2>
            <p> A <a>Servient</a> plays both <a>WoT Server</a> and
                <a>WoT Client</a> roles on the network and supports
                both the <a>Exposed Thing</a> and <a>Consumed Thing</a>
                abstractions within its <a>WoT Runtime</a>. 
            </p>
            <p> One simple application of a <a>Servient</a> is as a proxy.  
                When functioning as a proxy,
                the <a>Servient</a> generally interfaces with two separate
                networks or protocols.  This may involve 
                the implementation of additional security mechanisms
                such as providing TLS endpoints.  Generally proxies
                do not modify the set of interactions so the TD exposed
                by the <a>Servient</a> will have the same interactions
                as the consumed TD but with the connection metadata modified.
            </p>
            <p> To implement this pattern, the proxy <a>Servient</a> obtains a TD
                of a <a>WoT Server</a> and creates a <a>Consumed Thing</a>. 
                It creates a "shadow" of the <a>WoT Server</a> as a software
                implementation that has the same interactions.
                It then creates a TD for the shadow device with a new identifier 
                and possibly with new communications metadata (protocol bindings)
                and/or new public security configuration metadata.
                Finally an <a>Exposed Thing</a> is
                created based on this TD, and the <a>Servient</a> notifies other
                <a>WoT Clients</a> or <a>Servients</a> of the TD via
                an appropriate publication mechanism.
            </p>
            <figure id="simple-conf-application-proxy-device">
                <img
                    src="images/arch-simple-conf-application-proxy-device.png" />
                <figcaption>Client and Server Connect via a Servient Acting as a Proxy</figcaption>
            </figure>
            <p> More complex intermediaries may be known as digital twins.
                A digital twin may or may not modify the protocols or
                translate between networks, but they provide additional
                services, such as state caching, deferred updates, 
                or even predictive simulation of the behavior of the target device.
                For example, if an IoT device has limited power, it 
                may choose to wake up relatively infrequently, synchronize
                with a digital twin, and then immediately go to sleep again.
                In this case the digital twin runs on a less power-constrained
                device (such as in the cloud or on a gateway) 
                and is able to respond to interactions on the 
                constrained device's behalf.
                Requests for the current state of properties
                may also be satisfied by the digital twin using cached state.
                Requests that arrive when the target IoT device is sleeping
                may be queued and sent to it when it wakes.
                One complication with implementing this pattern is that the 
                digital twin <a>Servient</a> needs to know when the device is awake if it
                is implemented as a <a>WoT Server</a>.  The actual implementation
                may need to be augmented with a notification mechanism (which could
                be implemented using a separate <a>WoT Client</a>/<a>WoT Server</a> pair),
                although it may also be possible to use event interactions for this
                purpose.
            </p>
        </section>

        <section id="sec-deployment-cloud-rm">
            <h2>Devices in a Local Network Controlled from a Cloud Service</h2>
            <p> In Smart Home use cases, devices (sensors and home appliances)
                connected to a home network are often
                monitored and, in some cases, also controlled by cloud
                services. There is usually a NAT between the home
                network to which the devices are connected and the cloud.
                The NAT translates IP addresses as well as often providing
                firewall services, which block connections selectively.
                The local devices and cloud services can only communicate
                with each other if the communication can successfully
                traverse the NAT. 
            </p>
            <p> A typical structure,
                adopted in ITU-T Recommendation Y.2070,
                is shown in <a href="#deployment-cloud-device"></a>.
                In this structure there is both a local and a remote <a>Servient</a>.
                The local <a>Servient</a> aggregates the interaction affordances from multiple
                <a>WoT Servers</a> into a (set of) <a>Exposed Things</a>, 
                which can all be mapped onto a common protocol 
                (for example, HTTP, with all interactions mapped to a single
                URL namespace with a common base server and using a single port).
                This provides the remote <a>Servient</a> with a simple way to
                access all the <a>WoT Servers</a> behind the NAT,
                assuming the local <a>Servient</a>
                has used a converged protocol that can traverse the NAT
                and has some way to expose this service to the Internet (STUN, TURN, DyDNS, etc).
                In addition, the local <a>Servient</a> can function as a proxy, so
                even when the connected <a>WoT Servers</a> each use a different
                protocol (HTTP, MQTT, CoAP, etc.) and/or a different set of
                ecosystem conventions, the
                <a>Exposed Thing</a> can converge them into a single protocol so
                that clients do not need to be aware of the various
                protocols the servers use.  
            </p>
            <p> In the figure, there are two
                clients connected to the remote <a>Servient</a>, which
                has disaggregated the services available behind the NAT and may
                provide additional protocol translation or security services.
                In particular, the local <a>Servient</a> may be on a network
                with limited capacity and making that service directly available to all
                users may not be feasible.  In this case access to the local 
                <a>Servient</a> is _only_ provided to the remote <a>Servient</a>.
                The remote <a>Servient</a> then implements a more general access
                control mechanism and may also perform caching or throttling to
                protect the client from excess traffic.
                Those clients also will use a 
                single protocol suitable for the open Internet (e.g. HTTPS) to communicate with the
                <a>Servient</a>, which makes the development of clients much
                simpler.
            </p>
            <p> In this topology there is a NAT and a firewall between the clients and servers,
                but the local and remote <a>Servients</a> work together to tunnel all communications
                through the firewall, so the clients and servers need to know
                nothing about the firewall.
                The paired <a>Servients</a> also protect the home devices by providing
                access control and traffic management.
            </p>
            <figure id="deployment-cloud-device">
                <img src="images/arch-deploy-cloud-device.png" />
                <figcaption>Cloud Applications Implemented as WoT Clients Connected to
                    Local Devices implemented as WoT Servers via Paired Servients</figcaption>
            </figure>
            <p> In more difficult cases the NAT and firewall traversal may not work exactly as
                shown. In particular, an ISP may not support publicly accessible addresses,
                or STUN/TURN and/or DyDNS may not be supported or available.  
                In this case the <a>Servients</a>
                may alternative reverse the client/server roles between then to set up an initial
                connection (with the local <a>Servient</a> first connecting to the remote <a>Servient</a>
                in the cloud), then the pair of <a>Servients</a>
                may establish a tunnel (using for example, a Secure Web Socket, which uses TLS
                to protect the connection).
                The tunnel can then be used to encode all communications between the 
                <a>Servients</a> using a custom protocol.  
                In this case the initial connection can still be made over HTTPS using standard
                ports, and from the local <a>Servient</a> to the remote <a>Servient</a> identically
                to a normal browser/web server interaction.  
                This should be able to traverse most home firewalls, and since the connection
                is outgoing, network address translation will not cause any problems.  
                However, even though a custom tunneling protocol is needed, the 
                remote <a>Servient</a> can still translate this custom protocol back into
                standard external protocols.  The connected <a>WoT Clients</a> and <a>WoT Servers</a>
                do not need to know about it.  
                It is also possible to extend this example to use cases where both <a>WoT Servers</a>
                and <a>WoT Clients</a> can connect on either side of the NAT boundary.
                This however also requires a bidirectional tunnel to be established between
                the two <a>Servients</a>.
            </p>
        </section>
        <section id="sec-deployment-discovery-with-directory-rm">
            <h2>Discovery Using a Thing Directory</h2>
<!-- "application" and "device" are used intentionally here instead of client or server, since they
     might be either! -->
            <p> Once local devices (and possibly services) 
                can be monitored or controlled by services
                on cloud, a variety of additional services can be built on top.
                For example, a cloud application could change a device's
                operating condition based on an analysis of collected data.
            </p>
            <p> However when the remote <a>Servient</a> is a part of a cloud platform
                servicing client applications, the clients need to be able to find
                device information by, for example, accessing a
                directory of connected devices.  For simplicity in the figure below
                we have assumed all local devices are implemented as <a>WoT Servers</a> and
                all cloud applications as <a>WoT Clients</a>.
                To make the metadata of local devices implemented as <a>WoT Servers</a>
                available to the cloud applications,
                their metadata
                can be registered with a <a>Thing Directory</a> service.
                This metadata is specifically the TDs of the local devices modified to 
                reflect the security configuration and communication metadata
                provided by the remote <a>Servient</a>.
                A client application then can obtain the metadata
                it needs to communicate with local devices to
                achieve its functionality by querying the <a>Thing Directory</a>.
            </p>
            <figure id="deployment-cloud-directory">
                <img src="images/arch-deploy-service-directory.png" />
                <figcaption>Cloud Service with Thing Directory</figcaption>
            </figure>
            <p> In more complex situations, not shown in the figure, there
                may also be cloud services that act as <a>WoT Servers</a>.
                These can also register themselves with the <a>Thing Directory</a>.
                Since a <a>Thing Directory</a> is a web service, it should be visible
                to the local devices through the NAT/firewall 
                and its interface can even be provided with its own TD.  
                Local devices acting as <a>WoT Clients</a> can then
                connect to the <a>Thing Directory</a> either directly or via the local
                <a>Servient</a> if proxying (e.g. protocol translation) is needed.
            </p>
        </section>
        <section id="sec-deployment-service-to-service-rm">
            <h2>Service-to-Service Connections Across Multiple Domains</h2>
            <p> Multiple cloud eco-systems each based on different
                IoT platforms can work together to make a larger,
                system-of-systems eco-system. Building on the previously
                discussed structure of a cloud application eco-system,
                the figure below shows two eco-systems connected to each
                other to make a system-of-systems. Consider the case in
                which a client in one eco-system (i.e. <a>WoT Client</a> A 
                below) needs to use a server in another eco-system 
                (i.e. <a>WoT Server</a> B below). 
                There is more than one mechanism to
                achieve this cross eco-systems application-device
                integration. 
                Below, two mechanisms are
                explained, each using a figure, to show how this can be achieved.</p>
            <section id="sec-deployment-service-to-service-rm-synchronized">
                <h3>Connection Through Thing Directory Synchronization</h3>
                <p> In <a href="#deployment-service-sync-directory"></a>,
                    two <a>Thing Directories</a>
                    synchronize information, which makes it possible
                    for <a>WoT Client</a> A to obtain the information of
                    <a>WoT Server</a> B through <a>Thing Directory</a> A. As described in
                    previous sections, remote <a>Servient</a> B maintains a shadow
                    implementation of <a>WoT Server</a> B. 
                    By obtaining the TD of this shadow
                    device, <a>WoT Client</a> A is able to use <a>WoT Server</a> B through the
                    remote <a>Servient</a> B.
                </p>
                <figure id="deployment-service-sync-directory">
                    <img src="images/arch-deploy-service-sync-directory.png" />
                    <figcaption>Multiple Cloud Connections Through Thing
                        Directory Synchronization</figcaption>
                </figure>
            </section>
            <section id="sec-deployment-service-sync-proxy-rm">
                <h3>Connection Through Proxy Synchronization</h3>
                <p> In <a href="#deployment-service-sync-proxy"></a>, two remote <a>Servients</a>
                    synchronize device information. When a shadow of <a>WoT Server</a>
                    B is created in remote <a>Servient</a> B, the shadows TD is
                    simultaneously synchronized into remote <a>Servient</a> A.
                    Remote <a>Servient</a> A in turn creates its own shadow of
                    <a>WoT Server</a> B, and registers the TD with <a>Thing Directory</a>
                    A. With this mechanism, synchronization between 
                    <a>Thing Directories</a> is not necessary.
                </p>
                <figure id="deployment-service-sync-proxy">
                    <img src="images/arch-deploy-service-sync-proxy.png" />
                    <figcaption>Multiple Cloud Connections Through
                        Proxy Synchronization</figcaption>
                </figure>
                </section>
            </section>
        </section>
    </section>

    <section id="sec-security-considerations" class="informative">
        <h1>Security and Privacy Considerations</h1>
        <p>
            Security is a cross-cutting issue that needs to be taken
            into account in all <a href="#sec-building-blocks">WoT
                building blocks</a> and WoT implementations. This chapter
            summarizes some general issues and guidelines to help
            preserve the security and privacy of WoT implementations.
            For a more detailed and complete analysis of security and
            privacy threats, risks, mitigations, and best practices, see
            the WoT Security and Privacy Considerations
            [[?wot-security]] and the WoT Security Best
            Practices [[?WOT-SECURITY-BEST-PRACTICES]] documents.
            Guidelines for the security testing of WoT implementations,
            including adversarial testing, are given in the WoT Security
            Testing Plan [[?WOT-SECURITY-TESTING-PLAN]].
        </p>
        <p>Overall, the goal of the WoT is to describe the existing
            access mechanisms and properties of IoT devices and
            services, including security. In general, W3C WoT is
            designed to describe what exists rather than to prescribe
            what to implement.</p>
        <p>
            However, the WoT architecture should <em>enable</em> the use
            of best practices in security and privacy. The WoT security
            architecture must support the goals and mechanisms of the
            IoT protocols and systems it connects to. These systems vary
            in their security requirements and risk tolerance, so
            security mechanisms will also vary based on these factors.
        </p>
        <p>Security and privacy are especially important in the IoT
            domain since IoT devices need to operate autonomously and in
            many cases have access to both personal data and/or can be
            in control of safety-critical systems. Compared to personal
            systems, IoT devices are subject to different and in some
            cases higher risks than IT systems. It is also important to
            protect IoT systems so that they can not be used to launch
            attacks on other computer systems.</p>
        <p>In general, security and privacy cannot be guaranteed. It
            is not possible for the WoT to turn an insecure system into
            a secure one. Specifically, the WoT architecture needs to do
            no harm: it should support security and privacy at least as
            well as the systems it connects to.</p>
        <section id="sec-security-consideration-definitions">
            <h2>Definitions</h2>
            <dl>
                <dt>Security</dt>
                <dd>means a system should preserve its integrity
                    and functionality even when subject to attack.</dd>
                <dt>Personally Identifiable Information (PII)</dt>
                <dd>means information that can be associated with a
                    unique individual.</dd>
                <dt>Privacy</dt>
                <dd>means that the system should maintain the
                    confidentiality of personally identifiable
                    information.</dd>
            </dl>
        </section>
        <section id="sec-security-consideration-td-risks">
            <h2>WoT Thing Description Risks</h2>
            <p>
                The metadata contained in a <a>WoT Thing Description</a>
                (TD) is potentially sensitive. As a best practice, TDs
                should be used together with integrity protection
                mechanisms and access control policies, and should be
                provided only to authorized users.
            </p>
            <p>Please refer to the Security and Privacy
                Consideration section of the WoT Thing Description
                specification for additional details and discussion.</p>
            <section id="sec-security-consideration-td-private">
                <h5>Thing Description Private Security Data Risk</h5>
                <p>
                    TDs are designed to carry only public security data.
                    Producers of TDs must ensure that no private
                    security information is included in <a>TDs</a>.
                    There should be a strict separation of public and
                    private security data. A TD should contain only
                    public security information, letting users know what
                    they need to do to access as system if and only if
                    they have authorization. Authorization in turn
                    should be based on separately managed private
                    information.
                </p>
                <p>The built-in TD security schemes defined in the
                    TD specification do not support the encoding of
                    private security data. However, other fields such as
                    human-readable descriptions might be used
                    (incorrectly...) to encode this information, or new
                    security schemes might be defined and deployed via
                    the extension mechanism that encode such
                    information.</p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>TD producers must ensure that no private
                        security data is ever stored in TDs.</dd>
                </dl>
            </section>
            <section id="sec-security-consideration-td-pii">
                <h5>Thing Description Personally Identifiable
                    Information Risk</h5>
                <p>Thing descriptions can potentially contain
                    personally identifiable information of various
                    types. Even if it is not explicit, the presence of
                    semantic information in a TD and its association
                    with a person can be used to infer information about
                    that person. For example, the association of
                    uniquely identifiable TDs exposed by mobile devices
                    whose location can be determined can be a tracking
                    risk.</p>
                <p>Generally, personally identifiable information in
                    a TD should be limited as much as possible. In some
                    cases, however, it cannot be avoided. The potential
                    presence of PII in a TD means that TD should be
                    treated like other forms of PII. They should be
                    stored and transmitted in a secure fashion, should
                    only be cached for limited times, should be deleted
                    upon request, should only be used for the purpose
                    for which they were provided with user consent, and
                    they should otherwise satisfy local requirements for
                    the use of PII.</p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>Storage of PII in TDs should be minimized
                        as much as possible. Even without explicit PII
                        in TDs, a tracking and identification privacy
                        risk may exist. To minimize this risk, TDs
                        should be treated as if they contained PII and
                        subject to the same management policies as other
                        PII. They should only be provided to authorized
                        users.</dd>
                </dl>
            </section>
            <section id="sec-security-consideration-td-cm">
                <h5>Thing Description Communication Metadata Risk</h5>
                <p>
                    The <a>WoT Binding Templates</a> must correctly
                    support the security mechanisms employed by the
                    underlying <a>IoT Platform</a> for that platform to
                    be considered eligible for use with WoT. Due to the
                    automation of network interactions necessary to
                    deploy IoT at scale, operators need to ensure that <a>Things</a>
                    are exposed and consumed in a way that is compliant
                    with their security policies.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        Whenever possible, use the vetted communication
                        metadata provided in the <a>WoT Binding
                            Templates</a>. When using a TD for an IoT
                        ecosystem not covered by the <a>WoT Binding
                            Templates</a>, ensure that all the security
                        requirements of the <a>IoT Platform</a> are
                        satisfied.
                    </dd>
                </dl>
            </section>
        </section>
        <section id="sec-security-consideration-scripting-risks">
            <h2>WoT Scripting API Security and Privacy Risks</h2>
            <p>
                The <a>WoT Runtime</a> implementation and the <a>WoT
                    Scripting API</a> should have mechanisms to prevent
                malicious access to the system and isolate scripts in
                multi-tenant <a>Servients</a> . More specifically the <a>WoT
                    Runtime</a> implementation when used with the <a>WoT
                    Scripting API</a> should take into account the below
                security and privacy risks and implement the recommended
                mitigations.
            </p>
            <section id="sec-security-consideration-cross-script">
                <h5>Cross-Script Security and Privacy Risk</h5>
                <p>
                    In basic WoT setups, all scripts running inside the
                    <a>WoT Runtime</a> are considered trusted,
                    distributed by the manufacturer, and therefore there
                    is no strong need to perform strict isolation
                    between each running script instance. However,
                    depending on device capabilities, deployment use
                    case scenarios, and risk level it might be desirable
                    to do so. For example, if one script handles
                    sensitive privacy-related PII data and is
                    well-audited, it might be desirable to separate it
                    from the rest of the script instances to minimize
                    the risk of data exposure in case some other script
                    inside WoT gets compromised during runtime. Another
                    example is mutual co-existence of different tenants
                    on a single WoT device. In this case each WoT
                    runtime instance will be hosting a different tenant,
                    and isolation between them is required.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The WoT runtime should perform isolation of
                        script instances and their data in cases when
                        scripts handle privacy-related or other critical
                        security data. Similarly, the <a>WoT Runtime</a>
                        implementation should perform isolation of <a>WoT
                            Runtime</a> instances and their data if a WoT
                        device has more than one tenant. Such isolation
                        can be performed within the <a>WoT Runtime</a>
                        using platform security mechanisms available on
                        the device. For more information see Sections
                        "WoT Servient Single-Tenant" and "WoT Servient
                        Multi-Tenant" of
                        [[wot-security]].
                    </dd>
                </dl>
            </section>
            <section
                id="sec-security-consideration-device-direct-access">
                <h5>Physical Device Direct Access Security and
                    Privacy Risk</h5>
                <p>In case a script is compromised or misbehaving,
                    the underlying physical device (and potentially
                    surrounded environment) can be damaged if a script
                    can use directly exposed native device interfaces.
                    If such interfaces lack safety checks on their
                    inputs, they might bring the underlying physical
                    device (or environment) to an unsafe state.</p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The <a>WoT Runtime</a> should avoid directly
                        exposing the native device interfaces to the
                        script developers. Instead a <a>WoT Runtime</a>
                        implementation should provide a hardware
                        abstraction layer for accessing the native
                        device interfaces. Such hardware abstraction
                        layer should refuse to execute commands that
                        might put the device (or environment) to an
                        unsafe state. Additionally, in order to reduce
                        the damage to a physical WoT device in cases a
                        script gets compromised, it is important to
                        minimize the number of interfaces that are
                        exposed or accessible to a particular script
                        based on its functionality.
                    </dd>
                </dl>
            </section>
        </section>
        <section id="sec-security-consideration-runtime-risks">
            <h2>WoT Runtime Security and Privacy Risks</h2>
            <section id="sec-security-consideration-update-provisioning">
                <h5>Provisioning and Update Security Risk</h5>
                <p>
                    If the <a>WoT Runtime</a> implementation supports
                    post-manufacturing provisioning or updates of
                    itself, WoT scripts, or any related data (including
                    security credentials), it can be a major attack
                    vector. An attacker can try to modify any above
                    described element during the update or provisioning
                    process or simply provision attacker's code and data
                    directly.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        Post-manufacturing provisioning or update of
                        scripts, the <a>WoT Runtime</a> itself or any
                        related data should be done in a secure fashion.
                        A set of recommendations for secure update and
                        post-manufacturing provisioning can be found in
                        [[wot-security]].
                    </dd>
                </dl>
            </section>
            <section id="sec-security-consideration-credentials-storage">
                <h5>Security Credentials Storage Security and
                    Privacy Risk</h5>
                <p>
                    Typically the <a>WoT Runtime</a> needs to store the
                    security credentials that are provisioned to a WoT
                    device to operate in WoT network. If an attacker can
                    compromise the confidentiality or integrity of these
                    credentials, then it can obtain access to the WoT
                    assets, impersonate WoT things or devices or create
                    Denial-Of-Service (DoS) attacks.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The <a>WoT Runtime</a> should securely store any
                        provisioned security credentials, guaranteeing
                        their integrity and confidentiality. In case
                        there are more than one tenant on a single
                        WoT-enabled device, a <a>WoT Runtime</a>
                        implementation should guarantee isolation of
                        each tenant's provisioned security credentials.
                        Additionally, in order to minimize a risk that
                        provisioned security credentials get
                        compromised, the <a>WoT Runtime</a>
                        implementation should not expose any API for
                        scripts to query the provisioned security
                        credentials. Such credentials (or event better,
                        abstract operations that use them but do not
                        expose them) should only be accessible to the <a>Protocol
                            Binding</a> implementation that uses them.
                    </dd>
                </dl>
            </section>
        </section>
    </section>
    <section id="appendix-example-sequences" class="appendix informative">
        <h1>Example Sequences of interaction patterns</h1>
        <p> This section illustrates example sequences of application and protocol
            transactions that correspond to operations 
            (defined in <a href="#table-operation-types"></a>)
            implementing various interactions
            among <a>WoT Clients</a> and <a>WoT Servers</a>.
            The illustrations show both the concrete protocol transactions
            and the interactions between the applications running
            inside the <a>WoT Client</a> and <a>WoT Server</a>
            and the <a>Consumed Thing</a> and <a>Exposed Thing</a> abstractions.
        </p>
        <p> For the sake of simplicity, remote and local proxies
            between client and server are omitted from the following sequences.
            We also assume HTTP as the concrete protocol
            and omit any additional transactions for implementing security,
            such as those that would be used for authentication or
            to set up a secure connection for HTTPS.
            Other concrete protocols and the addition of security transactions
            however would only effect the concrete protocol transactions,
            not the application-level interactions with the
            <a>Consumed Thing</a> and <a>Exposed Thing</a> abstractions.
        </p>
        <section>
            <h2>Property Interactions</h2>
            <section>
                <h3>Read property (HTTP binding)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "readproperty" operation
                   with an HTTP protocol binding.</p>
                <p>
                    <img
                        src="images/message-flows/A_1_1_readProperty.png"
                        alt="Read property (HTTP binding)" />
                </p>
            </section>
            <section>
                <h3>Write property (HTTP binding)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "writeproperty" operation
                   with an HTTP protocol binding.</p>
                <p>
                    <img
                        src="images/message-flows/A_1_2_writeProperty.png"
                        alt="Write property (HTTP binding)" />
                </p>
            </section>
            <section>
                <h3>Observe property (HTTP binding with Long Polling subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "observeproperty" operation
                   with an HTTP protocol binding using 
                   the "longpolling" (Long Polling) subprotocol.</p>
                <p>
                    <img
                        src="images/message-flows/A_1_3a_observePropertyLongPoll.png"
                        alt="Observe property (HTTP binding with Long Polling subprotocol)" />
                </p>
            </section>
            <section>
                <h3>Observe property (HTTP binding with Server Sent Event subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "observeproperty" operation
                   with an HTTP protocol binding using 
                   the "sse" (Server Sent Event) subprotocol.</p>
                <p>
                    <img
                        src="images/message-flows/A_1_3b_observePropertySSE.png"
                        alt="Observe property (HTTP binding with Server Sent Event subprotocol)" />
                </p>
            </section>
            <section>
                <h3>Observe property (HTTP binding with WebSocket subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "observeproperty" operation
                   with an HTTP protocol binding using
                   a WebSocket-based subprotocol.</p>
                <p>
                    <img
                        src="images/message-flows/A_1_3c_observePropertyWebSocket.png"
                        alt="Observe property (HTTP binding with a WebSocket subprotocol)" />
                </p>
            </section>
        </section>
        <section>
            <h2>Action Interactions</h2>
            <section>
                <h3>Invoke action (HTTP binding)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "invokeaction" operation
                   with an HTTP protocol binding, where the
                   operation is synchronous and the response from the server
                   is delayed until after the action completes.</p>
                <p>
                    <img
                        src="images/message-flows/A_2_1_invokeAction.png"
                        alt="Invoke action (HTTP binding)" />
                </p>
                <!-- Note: Actions with asynchronous operation is
                     subject to further study.
                -->
            </section>
        </section>
        <section>
            <h2>Event Interactions</h2>
            <p>In the following, note that
               there is no explicit operation defined for event notification itself.
               The subprotocol used for notification is associated with 
               the "subscribeevent" operation, and any necessary concrete
               protocol transactions are managed by the Protocol Binding subsystem.
            </p>
            <p>There are also several subprotocols possible for event notification
               using WebSockets.
               The interaction diagrams show only one of several possible implementations.
            </p>
            <section>
                <h3>Subscribe, notify and unsubscribe event
                    (HTTP binding with Long Polling subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "subscribeevent" and "unsubscribeevent" operations
                   with an HTTP protocol binding using
                   the Long Polling subprotocol.
                </p>
                <p>
                    <img
                        src="images/message-flows/A_3_1a_eventLongPoll.png"
                        alt="Subscribe, notify, and unsubscribe event (HTTP binding with Long Polling subprotocol)" />
                </p>
            </section>
            <section>
                <h3>Subscribe, notify and unsubscribe event
                    (HTTP binding with Server Sent Event subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "subscribeevent" and "unsubscribeevent" operations
                   with an HTTP protocol binding using
                   the Server Sent Event subprotocol.
                </p>
                <p>
                    <img src="images/message-flows/A_3_1b_eventSSE.png"
                        alt="Subscribe, notify and unsubscribe event (HTTP binding with Server Sent Event subprotocol)" />
                </p>
            </section>
            <section>
                <h3>Subscribe, notify and unsubscribe event
                    (HTTP binding with WebSocket subprotocol)</h3>
                <p>The following sequence illustrates application and network
                   transactions to implement the 
                   "subscribeevent" and "unsubscribeevent" operations
                   with an HTTP protocol binding using
                   a WebSocket subprotocol.
                </p>
                <p>
                    <img
                        src="images/message-flows/A_3_1c_eventWebSocket.png"
                        alt="Subscribe, notify and unsubscribe event (HTTP binding with WebSocket subprotocol)" />
                </p>
            </section>
        </section>
    </section>

    <section class="appendix-acknowledgements">
        <h2>Acknowledgments</h2>
        <p>Special thanks to all active Participants of the W3C Web
            of Things Interest Group and Working Group for their
            technical input and suggestions that led to improvements to
            this document.</p>
    </section>

    <section class="appendix-change-history">
      <h2>Change History</h2>
      <ul>
      <li>Sept 2017: <a href="https://www.w3.org/TR/2017/WD-wot-architecture-20170914/">First Public Working Draft</a>.</li>
      <li>March 2019: Public Working Draft for TAG review.</li>
      </ul>
    </section>

</body>
</html>
