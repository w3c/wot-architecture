<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta charset="utf-8" />
<title>Web of Things (WoT) Architecture</title>
<script class="remove"
    src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
<script class="remove">
        var respecConfig = {
        lint: {
            "check-punctuation": true,
            "local-refs-exist": true,
            "no-http-props": true,
            "no-headingless-sections": true
        },
        doJsonLd : true,
        specStatus : "ED",
        shortName : "wot-architecture",
        copyrightStart : 2017,
        wg : "Web of Things Working Group",
        wgURI : "https://www.w3.org/WoT/WG/",
        wgPatentURI : "https://www.w3.org/2004/01/pp-impl/95969/status",
        wgPublicList : "public-wot-wg",
        github: {
            repoURL: "https://github.com/w3c/wot-architecture",
            branch: "master"
        },
        editors : [ {
            name : "Matthias Kovatsch",
            w3cid : "75998",
            company : "Huawei",
            companyURL : "https://www.huawei.com/"
        }, {
            name : "Ryuichi Matsukura",
            w3cid : "64284",
            company : "Fujitsu Ltd.",
            companyURL : "https://www.fujitsu.com/"
        }, {
            name : "Michael Lagally",
            w3cid : "47166",
            company : "Oracle Corp.",
            companyURL : "https://www.oracle.com/"
        }, {
            name : "Toru Kawaguchi",
            w3cid : "79307",
            company : "Panasonic Corp.",
            companyURL : "https://www.panasonic.com/"
        }, {
            name : "Kunihiko Toumura",
            w3cid : "83488",
            company : "Hitachi, Ltd.",
            companyURL : "https://www.hitachi.com/"
        }, {
            name : "Kazuo Kajimoto",
            note : "Former Editor, when at Panasonic"
        } ],
        otherLinks : [
                {
                    key : "Contributors",
                    data : [ {
                        value : "In the GitHub repository",
                        href : "https://github.com/w3c/wot-architecture/graphs/contributors"
                    } ]
                }],
        localBiblio : {
            "CoRE-RD" : {
                href : "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11",
                title : "CoRE Resource Directory",
                status : "Internet-Draft",
                publisher : "IETF",
                date : "03 July 2017"
            },
/* ReSpec will pick up the citation as it is officially published
            "wot-security" : {
                href : "https://www.w3.org/TR/wot-security/",
                // href: "https://cdn.staticaly.com/gh/w3c/wot-security/master/index.html?env=dev",
                title : "Web of Things (WoT) Security and Privacy Considerations",
                // status: "Editor's Draft (will be W3C NOTE in final version)",
                status: "W3C Note",
                publisher : "W3C"
            },
*/
            "tag-review-wot-thing-description" : {
                href: "https://cdn.staticaly.com/gh/w3c/wot-thing-description/TD-TAG-review/index.html?env=dev",
                title : "Web of Things (WoT) Thing Description",
                status: "Editor's Draft for TAG Review",
                publisher : "W3C"
            },
            "IEC-FOTF" : {
                href : "https://www.iec.ch/whitepaper/pdf/iecWP-futurefactory-LR-en.pdf",
                title : "Factory of the future",
                publisher : "IEC",
                date : "October 2015"
            },
            "iot-schema-org" : {
                href : "https://iot.schema.org/",
                title : "iot.schema.org"
            },
            "REST" : {
                title : "REST: Architectural Styles and the Design of Network-based Software Architectures",
                author : "Roy Thomas Fielding",
                status : "PhD thesis",
                publisher : "University of California, Irvine",
                date : "2000"
            },
            "SAREF" : {
                href : "https://sites.google.com/site/smartappliancesproject/ontologies/reference-ontology",
                title : "Smart Appliances REFerence (SAREF) ontology",
                publisher : "ETSI",
                date : "November 2015"
            },
            "HCI" : {
                title : "The Encyclopedia of Human-Computer Interaction, 2nd Ed",
                author : "Mads Soegaard, Rikke Friis Dam",
                publisher : "Interaction Design Foundation",
                date : "2013"
            },
            "NORMAN" : {
                title : "The Psychology of Everyday Things",
                author : "Donald A. Norman",
                publisher : "Basic Books",
                date : "1988"
            },
            "MQTT" : {
                title : "MQTT Version 3.1.1",
                author : "Andrew Banks, Rahul Gupta",
                publisher : "OASIS Standard",
                date : "2014"
            },
            "OCF" : {
                href : "https://openconnectivity.org/developer/specifications",
                title : "OCF Core Specification",
                publisher : "Open Connectivity Foundation",
                status : "Version 2.0.2",
                date : "April 2019"
            },
            "LWM2M" : {
                href : "http://openmobilealliance.org/release/LightweightM2M/V1_1-20180710-A/OMA-TS-LightweightM2M_Core-V1_1-20180710-A.pdf",
                title : "Lightweight Machine to Machine Technical Specification: Core",
                publisher : "OMA SpecWorks",
                status : "Approved Version: 1.1",
                date : "August 2018"
            },
            "CoRAL" : {
                href : "https://tools.ietf.org/html/draft-hartke-t2trg-coral",
                title : "The Constrained RESTful Application Language (CoRAL)",
                authors : [ "Klaus Hartke" ],
                publisher : "IETF",
                status : "Internet-Draft",
                date : " March 2019"
            },
            "wot-pioneers-1" : {
                title : "Mobile Service Interaction with the Web of Things",
                authors : [ "E. Rukzio, M. Paolucci", "M. Wagner, H. Berndt", "J. Hamard", "A. Schmidt" ],
                publisher : "Proceedings of 13th International Conference on Telecommunications (ICT 2006), Funchal, Madeira island, Portugal",
                date : "May 2006"
            },
            "wot-pioneers-2" : {
                title : "Putting Things to REST",
                authors : [ "Erik Wilde" ],
                publisher : "UCB iSchool Report 2007-015, UC Berkeley, Berkeley, CA, USA",
                date : "November 2007"
            },
            "wot-pioneers-3" : {
                title : "Poster Abstract: Dyser – Towards a Real-Time Search Engine for the Web of Things",
                authors : [ "Benedikt Ostermaier",
                            "B. Maryam Elahi",
                            "Kay Römer",
                            "Michael Fahrmair",
                            "Wolfgang Kellerer" ],
                publisher : "Proceedings of ACM SenSys 2008, Raleigh, NC, USA",
                date : "November 2008"
            },
            "wot-pioneers-4" : {
                title : "A Resource Oriented Architecture for the Web of Things",
                authors : [ "Dominique Guinard", "Vlad Trifa", "Erik Wilde" ],
                publisher : "Proceedings of Internet of Things 2010 International Conference (IoT 2010). Tokyo, Japan",
                date : "November 2010"
            },
            "Y.2070" : {
                title : "ITU-T Rec. Y.2070 (01/2015) Requirements and architecture of the home energy management system and home network services ",
                publisher : "ITU-T",
                status: "Recommendation",
                date : "January 2015"
            }
        }
    };
</script>
<style type="text/css">
a[href].internalDFN {
        color: inherit;
        border-bottom: 1px solid #99c;
        text-decoration: none;
}
img.wot-arch-diagram {
    max-width: 90%;
    height: auto;
}
</style>
</head>
<body>
    <section id="abstract">
        <p>The W3C Web of Things (WoT) was created to enable
            interoperability across IoT platforms and application
            domains.</p>
        <p>WoT provides mechanisms to formally describe IoT
            interfaces to allow IoT devices and services to communicate
            with each other, independent of their underlying
            implementation, and across multiple networking protocols. In
            addition WoT offers a standardized way to define and program
            IoT behavior.</p>

        <p>This <em>WoT Architecture>/em> specification describes the abstract
            architecture for the W3C Web of Things. It is derived from a
            set of requirements that were derived from use cases for
            multiple application domains. The architecture can be mapped
            onto a variety of concrete deployment scenarios, several
            example patterns of which are given.</p>
	    
        <p>This specification is focused on the scope of W3C WoT standardization,
	    which is broken down into so-called building blocks.
	    It introduces the four intial WoT building blocks,
            which are defined and described in detail in separate specifications,
	    and explains their interworking:</p>
        <p>
            The <em>WoT Thing Description</em> is the central building
            block, as it allows to describe the metadata and network-facing
	    interfaces of Things.
        </p>
        <p>
            The informational <em>WoT Binding Templates</em> provide
	    guidelines on how to define so-called Protocol Bindings
	    for the description of these network-facing interfaces
	    and provides examples for a number of existing IoT
	    ecosystems and standards.
        </p>
        <p>
            The optional <em>WoT Scripting API</em> enables the implementation of
            the application logic of a Thing using a common JavaScript API
	    similar to the Web browser APIs. This simplifies IoT application
            development and enables portability across vendors and devices.
        </p>
	<p>
	    The <em>WoT Security and Privacy Considerations</em> represent a
	    cross-cutting building block, which should be applied to any system
	    implementing W3C WoT. It focuses on the secure implementation and
	    configuration of Things.
	</p>
	
        <p>
	    This specification also covers non-normative architectural aspects
	    and conditions for the deployment of WoT systems.
            These guidelines are described in the context of deployment scenarios.
        </p>
        <p>
	    Overall, the goal is to preserve and complement existing
            IoT standards and solutions. In general, W3C WoT is
            designed to describe what exists rather than to prescribe
            what to implement.
	</p>

    </section>
    <section id="sotd">
        <p class="ednote" title="The W3C WoT WG is asking for feedback">
            Please contribute to this draft using the <a
                href="https://github.com/w3c/wot-architecture/issues">GitHub
                Issue</a> feature of the <a
                href="https://github.com/w3c/wot-architecture/">WoT
                Architecture</a> repository. For feedback on security and
            privacy considerations, please use the <a
                href="https://github.com/w3c/wot-security/issues">WoT
                Security and Privacy Considerations</a> repository to file issues, 
               as they are cross-cutting over all our specifications.
        </p>
    </section>
    <section id="introduction">
        <h1>Introduction</h1>
        <p>
	    The goals of the <em>Web of Things</em> (WoT) are to improve the interoperability
            and usability of the Internet of Things (IoT). Through a collaboration
            involving many stakeholders over the past years, several building
            blocks have been identified that address these challenges.
            The first set of WoT building blocks is now defined:
        </p>
        <ul>
            <li>the <em>Web of Things (WoT)
                    Thing Description</em> [[wot-thing-description]],
            </li>
            <li>the <em>Web of Things (WoT)
                    Binding Templates</em> [[?wot-binding-templates]],
            </li>
            <li>the <em>Web of Things (WoT)
                    Scripting API</em> [[?wot-scripting-api]], and
            </li>
            <li>the <em>Web of Things (WoT)
                    Security and Privacy Considerations</em> [[?wot-security]].
            </li>
        </ul>

        <p>This specification serves as an umbrella for W3C WoT
            specifications and defines the basics such as terminology
            and the underlying abstract architecture of the W3C Web of
            Things. In particular, the purpose of this specification is to
            provide:</p>
        <ul>
            <li>a set of use cases in <a href="#sec-use-cases"></a>
                that lead to the W3C WoT Architecture,
            </li>
            <li>a set of requirements for WoT implementations in
                <a href="#sec-requirements"></a>,
            </li>
            <li>a definition of the abstract architecture in
                <a href="#sec-wot-architecture"></a>
            </li>
            <li>an overview of the available WoT building blocks
                and their interplay in <a href="#sec-building-blocks"></a>,
            </li>
            <li>a guideline to map the abstract architecture to
                software stacks and hardware components in
                <a href="#sec-servient-implementation"></a>,
            </li>
            <li>deployment scenarios in <a
                href="#sec-deployment-scenario"></a>,
            </li>
            <li>and security considerations to be aware of when
                implementing the W3C WoT architecture in
		<a href="#sec-security-considerations"></a>.
            </li>
        </ul>
    </section>
    <section id="conformance"></section>
    <section id="terminology">
        <h1>Terminology</h1>
        <p>
            <em>This section is normative.</em>
        </p>

        <p>This specification uses the following terms as defined here.
            The WoT prefix is used to avoid ambiguity for terms that are
            (re)defined specifically for Web of Things concepts.</p>
        <dl>
            <dt>
                <dfn>Action</dfn>
            </dt>
            <dd>An Interaction Affordance that allows to invoke a
                function of the Thing, which manipulates state
                (e.g., toggling a lamp on or off)
                or triggers a process on the Thing (e.g., dimm a lamp over time).</dd>
            <dt>
                <dfn data-lt="WoT Binding Templates">Binding
                    Templates</dfn>
            </dt>
            <dd>A re-usable collection of blueprints for the
                communication with different IoT platforms. The
                blueprints includes the required vocabulary for the
                WoT Thing Description to map Interactions to
                platform-specific messages as well as implementation
                notes for the required protocol stacks or dedicated
                communication drivers.</dd>
            <dt>
                <dfn>to consume a Thing</dfn>
            </dt>
            <dd>To process a WoT Thing Description and from it create a Consumed
                Thing software abstraction as interface for the application in the local
                runtime environment.</dd>
            <dt>
                <dfn>Consumed Thing</dfn>
            </dt>
            <dd>A software abstraction that represents a remote
                Thing used by the local application. The abstraction might be
                created by a native WoT Runtime, or instantiated
                as an object through the WoT Scripting API.</dd>
            <dt>
                <dfn>Consumer</dfn>
            </dt>
            <dd>An entity that can process the WoT Thing Description format
                and interact with Things (i.e., consume Things).</dd>
            <dt>
                <dfn>Digital Twin</dfn>
            </dt>
            <dd>A digital twin is a virtual representation of a
                device or a group of devices that resides on a cloud
                or edge node. It can be used to represent
                real-world devices which may not be continuously online,
                or to run simulations of new applications and services,
                before they get deployed to the real devices.</dd>
            <dt>
                <dfn>Domain-specific vocabulary</dfn>
            </dt>
            <dd>Linked Data vocabulary that can be used in the WoT
                Thing Description, but is not defined by W3C WoT.</dd>
            <dt>
                <dfn>Edge device</dfn>
            </dt>
            <dd>a device which provides an entry point into
                enterprise or service provider core networks. Examples
                include gateways, routers, switches, multiplexers, and a
                variety of other access devices.</dd>
            <dt>
                <dfn>Event</dfn>
            </dt>
            <dd>An Interaction Affordance that describes an event source,
                which asynchronously pushes event data to Consumers
                (e.g., overheating alerts).</dd>
           <dt>
                <dfn>to expose a Thing</dfn>
            </dt>
            <dd>To create an Exposed Thing software abstraction in the
                local runtime environment to manage the state of a Thing
                and interface with the behavior implementation.</dd>
            <dt>
                <dfn>Exposed Thing</dfn>
            </dt>
            <dd>A software abstraction that represents a locally hosted Thing
                that can be accessed over the network by remote Consumers.
                The abstraction might be created by a native WoT Runtime,
                or instantiated as an object through the WoT Scripting API.</dd>
            <dt>
                <dfn>Hypermedia Control</dfn>
            </dt>
            <dd>A serialization of a Protocol Binding in hypermedia, that is,
                either a Web link [[!RFC8288]] for navigation or a Web form for
                performing other operations. Forms can be seen as request templates
                provided by the Thing to be completeted and sent by the Consumer.</dd>
            <dt>
                <dfn>Interaction Affordance</dfn>
            </dt>
            <dd>
                Metadata of a Thing that shows and describes the possible choices to Consumers,
                thereby suggesting how Consumers may interact with the Thing.
                There are many types of potential affordances, but
                W3C WoT defines three types of Interaction Affordances:
                Properties, Actions, and Events.
                A fourth Interaction Affordance is navigation, which is already available on the Web through linking.</dd>
            <dt>
                <dfn>Interaction Model</dfn>
            </dt>
            <dd>An intermediate abstraction that formalizes and narrows the
                mapping from application intent to concrete protocol operations.
                In W3C WoT, the defined set of Interaction Affordances constitutes the Interaction Model.</dd>
            <dt>
                <dfn>Intermediary</dfn>
            </dt>
            <dd>An entity between Consumers and Things that can proxy, augment, or compose Things
                and republish a WoT Thing Description that points to the WoT Interface on the Intermediary instead of the original Thing.
                For Consumers, an Intermediary may be indistinguishable from a Thing, following the Layered System constraint of REST.</dd>
            <dt>
                <dfn>IoT platform</dfn>
            </dt>
            <dd>A specific IoT ecosystem such as OCF, oneM2M, or
                Mozilla Project Things with its own specifications for
                application-facing APIs, data model, and protocols or
                protocol configurations.</dd>
            <dt>
                <dfn data-lt="Personally Identifiable Information">Personally Identifiable Information (PII)</dfn>
            </dt>
            <dd>Information that can be associated with a
                unique individual.</dd>
            <dt>
                <dfn>Privacy</dfn>
            </dt>
            <dd>The system should maintain the
                confidentiality of <a>Personally Identifiable Information</a>.</dd>
            <dt>
                <dfn>Property</dfn>
            </dt>
            <dd>An Interaction Affordance that exposes state of the Thing.
                This state can then be retrieved (read) and optionally updated (write).
                Things can also choose to make Properties observable by pushing the new
                state after a change.</dd>
            <dt>
                <dfn data-lt="WoT Protocol Binding">Protocol Binding</dfn>
            </dt>
            <dd>The mapping from an Interaction Affordance to concrete messages of a specific protocol,
                thereby informing Consumers how to activate the Interaction Affordance.
                W3C WoT serializes Protocol Bindings as hypermedia controls.</dd>
            <dt>
                <dfn>Security</dfn>
            </dt>
            <dd>The system should preserve its integrity
                and functionality even when subject to attack.</dd>
            <dt>
                <dfn>Servient</dfn>
            </dt>
            <dd>A software stack that implements the WoT building
                blocks. A Servient can host and expose Things and/or host Consumers that consume Things.
                Servients can support multiple Protocol Bindings to enable
                interaction with different IoT platforms.</dd>
            <dt>
                <dfn>Subprotocol</dfn>
            </dt>
            <dd>An extension mechanism to a transfer protocol that
                must be known to interact successfully.
                An example is long polling for HTTP.</dd>
            <dt>
                <dfn>TD</dfn>
            </dt>
            <dd>Short for WoT Thing Description.</dd>
            <dt>
                <dfn>TD Vocabulary</dfn>
            </dt>
            <dd>A controlled Linked Data vocabulary by W3C WoT to
                tag the metadata of Things in the WoT Thing Description
                including communication metadata of WoT Binding
                Templates.</dd>
            <dt>
                <dfn>Thing</dfn> or <dfn>Web Thing</dfn>
            </dt>
            <dd>An abstraction of a physical or a virtual entity
                whose metadata and interfaces are described by a WoT
                Thing Description, whereas a virtual entity is the
                composition of one or more Things.</dd>
            <dt>
                <dfn>Thing Directory</dfn>
            </dt>
            <dd>A directory service for TDs that provides a Web
                interface to register TDs (similar to [[?CoRE-RD]]) and look them up
                (e.g., using SPARQL queries or the CoRE RD lookup interface [[?CoRE-RD]]).</dd>
            <dt>
                <dfn>Transfer Protocol</dfn>
            </dt>
            <dd>The underlying, standardized application layer
                protocol without application-specific requirements or
                constraints on options or subprotocol mechanisms.
                Examples are HTTP, CoAP, or MQTT.</dd>
            <dt>
                <dfn>Virtual Thing</dfn>
            </dt>
            <dd>An instance of a Thing that represents a Thing that is located
                on another system component.</dd>
            <dt>
                <dfn>WoT Interface</dfn>
            </dt>
            <dd>The network-facing interface of a Thing
                that is described by a WoT Thing Description.</dd>
            <dt>
                <dfn>WoT Runtime</dfn>
            </dt>
            <dd>A runtime system that maintains an execution
                environment for applications, and is able to expose and/or
                consume Things, to process WoT Thing Descriptions, to maintain private security
                metadata, and to interface with Protocol Binding implementations.
                A WoT Runtime may have a custom API or use the optional WoT Scripting API.</dd>
            <dt>
                <dfn>WoT Scripting API</dfn>
            </dt>
            <dd>The application-facing programming interface
                provided by a Servient in order to to ease
                the implementation of behavior or applications running in a WoT
                Runtime. It is comparable to the Web browser APIs.
                The WoT Scripting API is an optional building block for W3C WoT.</dd>
            <dt>
                <dfn>WoT Servient</dfn>
            </dt>
            <dd>Synonym for Servient.</dd>
            <dt>
                <dfn>WoT Thing Description</dfn> or <dfn>Thing Description</dfn>
            </dt>
            <dd>Structured data describing a Thing. A WoT Thing Description comprises
                general metadata, domain-specific metadata, Interaction Affordances
                (which include the supported Protocol Bindings), and links to related Things.
                The WoT Thing Description format is the central building block of W3C WoT.</dd>
        </dl>
    </section>

    <section id="sec-use-cases" class="informative">
        <h1>Use Cases</h1>

        <p>
            This section presents the application domains and use cases
            targeted by the W3C WoT and which are used to derive the
            abstract architecture discussed in <a
                href="#sec-building-blocks"></a>.
        </p>
        <p>The Web of Things architecture does not put any
            limitations on use cases and application domains. Various
            application domains have been considered to collect common
            patterns that have to be satisfied by the abstract
            architecture.</p>
        <p>The following sections are not exhaustive. Rather they
            serve as illustrations, where connected things can provide
            additional benefit or enable new scenarios.</p>
        <section id="sec-application-domains">
            <h2>Application Domains</h2>
            <section id="consumer-use-cases">
                <h3>Consumer</h3>
                <p>In the consumer space there are multiple assets
                    that benefit from being connected. Lights and air
                    conditioners can be turned off based on room
                    occupancy. Window blinds can be closed automatically
                    based on weather conditions and presence. Energy and
                    other resource consumption can be optimized based on
                    usage patterns and predictions.</p>
                <p>The consumer use cases in this section includes
                    Smart Home use case.</p>
                <p>
                    <a href="#smart-home"></a> shows an example of a
                    Smart Home. In this case, gateways are connected to
                    edge devices such as sensors, cameras and home
                    appliances through corresponding local communication
                    protocols such as KNX, ECHONET, ZigBee, DECT ULE and
                    Wi-SUN. Multiple gateways can exist in one home,
                    while each gateway can support multiple local
                    protocols.
                </p>
                <p>Gateways can be connected to the cloud through
                    the internet, while some appliances can be connected
                    to the cloud directly. Services running in the cloud
                    collect data from edge devices and analyze the data,
                    then provide value to users through the edge devices
                    and other UX devices.</p>
                <figure id="smart-home">
                    <img src="images/wot-use-cases/smart-home.png"
                        class="wot-arch-diagram"/>
                    <figcaption>Smart Home</figcaption>
                </figure>
                <p>Smart home provides consumer benefits such as
                    remote access and control, voice control and home
                    automation. Smart home also enables device
                    manufacturers to monitor and maintain devices
                    remotely. Smart home can realizes added value
                    services such as energy management and security
                    surveillance.</p>
            </section>
            <section id="industrial-iot-usecases">
                <h3>Industrial</h3>
                <p>
                    The industrial use cases in this section are
                    applicable to different industry verticals. <br />
                    Due to the nature of overlaps in the application
                    scenarios, different verticals have similar use
                    cases.
                </p>
                <section>
                    <h4>Example: Smart Factory</h4>
                    <p>
                        <a href="#smart-factory"></a> shows an example
                        of a Smart Factory. In this case, field-level,
                        cell and line controllers automate different
                        factory equipment based on industrial
                        communication protocols such as Profinet,
                        Modbus, OPC UA TSN, EtherCAT, or CAN. An
                        industrial edge device collects selected data
                        from various controllers and makes it available
                        to a cloud backend service, e.g. for remote
                        monitoring via a dashboard or analyzes it for
                        preventive maintenance.
                    </p>
                    <figure id="smart-factory">
                        <img
                            src="images/wot-use-cases/smart_factory_new.png"
                            class="wot-arch-diagram" />
                        <figcaption>Smart Factory</figcaption>
                    </figure>
                </section>
                <p>Smart factories require advanced monitoring of
                    the connected manufacturing equipment as well of the
                    manufactured products. They benefit from predictions
                    of machine failures and early discovery of anomalies
                    to prevent costly downtime and maintenance efforts.</p>
                <p>Additionally, monitoring of connected
                    manufacturing equipment and the environment at the
                    production facility for the presence of poisonous
                    gases, excessive noise or heat increases the safety
                    of the workers and reduces the risks of incidents or
                    accidents.</p>
                <p>Real-time monitoring and KPI calculations of
                    production equipment helps to detect productivity
                    problems and optimize the supply chain.</p>
            </section>
            <section id="sec-transportationlogistics">
                <h4 id="transportationlogistics">Transportation
                    &amp; Logistics</h4>
                <p>Monitoring of vehicles, fuel costs, maintenance
                    needs and assignments helps to optimize the full
                    utilization of the vehicle fleet.</p>
                <p>Shipments can be tracked to be en-route to ensure
                    consistent quality and condition of the transported
                    goods. This is especially useful to assert the
                    integrity of the cold-chain from warehouses to
                    refrigerated trucks to delivery.</p>
                <p>Centralized monitoring and management of stock in
                    warehouses and yards can prevent out of stock and
                    excessive stock situations.</p>
            </section>
            <section id="sec-utilities">
                <h4 id="utilities">Utilities</h4>
                <p>Automated reading of residential and C&amp;I
                    (Commercial and Industrial) meters, and billing
                    offers continuous insights into resource consumption
                    and potential bottlenecks.</p>
                <p>Monitoring the condition and output of
                    distributed renewable energy generation equipment
                    enables optimization of distributed energy
                    resources.</p>
                <p>Monitoring and remote-controlling of distribution
                    equipment helps to automate the distribution
                    process.</p>
                <p>Continuous monitoring of generation and
                    distribution infrastructure is improving safety of
                    utilities crew in the field.</p>
            </section>
            <section id="sec-oilandgas">
                <h4 id="oilandgas">Oil and Gas</h4>
                <p>Offshore platform monitoring, leakage detection
                    and prediction of pipelines as well as monitoring
                    and controlling the levels in tanks and reservoirs
                    helps to improve the industrial safety for the
                    workforce as well as for the environment.</p>
                <p>Automated calculation of a distributed stock
                    through various storage tanks and delivery
                    pipes/trucks allows for improved planning and
                    resource optimization.</p>
            </section>
            <section id="sec-insurance">
                <h4 id="insurance">Insurance</h4>
                <p>Proactive Asset Monitoring of high value assets
                    such as connected structures, fleet vehicles, etc.
                    mitigates the risk of severe damage and high costs
                    due to predictions and early detection of incidents.</p>
                <p>Usage based insurance can be offered with usage
                    tracking and customized insurance policies.</p>
                <p>Predictive weather monitoring and re-routing
                    fleet vehicles to covered garages can limit loss due
                    to hail damage, tree damage.</p>
            </section>
            <section id="sec-engineering-and-construction">
                <h4 id="engineering-and-construction">Engineering
                    and Construction</h4>
                <p>Monitoring for industrial safety reduces the
                    risks of security hazards. Monitoring of assets at
                    construction site can prevent damage and loss.</p>
            </section>

            <section id="sec-agriculture">
                <h3 id="agriculture">Agriculture</h3>
                <p>Soil condition monitoring and creating optimal
                    plans for watering, fertilizing as well as
                    monitoring the produce conditions optimize the
                    quality and output of agricultural produce.</p>
            </section>
            <section id="sec-healthcare">
                <h3 id="healthcare">Healthcare</h3>
                <p>Data collection and analytics of clinical trial
                    data helps to gain insights into new areas.</p>
                <p>Remote patient monitoring mitigates the risk of
                    undetected critical situations for elderly people
                    and patients after hospitalization.</p>
            </section>
            <section id="sec-environmentmonitoring">
                <h3 id="environmentmonitoring">Environment
                    Monitoring</h3>
                <p>Environment monitoring typically relies on a lot
                    of distributed sensors that send their measurement
                    data to common gateways, edge devices and cloud
                    services.</p>
                <p>Monitoring of air pollution, water pollution and
                    other environmental risk factors such as fine dust,
                    ozone, volatile organic compound, radioactivity,
                    temperature, humidity to detect critical environment
                    conditions can prevent unrecoverable health or
                    environment damages.</p>
            </section>
            <section id="sec-smart-cities">
                <h3 id="smartcities">Smart Cities</h3>
                <p>Monitoring of Bridges, Dams, Levees, Canals for
                    material condition, deterioration, vibrations
                    discovers maintenance repair work and prevents
                    significant damage. Monitoring of highways and
                    providing appropriate signage ensures optimized
                    traffic flow.</p>
                <p>Smart Parking is optimizing and tracking the
                    usage and availability of parking spaces and
                    automates billing/reservations.</p>
                <p>Smart control of street lights based on presence
                    detection, weather predictions, etc reduced cost.</p>
                <p>Garbage containers can be monitored to optimize
                    the waste management and the trash collection route.</p>
            </section>
            <section id="sec-smart-buildings">
                <h3 id="smartbuildings">Smart Buildings</h3>
                <p>Monitoring the energy usage throughout the
                    building helps to optimize resource consumption and
                    reduce waste.</p>
                <p>Monitoring the equipment in the buildings such as
                    HVAC, Elevators, etc. and fixing problems early
                    improves the satisfaction of occupants.</p>
            </section>
            <section id="sec-connected-car">
                <h3 id="connectedcar">Connected Car</h3>
                <p>Monitoring of operation status, prediction of
                    service needs optimizes maintenance needs and costs.
                    Driver safety is enhanced with notifications of an
                    early warning system for critical road and traffic
                    conditions.</p>
                <section id="connected car example">
                    <h4 id="connectedcar-example">Connected Car
                        Example</h4>
                    <p>
                        <a href="#connected-car"></a> shows an example
                        of a Connected Car. In this case, a gateway
                        connects to car components through CAN and to
                        the car navigation system through a proprietary
                        interface. Services running in the cloud collect
                        data pushed from car components and analyze the
                        data from multiple cars to determine traffic
                        patterns. The gateway can also consume cloud
                        services, in this case, to get traffic data and
                        show it to the driver through the car navigation
                        system.
                    </p>
                    <figure id="connected-car">
                        <img
                            src="images/wot-use-cases/connected-car.png"
                            class="wot-arch-diagram" />
                        <figcaption>Connected Car</figcaption>
                    </figure>
                </section>
                <p>Monitoring of operation status, prediction of
                    service needs optimizes maintenance needs and costs.
                    Driver safety is enhanced with notifications of an
                    early warning system for critical road and traffic
                    conditions.</p>
            </section>
        </section>



        <section id="sec-common-usecase-patterns">
            <h1>Common Patterns</h1>
            <p>
            This section introduces common use case patterns that
            illustrate how devices/things interact with controllers,
            other devices, agents and servers.
            In this section, we use the term 'client roles' as an
            initiator of a transport protocol, and the term 'server roles'
            as a passive component of a transport protocol.
            </p>

            <section id="device-controllers">
                <h3>Device Controllers</h3>
                <p>
                    The first use case is a local device controlled by a
                    user-operated remote controller as depicted in <a
                        href="#smart-home-device"></a>. A remote
                    controller can access an electronic appliance
                    through the local home network directly. In this
                    case, the remote controller can be implemented by a
                    browser or native application.
                </p>
                <p>In this pattern, at least one device like the
                    electronic appliance has a server role that can
                    accept a request from the other devices and responds
                    to them, and sometimes initiates a mechanical
                    action. The other device like the remote controller
                    has a client role that can send a message with a
                    requests, like to read a sensor value or to turn on
                    the device.
                    Moreover, to emit a current state or event notification of a device,
                    the device may have a client role that can send a message
                    to another device, which has server roles.
                </p>
                <figure id="smart-home-device">
                    <img
                        src="images/wot-use-cases/smart-home-device.png"
                        class="wot-arch-diagram" />
                    <figcaption>Device Control</figcaption>
                </figure>
            </section>
            <section>
                <h3>Thing-to-Thing</h3>
                <p>
                    <a href="#smart-home-t2t"></a> shows an example of a
                    direct Thing-to-Thing interaction. The scenario is
                    as follows: a sensor detects a change of the room
                    condition, for example the temperature exceeding a
                    threshold, and issues a control message like "turn
                    on" to the electronic appliance. The sensor unit can
                    issue some trigger messages to other devices.
                </p>
                <p>In this case, when two devices that have server
                    roles are connected, at least one device must have
                    also a client role that issues a message to the
                    other to actuate or notify.</p>
                <figure id="smart-home-t2t">
                    <img src="images/wot-use-cases/smart-home-t2t.png"
                         class="wot-arch-diagram" />
                    <figcaption>Control Agent</figcaption>
                </figure>
            </section>
            <section>
                <h3>Remote Access</h3>
                <p>
                    This use case contains a mobile remote controller
                    (e.g., on a smartphone) as shown in <a
                        href="#smart-home-multi"></a>. The remote
                    controller can switch between different network
                    connections and protocols, e.g. between a cellular
                    network and a home network, which is using protocols
                    such as Wi-Fi and Bluetooth. When the controller is
                    in the home network it is a trusted device and no
                    additional security or access control is required.
                    When it is outside of the trusted network,
                    additional access control and security mechanisms
                    must be applied to ensure a trusted relationship.
                    Note that in this scenario the network connectivity
                    may change due to switching between different
                    network access points or cellular base stations.
                </p>
                <p>
                    In this pattern, the remote controller and the
                    electronic appliance have a client and a server role
                    as in the related scenario in <a
                        href="#smart-home-device"></a>.
                </p>
                <figure id="smart-home-multi">
                    <img src="images/wot-use-cases/smart-home-multi.png"
                         class="wot-arch-diagram" />
                    <figcaption>Multiple Network Interfaces</figcaption>
                </figure>
            </section>
            <section>
                <h3>Smart Home Gateways</h3>
                <p>
                    <a href="#smart-home-gateway"></a> shows a use case
                    using a Smart Home gateway. The smart home gateway
                    is placed between a home network and the Internet.
                    The gateway manages electronic appliances inside the
                    house and can receive commands from a remote
                    controller over the Internet, e.g., from a
                    smartphone as in the previous use case. It is also
                    is a virtual representation of a device. The smart
                    home gateway typically offers proxy and firewall
                    functionality.
                </p>
                <p>In this pattern, the home gateway has both a
                    client and a server role. When the remote controller actuates the electronic appliance,
                    it can connect to the
                    electronic appliance in the client role and to the
                    remote controller with the server role.
                    When the electronic appliance emits a message to the
                    remote controller, the gateway act as server roles
                    for the electric appliance, and it act as client roles
                    for the remote controller.
                 </p>
                <figure id="smart-home-gateway">
                    <img
                        src="images/wot-use-cases/smart-home-gateway.png"
                        class="wot-arch-diagram" />
                    <figcaption>Smart Home Gateway</figcaption>
                </figure>
            </section>
            <section>
                <h3>Edge Devices</h3>
                <p>
                    An Edge Device or Edge Gateway is similar to a Smart
                    Home gateway. We use the term to indicate additional
                    tasks that are carried out by the edge gateway.
                    Whereas the home gateway in <a
                        href="#edge-device"></a> primarily just
                    bridges between the public and the trusted network,
                    the edge device has local compute capabilities and
                    typically bridges between different protocols. Edge
                    devices are typically used in industrial solutions,
                    where they can provide preprocessing, filtering and
                    aggregation of data provided by connected devices
                    and sensors.
                </p>
                <figure id="edge-device">
                    <img src="images/wot-use-cases/edge-device.png"
                         class="wot-arch-diagram" />
                    <figcaption>Edge device</figcaption>
                </figure>
            </section>
            <section>
                <h3>Digital Twins</h3>
                <p>A digital twin is a virtual representation, i.e.
                    a model of a device or a group of devices that
                    resides on a cloud server or edge device. It can be
                    used to represent real-world devices which may not
                    be continuously online, or to run simulations of new
                    applications and services, before they get deployed
                    to the real devices.</p>
                <figure id="digital-twin">
                    <img src="images/wot-use-cases/digital-twin.png"
                         class="wot-arch-diagram" />
                    <figcaption>Digital Twin</figcaption>
                </figure>
                <p>Digital twins can model a single device, or they
                    can aggregate multiple devices in a virtual
                    representation of the combined devices.</p>
                <figure id="digital-twin-multiple-devices">
                    <img
                        src="images/wot-use-cases/digital-twin-multiple-devices.png"
                        class="wot-arch-diagram" />
                    <figcaption>Digital Twin for Multiple
                        Devices</figcaption>
                </figure>

                <p>Digital twins can be realized in different ways,
                    depending on whether a device is already connected
                    to the cloud, or whether it is connected to a
                    gateway, which itself is connected to the cloud.</p>
                <section>
                    <h4>Cloud-ready Devices</h4>
                    <p>
                        <a href="#smart-home-cloud1"></a> shows an
                        example where electronic appliances are
                        connected directly to the cloud. The cloud
                        mirrors the appliances and, acting as a digital
                        twin, can receive commands from remote
                        controllers (e.g., a smartphone). Authorized
                        controllers can be located anywhere, as the
                        digital twin is globally reachable.

                    </p>
                    <figure id="smart-home-cloud1">
                        <img
                            src="images/wot-use-cases/smart-home-cloud1a.png"
                            class="wot-arch-diagram" />
                        <figcaption>Appliance twin for a
                            Cloud-ready Devices</figcaption>
                    </figure>
                </section>
                <section>
                    <h3>Legacy Devices</h3>
                    <p>
                        <a href="#smart-home-cloud2"></a> shows an
                        example where legacy electronic appliances
                        cannot directly connect to the cloud. Here, a
                        gateway is needed to relay the connection. The
                        gateway works as:
                    </p>
                    <ul>
                        <li>integrator of a variety of legacy
                            communication protocols both in the physical
                            and logical view</li>
                        <li>firewall toward the Internet</li>
                        <li>privacy filter which substitutes real
                            image and/or speech, and logs data locally</li>
                        <li>local agent in case the network
                            connection is interrupted</li>
                        <li>emergency services running locally when
                            fire alarms and similar events occur</li>
                    </ul>
                    <p>The cloud mirrors the gateway with all
                        connected appliances and acts as a digital twin
                        that manages them in the cloud in conjunction
                        with the gateway. Furthermore, the cloud can
                        receive commands from remote controllers (e.g.,
                        a smartphone), which can be located anywhere.</p>
                    <figure id="smart-home-cloud2">
                        <img
                            src="images/wot-use-cases/smart-home-cloud2.png"
                            class="wot-arch-diagram" />
                        <figcaption>A Digital Twin for a
                            Legacy Device</figcaption>
                    </figure>
                </section>
            </section>
            <section>
                <h3>Multi-Cloud</h3>
                <p>Typical IoT deployments consist of multiple
                    (thousands) of devices. Without a standardized
                    mechanism, the management of firmware updates for
                    specific clouds require a lot of effort and hinders
                    wider scale IoT adoption.</p>
                <p>The primary benefit of a standardized mechanism
                    for describing devices and device types is the
                    capability of deploying devices to different cloud
                    environments without the need of doing customization
                    at device software / firmware level, i.e. installing
                    cloud specific code to a device. This implies that
                    the solution is flexible enough to describe devices
                    in a way that allows on-boarding and using devices
                    in multiple IoT cloud environments.</p>
                <p>This drives adoption of Web of Things devices,
                    since it enables easy usage of new devices in an
                    existing deployment, as well as migration of
                    existing devices from one cloud to the other.</p>
            </section>

            <section>
                <h3>Cross-domain Collaboration</h3>
                <p>
                    <a href="#cross-domain"></a> show an example of a
                    cross-domain collaboration. In this case, each
                    system involves other systems in other domains, such
                    as Smart Factory with Smart City, Smart City with
                    Smart Home. This type of system is called
                    "Symbiotic" ecosystem, as shown in [[IEC-FOTF]].
                    There are two collaboration models: direct
                    collaboration and indirect collaboration. In the
                    direct collaboration model, systems exchange
                    information directly with each other in a
                    peer-to-peer manner. In the indirect collaboration,
                    systems exchange information via some collaboration
                    platform. In order to maintain and continue this
                    collaboration, each system provides the metadata of
                    their capabilities and interfaces and adapts itself
                    to others.
                </p>
                <figure id="cross-domain">
                    <img src="images/wot-use-cases/cross-domain-direct.png"
                        class="wot-arch-diagram" />
                    <img src="images/wot-use-cases/cross-domain-indirect.png"
                        class="wot-arch-diagram" />
                    <figcaption>Cross-domain collaboration</figcaption>
                </figure>
            </section>
        </section>
        <section id="sec-use-case-summary">
            <h2>Summary</h2>
            <p>
                The previous section described various architecture
                patterns. In these patterns, some functional entities
                such as the devices including the legacy devices,
                controllers, gateways and cloud servers are located at
                physical locations such as inside building, outside
                buildings, and data centers. <a href="#usecase-overview"></a>
                is an overview that shows the combinations and
                communication paths of these entities.
            </p>
            <p>
                In a transport protocol layer, each entity arbitrarily
                selects a suitable role for communications.  For example,
                a device may act as a server when the device provides a service
                to indefinite number of applications.  On the other hand,
                if a device has limited or intermittent network connectivity,
                they may act as a client and actively send message to an application
                when network is available.  Regardless of this,
                in application layer, an application sees that a device provides abstract
                interfaces to interact and the application can interact with the device
                using their abstract interfaces.
            </p>
            <figure id="usecase-overview">
                <img src="images/wot-use-cases/use-case-summary.png"
                     class="wot-arch-diagram" />
                <figcaption>Use Case Overview</figcaption>
            </figure>
        </section>
    </section>
    <section id="sec-requirements" class="normative">
        <h1>Requirements</h1>
        <p>
            <em>This section is normative.</em>
        </p>

        <section id="sec-functional-requirement">
            <h2>Functional Requirements</h2>
            <p>This section defines the properties required in an
                abstract Web of Things (WoT) architecture.</p>
            <section id="sec-requirements-principles">
                <h3>Common Principles</h3>
                <ul>
                    <li>WoT architecture should enable mutual
                        interworking of different eco-systems using web
                        technology.</li>
                    <li>WoT architecture should be based on the web
                        architecture using RESTful APIs.</li>
                    <li>WoT architecture should allow to use
                        multiple payload formats which are commonly used
                        in the web.</li>
                    <li>WoT architecture must enable different device
                        architectures and must not force a client or server
                        implementation of system components.</li>
                    <li>Flexibility
                        <p>There are a wide variety of physical
                            device configurations for WoT
                            implementations. The WoT abstract
                            architecture should be able to be mapped to
                            and cover all of the variations.</p>
                    </li>
                    <li>Compatibility
                        <p>There are already many existing IoT
                            solutions and ongoing IoT standardization
                            activities in many business fields. The WoT
                            should provide a bridge between these
                            existing and developing IoT solutions and
                            Web technology based on WoT concepts. The
                            WoT should be upwards compatible with
                            existing IoT solutions and current
                            standards.</p>
                    </li>
                    <li>Scalability
                        <p>WoT must be able to scale for IoT
                            solutions that incorporate thousands to
                            millions of devices. These devices may offer
                            the same capabilities even though they are
                            created by different manufacturers.</p>
                    </li>
                    <li>Interoperability
                        <p>WoT must provide interoperability across
                            device and cloud manufacturers. It must be
                            possible to take a WoT enabled device and
                            connect it with a cloud service from
                            different manufacturers out of the box.</p>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-thing-functionalities">
                <h3>Thing functionalities</h3>
                <ul>
                    <li>WoT architecture should allow things to
                        have functionalities such as
                        <ul>
                            <li>reading thing's status information</li>
                            <li>updating thing's status information
                                which might cause actuation</li>
                            <li>subscribing to, receiving and
                                unsubscribing to notifications of
                                changes of the thing's status
                                information.</li>
                            <li>invoking functions with input and
                                output parameters which would cause
                                certain actuation or calculation.</li>
                            <li>subscribing to, receiving and
                                unsubscribing to event notifications
                                that are more general than just reports
                                of state transitions.
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-search-and-discovery">
                <h3>Search and discovery</h3>
                <ul>
                    <li>WoT architecture should allow clients to
                        know thing's attributes, functionalities and
                        their access points, prior to access to the
                        thing itself.</li>
                    <li>WoT architecture should allow clients to
                        search things by its attributes and
                        functionalities.</li>
                    <li>WoT architecture should allow semantic
                        search of things providing required
                        functionalities based on a unified vocabulary,
                        regardless of naming of the functionalities.</li>
                </ul>
            </section>
            <section id="sec-requirements-description-mechanism">
                <h3>Description mechanism</h3>
                <ul>
                    <li>WoT architecture should support a common
                        description mechanism which enables describing
                        things and their functions.</li>
                    <li>Such descriptions should be not only
                        human-readable, but also machine-readable.</li>
                    <li>Such descriptions should allow semantic
                        annotation of its structure and described
                        contents.</li>
                    <li>Such description should be able to be
                        exchanged using multiple formats which are
                        commonly used in the web.</li>
                </ul>
            </section>
            <section id="sec-requirements-description-of-attributes">
                <h3>Description of attributes</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        thing's attributes such as
                        <ul>
                            <li>name</li>
                            <li>explanation</li>
                            <li>version of spec, format and
                                description itself</li>
                            <li>links to other related things and
                                metadata information</li>
                        </ul>
                    </li>
                    <li>Such descriptions should support
                        internationalization.</li>
                </ul>
            </section>
            <section
                id="sec-requirements-description-of-functionalities">
                <h3>Description of functionalities</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        thing's functionalities which is shown in <a
                        href="#sec-requirements-thing-functionalities"></a>
                    </li>
                </ul>
            </section>
            <section id="sec-requirements-network">
                <h3>Network</h3>
                <ul>
                    <li>WoT architecture should support multiple
                        web protocols which are commonly used.</li>
                    <li>Such protocols include
                        <ol>
                            <li>protocols commonly used in the
                                internet and</li>
                            <li>protocols commonly used in the
                                local area network</li>
                        </ol>
                    </li>
                    <li>WoT architecture should allow using
                        multiple web protocols to access to the same
                        functionality.</li>
                    <li>WoT architecture should allow using a
                        combination of multiple protocols to the
                        functionalities of the same thing (e.g. HTTP and
                        WebSocket).</li>
                </ul>
            </section>
            <section id="sec-requirements-deployment">
                <h3>Deployment</h3>
                <ul>
                    <li>WoT architecture should support a wide
                        variety of thing capabilities such as edge
                        devices with resource restrictions and virtual
                        things on the cloud, based on the same model.</li>
                    <li>WoT architecture should support multiple
                        levels of thing hierarchy with intermediate
                        entities such as gateways and proxies.</li>
                    <li>WoT architecture should support accessing
                        things in the local network from the outside of
                        the local network (the internet or another local
                        network), considering network address
                        translation.</li>
                </ul>
            </section>
            <section id="sec-requirements-application">
                <h3>Application</h3>
                <ul>
                    <li>WoT architecture should allow describing
                        applications for a wide variety of things such
                        as edge device, gateway, cloud and UI/UX device,
                        using web standard technology based on the same
                        model.</li>
                </ul>
            </section>
            <section id="sec-requirements-legacy-adoption">
                <h3>Legacy adoption</h3>
                <ul>
                    <li>WoT architecture should allow mapping of
                        legacy IP and non-IP protocols to web protocols,
                        supporting various topologies, where
                        such legacy protocols are terminated and
                        translated.
                    </li>
                    <li>WoT architecture should allow transparent
                        use of existing IP protocols without
                        translation, which follow RESTful architecture.</li>

                    <li>WoT architecture must not enforce client or server
                        roles on devices and services.
                        An IoT device can be either a client or a server,
                        or both, depending on the system architecture;
                        the same is true of edge and cloud services.
                    </li>
                </ul>
            </section>
        </section>
        <section id="sec-technical-requirements">
            <h2>Technical Requirements</h2>
            <p>
                <a href="#sec-common-usecase-patterns"></a> defines the
                Web of Things abstract architecture by showing various
                use cases and enumerating patterns for combining
                architectural components. This section describes
                technical requirements derived from the abstract
                architecture.
            </p>
            <section>
                <h3>Components consisting Web of Things and the Web
                    of Things architecture</h3>
                <p>The use cases help to identify basic components
                    such as devices and applications, that access and
                    control those devices, proxies (i.e. gateways and
                    edge devices) that are located between devices.
                    An additional component useful in some use cases
                    is the directory, which assists with discovery.</p>
                <p>Those components are connected to the internet or
                    field networks in offices, factories or other
                    facilities. Note that all components involved may be
                    connected to a single network in some cases,
                    however, in general components can be deployed
                    across multiple networks.</p>
            </section>
            <section>
                <h3>Devices</h3>
                <p>
                    Access to devices is made using a descriptions of
                    their functions and interfaces. This description is
                    called <em>Thing Description (TD)</em>. A <em>Thing
                        Description</em> includes a general metadata about
                    the device, information models representing
                    functions, transport protocol description for
                    operating on information models, and security
                    information.
                </p>
                <p>General metadata contains device identifiers
                    (URI), device information such as serial number,
                    production date, location and other human readable
                    information.</p>
                <p>Information models defines device attributes, and
                    represent device’s internal settings, control
                    functionality and notification functionality.
                    Devices that have the same functionality have the
                    same information model regardless of the transport
                    protocols used.</p>
                <p>Because many systems based on Web of Things
                    architecture are crossing system Domains,
                    vocabularies and meta data (e.g. ontologies) used in
                    information models should be commonly understood by
                    involved parties. In addition to REST transports,
                    PubSub transports are also supported.</p>
                <p>Security information includes descriptions about
                    authentication, authorization and secure
                    communications. Devices are required to put TDs
                    either inside them or at locations external to the
                    devices, and to make TDs accessible so that other
                    components can find and access them.</p>
            </section>
            <section>
                <h3>Applications</h3>
                <p>Applications need to be able to generate and use network
                    and program interfaces based on metadata (descriptions).</p>
                <p>Applications have to be able to obtain these
                    descriptions through the network,
                    therefore, need to be able to conduct search
                    operations and acquire the necessary descriptions over the
                    network.</p>
            </section>
            <section>
                <h3>Digital Twins</h3>
                <p>Digital Twins need to generate program interfaces
                    internally based on metadata (descriptions),
                    and to represent virtual devices by using those
                    program interfaces. A twin has to produce a description for
                    the virtual device and make it externally available.</p>
                <p>Identifiers of virtual devices need to be newly
                    assigned, therefore, are different from the original
                    devices. This makes sure that virtual devices and
                    the original devices are clearly recognized as
                    separate entities. Transport and security mechanisms
                    and settings of the virtual devices can be different
                    from original devices if necessary. Virtual devices
                    are required to have descriptions provided either directly by
                    the twin or to have them available at external
                    locations. In either case it is required to make the
                    descriptions available so that other components can find and
                    use the devices associated with them.</p>
            </section>
            <section>
                <h3>Discovery</h3>
                <p>For TDs of devices and virtual devices to be
                    accessible from devices, applications and twins,
                    there needs to be a common way to share TDs.
                    Directories can serve this requirement by providing
                    functionalities to allow devices and twins
                    themselves automatically or the users to manually
                    register the descriptions.</p>
                <p>Descriptions of the devices and virtual devices
                    need to be searchable by external entities.
                    Directories have to be able to process search
                    operations with search keys such as keywords from
                    the general description in the device description or
                    information models.</p>
            </section>
            <section>
                <h3>Security</h3>
                <p>Security information related to devices and
                    virtual devices needs to be described in device
                    descriptions. This includes information for
                    authentication/authorization and payload
                    encryption.</p>
                <p>WoT architecture should support multiple security
                    mechanism commonly used in the web, such as Basic,
                    Digest, Bearer and OAuth2.0.</p>
            </section>
            <section>
                <h3>Accessibility</h3>
                <p>The Web of Things primarily targets
                    machine-to-machine communication. The humans
                    involved are usually developers that integrate
                    Things into applications. End-users will be faced
                    with the front-ends of the applications or the
                    physical user interfaces provided by devices
                    themselves. Both are out of scope of the W3C WoT
                    specifications. Given the focus on IoT instead of
                    users, accessibility is not a direct requirement,
                    and hence is not addressed within this specification.</p>
                <p>There is, however, an interesting aspect on
                    accessibility: Fulfilling the requirements above
                    enables machines to understand the network-facing
                    API of devices. This can be utilized by
                    accessibility tools to provide user interfaces of
                    different modality, thereby removing barriers to
                    using physical devices and IoT-related applications.</p>
            </section>
        </section>
    </section>

    <section id="sec-wot-architecture">
        <h1>WoT Architecture</h1>
        <p>
            <em>This section is normative.</em>
        </p>
        <p>
            To address the use cases in Section 4 and fulfill the requirements in Section 5,
            the Web of Things (WoT) builds on top of the concept of Web Things &ndash; usually simply called <a>Things</a> &ndash; that can be used by so-called <a>Consumers</a>.
            This section provides the background and normative assertions to define the overall W3C Web of Things architecture.
            As the Web of Things addresses stakeholders from different domains, certain aspects of Web technology are explained in more detail, in particular the concept of hypermedia.
        </p>
        <section id="sec-architecture-overview">
            <h2>Overview</h2>
            <p>
                A <a>Thing</a> is the abstraction of a physical or virtual entity (e.g., a device or a room) and is described by standardized metadata.
                <span class="rfc2119-assertion" id="arch-td-metadata">
                  In W3C WoT, the description metadata MUST be a WoT Thing Description (TD) [[!wot-thing-description]].
                </span>
                <span class="rfc2119-assertion" id="arch-td-consumers-process">
                  <a>Consumers</a> MUST be able to process the <a>WoT Thing Description</a> format, which is based on JSON [[!RFC8259]].
                </span>
                The format can be processed either through classic JSON libraries or a JSON-LD processor, 
                as the underlying information model is graph-based and its serialization compatible with JSON-LD 1.1 [[?json-ld-syntax]].
                A <a>TD</a> is instance-specific (i.e., describes an individual Thing, not types of Things)
                and is the default external, textual (Web) representation of a <a>Thing</a>.
                <span class="rfc2119-assertion" id="arch-other-thing-representations">
                There MAY be other representations of a <a>Thing</a> such as an HTML-based user interface, 
                simply an image of the physical entity,
                or even non-Web representations in closed systems.
                </span>
             </p>
             <p>
                <span class="rfc2119-assertion" id="arch-td-mandatory">
                To be a <a>Thing</a>, however, at least one <a>TD</a> representation MUST be available.
                </span>
                The <a>WoT Thing Description</a> is a standardized, machine-understandable representation format
                that allows <a>Consumers</a> to discover and interpret the capabilities of a <a>Thing</a> (through semantic annotations)
                and to adapt to different implementations (e.g., different protocols or data structures) when interacting with a Thing,
                thereby enabling interoperability across different <a>IoT platforms</a>, i.e., different ecosystems and standards.
            </p>
            <figure id="consumer-thing">
                <img src="images/architecture/consumer-thing.png"
                     class="wot-arch-diagram" />
                <figcaption>Consumer--Thing interaction</figcaption>
            </figure>
            <p>
                A <a>Thing</a> can also be the abstraction of a virtual entity.
                A virtual entity is the composition of one or more Things (e.g., a room consisting of several sensors and actuators).
                One option for the composition is to provide a single, consolidated <a>WoT Thing Description</a> that contains the superset of capabilities for the virtual entity.
                In cases where the composition is rather complex, its <a>TD</a> may <em>link</em> to hierarchical sub-Things within the composition.
                The main <a>TD</a> acts as entry point and only contain general metadata and potentially overarching capabilities.
                This allows grouping of certain aspects of more complex Things.
            </p>
            <p>
                Linking does not only apply to hierarchical <a>Things</a>, but relations between Things and other resources in general.
                Link relation types express how Things relate, for instance, a switch controlling a light or a room monitored by a motion sensor.
                Other resources related to a <a>Thing</a> can be manuals, catalogs for spare parts, CAD files, a graphical UI, or any other document on the Web.
                Overall, Web linking among Things makes the Web of Things navigable, for both humans and machines.
                This can be further facilitated by providing Thing directories that manage a catalog of available <a>Things</a>, usually by caching their TD representation.
                In summary, 
                <span class="rfc2119-assertion" id="arch-td-linking"><a>WoT Thing Descriptions</a> 
                MAY link to other <a>Things</a> and other resources on the Web to form a Web of Things.
                </span>
            </p>
            <figure id="linked-things">
                <img src="images/architecture/linked-things.png"
                     class="wot-arch-diagram" />
                <figcaption>Linked Things</figcaption>
            </figure>
            <p>
                Things must be hosted on networked system components with a software stack to realize interaction through a network-facing interface, the <a>WoT Interface</a> of a <a>Thing</a>.
                One example of this is an HTTP server running on an embedded device with sensors and actuators interfacing the physical entity behind the <a>Thing</a> abstraction.
                However, W3C WoT does not mandate where <a>Things</a> are hosted; it can be on the IoT device directly, an <a>Edge device</a> such as a gateway, or the cloud.
            </p>
            <p>
                A typical deployment challenge is a scenario, where local networks are not reachable from the Internet, 
                usually because of IPv4 Network Address Translation (NAT) or firewall devices.
                To remedy this situation, W3C WoT allows for <a>Intermediaries</a> between <a>Things</a> and <a>Consumers</a>.
            </p>
            <p>    
                <a>Intermediaries</a> can act as proxies for <a>Things</a>, where the <a>Intermediary</a> has a <a>WoT Thing Description</a> similar to the original <a>Thing</a>,
                but which points to the <a>WoT Interface</a> provided by the <a>Intermediary</a>.
                <a>Intermediaries</a> may also augment existing <a>Things</a> with additional capabilities or compose a new <a>Thing</a> out of multiple available <a>Things</a>,
                thereby forming a virtual entity.
                To <a>Consumers</a>, <a>Intermediaries</a> look like <a>Things</a>, as they possess <a>WoT Thing Descriptions</a> and provide a <a>WoT Interface</a>,
                and hence might be indistinguishable from <a>Things</a> in a layered system architecture like the Web [[?REST]].
                <span class="rfc2119-assertion" id="arch-id-correlation">
                An identifier in the <a>WoT Thing Description</a> MUST allow for the correlation of multiple <a>TDs</a> representing the same original <a>Thing</a> or ultimately unique physical entity.
                </span>
            </p>
            <figure id="intermediary">
                <img src="images/architecture/intermediary.png"
                     class="wot-arch-diagram" />
                <figcaption>Intermediary</figcaption>
            </figure>
            <p>
                Another remedy for restricted local networks is binding the <a>WoT Interface</a> to a protocol 
                that establishes the connection from the <a>Thing</a> within the local network to a publicly reachable <a>Consumer</a>.
            </p>
            <p>
                <span class="rfc2119-assertion" id="arch-thing-bundling">Things 
                MAY be bundled together with a Consumer to enable Thing-to-Thing interaction.</span>
                Usually, the Consumer behavior is embedded in the software component, 
                which is also implementing the behavior of the Thing.
                <span class="rfc2119-assertion" id="arch-consumer-configuration">The 
                configuration of the Consumer behavior MAY be exposed through the Thing.</span>
            </p>
            <p>
                The concepts of W3C WoT are applicable to all levels relevant for IoT applications: the device level, edge level, and cloud level.
                This fosters common interfaces and APIs across the different levels and enables various integration patterns 
                such as Thing-to-Thing, Thing-to-Gateway, Thing-to-Cloud, Gateway-to-Cloud, and even cloud federation, 
                i.e. interconnecting cloud computing environments of two or more service providers, for IoT applications.
                <a href="#architecture-abstract"></a> gives an overview how the WoT concepts introduced above can be applied and combined to address the use cases summarized in <a href="#sec-use-case-summary"></a>.
            </p>
            <figure id="architecture-abstract">
                <img src="images/architecture/overview.png"
                     class="wot-arch-diagram" />
                <figcaption>Abstract Architecture of W3C WoT</figcaption>
            </figure>
        </section>
        <section id="sec-affordances">
            <h2>Affordances</h2>
            <p>
                A central aspect in W3C WoT is the provision of machine-understandable metadata (i.e., <a>WoT Thing Descriptions</a>).
                Ideally, such metadata is self-descriptive, so that <a>Consumers</a> are able to identify
                <em>what</em> capabilities a <a>Thing</a> provides and <em>how</em> to use the provided capabilities.
                A key to this self-descriptiveness lies in the concept of affordances.
            </p>
            <p>
                The term affordance originates in ecological
                psychology, but was adopted in the field of
                Human-Computer Interaction [[?HCI]] based on the
                definition by Donald Norman: "'Affordance' refers to
                the perceived and actual properties of the thing,
                primarily those fundamental properties that
                determine just how the thing could possibly be
                used." [[?NORMAN]]</p>
            <p>
                An example for this is a door with a handle.
                The door handle is an affordance, which suggests that the door can be opened.
                For humans, a door handle usually also suggests <em>how</em> the door can be opened;
                an American knob suggests twisting, a European lever handle suggests pressing down.
            </p>
            <p>
                The hypermedia principle, which is one of the
                core foundations of the REST architectural style [[?REST]],
                demands that any piece of information available on
                the Web be linked to other pieces of information so
                that the consumer of the information gets explicit
                knowledge about how to navigate the Web and control
                Web applications.
                Here, the simultaneous presentation of
                information and control (provided in
                the form of hyperlinks) is a mechanism that <em>affords</em>
                Web clients the means to drive Web applications. In this
                context, an affordance is the description of a
                hyperlink (e.g., via a link relation type and link
                target attributes) suggesting Web clients how to navigate
                and possibly how to act on the linked resource.
                Hence, links provide navigation affordances.
            </p>
            <p>
                Drawn from this hypermedia principle,
                the Web of Things defines <a>Interaction Affordances</a> as metadata of a Thing
                that shows and describes the possible choices to <a>Consumers</a>, thereby suggesting 
                how <a>Consumers</a> may interact with the <a>Thing</a>.
                A general <a>Interaction Affordance</a> is navigation, which is activated by following a link, 
                thereby enabling <a>Consumers</a> to browse the Web of Things.
                <a href="#sec-interaction-model"></a> defines three more types of Interaction Affordances for W3C WoT: <a>Properties</a>, <a>Actions</a>, and <a>Events</a>.
            </p>
            <p>
                Overall, this W3C WoT definition is aligned with HCI and interaction designers, who create physical Things,
                as well as the REST and microservice community, who is working on Web services in general.
            </p>
        </section>
        <section id="sec-web-thing">
            <h2>Web Thing</h2>
            <p>
                A Web Thing has four architectural aspects of interest:
                its <em>behavior</em>, its <em><a>Interaction Affordances</a></em>, its <em>security configuration</em>, 
                and its <em><a>Protocol Bindings</a></em>,
				as depicted in <a href="#arch-webthing"></a>. 
                The behavior aspect of a <a>Thing</a> includes both the autonomous behavior and the handlers for the <a>Interaction Affordances</a>.
                The <a>Interaction Affordances</a> provide a model of how <a>Consumers</a> can interact with the <a>Thing</a> through abstract operations,
				but without reference to a specific network protocol or data encoding.
                The protocol binding adds the additional detail needed to map each interaction to concete messages of a certain protocol.
                In general, different concrete protocols may be used to
                support different subsets of <a>Interaction Affordances</a>,
                even within a single Thing. The security configuration
                aspect of a Thing represents the mechanisms used to
                control access to the <a>Interaction Affordances</a> and the management of
                related public and private metadata.
            </p>
            <figure id="arch-webthing">
                <img src="images/architecture/webthing.png"
                     class="wot-arch-diagram" />
                <figcaption>Architectural Aspects of a Thing</figcaption>
            </figure>
        </section>
        <section id="sec-interaction-model">
            <h2>Interaction Model</h2>
            <p>
                Originally, a Web resource usually represented a
                document on the World Wide Web that can simply be
                fetched by a Web client. With the introduction of Web
                services, resources became more generic interaction
                entities that can implement any kind of behavior. This
                very high level of abstraction makes it hard to provide
                a loose coupling between applications and resources due to
                the manifold interaction possibilities. As a result,
                at the time of writing typical API descriptions consist of a static mapping
                from an application intent to a resource address,
                method, request payload structure, response payload
                structure, and expected errors.
                This imposes a tight coupling between Web client and Web service.</p>
            <p>
                The <a>Interaction Model</a> of W3C WoT introduces an
                intermediate abstraction that formalizes the mapping
                from application intent to concrete protocol operations
                and also narrows the possibilities how <a>Interaction Affordances</a>
                can be modeled.
            </p>
            <p>
                <span class="rfc2119-assertion" id="arch-affordances">In 
                addition to navigation affordances (i.e., Web links),
                <a>Things</a> MAY offer three other types of <a>Interaction Affordances</a> 
                defined by this specification: <a>Properties</a>, <a>Actions</a>, and <a>Events</a>.
                </span>
                While this narrow waist allows to decouple <a>Consumers</a> and <a>Things</a>,
                these four types of <a>Interaction Affordances</a> are still able to model virtually all interaction possibilities found in IoT devices and services.
            </p>
            <section>
                <h3>Properties</h3>
                <p>
                    A Property is an Interaction Affordance that exposes the state of the Thing.
                    <span class="rfc2119-assertion" id="arch-property-readable">
                    The state exposed by a Property MUST be retrievable (readable).
                    </span>
                    <span class="rfc2119-assertion" id="arch-property-writable">
                    Optionally, the state exposed by a Property MAY be updated (writeable).
                    </span>
                    <span class="rfc2119-assertion" id="arch-property-observable">
                    <a>Things</a>  MAY choose to make Properties observable by pushing the new state after a change
                    (cf. Observing Resources [[?RFC7641]]).
                    </span>
                    Write-only state should be updated through an Action.
                </p>
                <p>
                    <span class="rfc2119-assertion" id="arch-property-dataschema">
                    If the data is not fully specified by the Protocol Binding used (e.g., through a Media Type),
                    Properties MAY contain one data schema for the exposed state.
                    </span>
                </p>
                <p>
                    Examples of Properties are sensor values (read-only), stateful actuators (read-write),
                    configuration parameters (read-write), Thing status (read-only or read-write), or computation results (read-only).
                </p>
            </section>
            <section>
                <h3>Actions</h3>
                <p>
                    An Action is an Interaction Affordance that allows to invoke a function of the Thing.
                    <span class="rfc2119-assertion" id="arch-action-functions">
                    An Action MAY manipulate state that is not directly exposed (cf. Properties),
                    manipulate multiple Properties at a time, or manipulate Properties based on internal logic (e.g., toggle).
                    </span>
                    <span class="rfc2119-assertion" id="arch-action-process">
                    Invoking an Action MAY also trigger a process on the Thing that manipulates state 
                    (including physical state through actuators) over time.
                    </span>
                </p>
                <p>
                    <span class="rfc2119-assertion" id="arch-action-dataschema">
                    If the data is not fully specified by the Protocol Binding used (e.g., through a Media Type),
                    Actions MAY contain data schemas for optional input parameters and output results.
                    </span>
                </p>
                <p>
                    Examples of Actions are changing multiple Properties simultaneously,
                    changing Properties over time such as fading the brightness of a light (dimming)
                    or with a process that shall not be disclosed such as a proprietary control loop algorithm,
                    or invoking a long-lasting process such as printing a document.</p>
            </section>
            <section>
                <h3>Events</h3>
                <p>
                    An Event Interaction Affordance describes an event source that pushes data asynchronously from the Thing to the Consumer.
                    Here not state, but state transitions (i.e., events) are communicated.
                    <span class="rfc2119-assertion" id="arch-event-trigger">
                    Events MAY be triggered through conditions that are not exposed as Properties.
                    </span>
                </p>
                <p>
                    <span class="rfc2119-assertion" id="arch-event-dataschema">
                    If the data is not fully specified by the Protocol Binding used (e.g., through a Media Type),
                    Events MAY contain data schemas for the event data and possible subscription control messages 
                    (e.g., to subscribe with a Webhook callback URI).
                    </span>
                </p>
                <p>
                    Examples of Events are discrete events such as an alarm or samples of a time series that are pushed regularly.
                </p>
            </section>
        </section>
        <section id="sec-hypermedia-controls">
            <h2>Hypermedia Controls</h2>
            <p>
                On the Web, an affordance is the simultaneous presentation of information and controls,
                such that the information becomes the affordance through which the user obtains choices.
                For humans, the information is usually text or images describing or decorating a hyperlink.
                The control is a Web link, which includes at least the URI of the target resource,
                which can be dereferenced by the Web browser (i.e., the link can be followed).
                But also machines can follow links in a meaningful way, when the Web link is further described 
                by a relation type and a set of target attributes.
                A hypermedia control is the machine-understandable description of <em>how</em> to activate an affordance.
                Hypermedia controls usually originate from a Web server and are discovered in-band while a Web client is interacting with the server.
                This way, Web servers can drive clients through Web applications dynamically,
                by taking their current state and other factors such as authorization into account.
                This is opposed to out-of-band interface descriptions that need to be preinstalled or hardcoded into clients
                (e.g., RPC, WS-* Web services, HTTP services with fixed URI-method-response definitions).
            </p>
            <p>
                W3C WoT makes use of two kinds of hypermedia controls:
                <em> Web links</em> [[!RFC8288]], the well-established control to navigate the Web,
                and Web forms as a more powerful control to enable any kind of operation.
		            Links are already used in other IoT standards and <a>IoT platforms</a> such as
		            CoRE Link Format [[?RFC6690]], OMA LWM2M [[?LWM2M]], and OCF [[?OCF]].
		            Form is a new concept that besides W3C WoT is also introduced by the
		            <em>Constrained RESTful Application Language (CoRAL)</em> [[?CoRAL]] defined by the IETF.
            </p>
            <section id="sec-hypermedia-links">
                <h3>Links</h3>
                <p>
                    Links enable <a>Consumers</a> (or Web clients in the broader sense) to change the current context
                    (cf. the set of resource representations currently rendered in the Web browser)
                    or to include additional resources into the current context,
                    depending on the relation between context and link target.
                    <a>Consumers</a> do so by <em>dereferencing</em> the target URI,
                    that is, fetching the resource representation by following a link.
                </p>
                <p>
                    W3C WoT follows the definitions of Web Linking [[!RFC8288]],
                    where a link is comprised of:
                </p>
                <ul>
                        <li>a link context,</li>
                        <li>a relation type,</li>
                        <li>a link target, and</li>
                        <li>optionally target attributes.</li>
                    </ul>
                <p>
                    Link relation types are either a set of predefined tokens that are registered with IANA [[IANA-RELATIONS]] 
                    adhering to the ABNF [[!RFC5234]] <code style="white-space: nowrap;">LOALPHA *( LOALPHA / DIGIT / "." / "-" )</code>
                    (e.g., <code>stylesheet</code>) or extension types in the form of URIs [[!RFC3986]].
                    <span class="rfc2119-assertion" id="arch-rel-types">
                    Extension relation types MUST be compared as strings using a case-insensitive comparison.
                    (If they are serialised in a different format they are to be converted to URIs).
                    </span>
                    <span class="rfc2119-assertion" id="arch-rel-type-lowercase">
                    Nevertheless, all-lowercase URIs SHOULD be used for extension relation types. [[!RFC8288]]
                    </span>
                </p>
                <p>
                    In the Web of Things, links are used for discovery and to express relations between <a>Things</a> 
                    (e.g., hierarchical or functional)
                    and relations to other documents on the Web
                    (e.g., manuals or alternative representations such as CAD models).
                </p>
            </section>
            <section id="sec-hypermedia-forms">
                <h3>Forms</h3>
                <p>
                    Forms enable <a>Consumers</a> (or Web clients in the broader sense) to perform operations that go beyond dereferencing a URI
                    (e.g. to manipulate the state of a Thing).
                    <a>Consumers</a> do so by <em>filling out</em> and <em>submitting</em> the form to its submission target.
                    This usually requires more detailed information about the contents of the (request) message than a link can provide
                    (e.g., method, header fields, or other protocol options).
                    Forms can be seen as a request template,
                    where the provider pre-filled parts of the information according to its own interface and state,
                    and left parts blank to be filled by the <a>Consumers</a> (or Web client in general).
                </p>
                <p>
                    W3C WoT defines forms as new hypermedia control.
		    Note that the definition in CoRAL is virtually identical, and hence compatible [[?CoRAL]].
                    A form is comprised of:
                </p>
                    <ul>
                        <li>a form context,</li>
                        <li>an operation type,</li>
                        <li>a submission target,</li>
                        <li>a request method, and</li>
                        <li>optionally form fields.</li>
                    </ul>
                <p>
                    A form can be viewed as a statement of "To perform a
                    <code>operation type</code>
                    operation on
                    <code>form context</code>
                    , issue a
                    <code>request method</code>
                    request to
                    <code>submission target</code>
                    " where the optional form fields may further describe the required request.
                </p>
                <p>
                    <span class="rfc2119-assertion" id="arch-form-iris">
                    Form contexts and submission targets MUST both be
                    Internationalized Resource Identifiers (IRIs)
                    [[!RFC3987]]. 
                    </span>
                    However, in the common case, they will
                    also be URIs [[!RFC3986]], because many protocols
                    (such as HTTP) do not support IRIs.</p>
                <p>
                    <span class="rfc2119-assertion" id="arch-form-iris">
                    Form context and submission target MAY point to
                    the same resource or different resources, where the
                    submission target resource implements the operation
                    for the context.
                    </span></p>
                <p>The operation type identifies the semantics of
                    the operation. Operation types are denoted similar
                    to link relation types:</p>
                <ul>
                    <li>
                        <span class="rfc2119-assertion" id="arch-op-wellknown">
                            Well-known operation types MUST follow the ABNF
                            <code style="white-space: nowrap;">LOALPHA *( LOALPHA / DIGIT / "." / "-" )</code>.
                        </span>
                        <span class="rfc2119-assertion" id="arch-op-wellknown-compare">
                            Well-known operation types MUST be compared using a case-insensitive comparison.
                        </span>
                        The well-known operation types for the Web of Things defined by this specification are given in <a href="#table-operation-types">Table 1</a>.
                    </li>
                    <li>
                        <span class="rfc2119-assertion" id="arch-op-extension">
                            The set of predefined operation types MAY be augmented by <em>Extension operation types</em> chosen by applications.
                        </span>
                        <span class="rfc2119-assertion" id="arch-op-extension-uri">
                            Extension operation types MUST be URIs [[!RFC3986]] that uniquely identify the type.
                        </span>
                        <span class="rfc2119-assertion" id="arch-op-extension-comparison">
                            Extension operation types MUST be compared compared as strings using a case-insensitive comparison.
                        </span>
                        <span class="rfc2119-assertion" id="arch-op-extension-lowercase">
                            Nevertheless, all-lowercase URIs SHOULD be used for extension operation types.
                        </span>
                    </li>
                </ul>
                <p>
                    <span class="rfc2119-assertion" id="arch-op-request-method">
                    The request method MUST identify one method of
                    the standard set of the protocol identified by the
                    submission target URI scheme.
                    </span>
                </p>
                <p>
                    <span class="rfc2119-assertion" id="arch-op-expected-request">
                    Form fields are optional and MAY further specify the
                    expected request message for the given operation.
                    </span>
                    Note that this is not limited to the payload, but may affect also protocol headers.
                    <span class="rfc2119-assertion" id="arch-op-form-fields-protocol">
                    Form fields MAY depend on the protocol used for the
                    submission target as specified in the URI scheme. 
                    </span>
                    Examples are HTTP header fields,
                    CoAP options, the protocol-independent Media Type including parameters (i.e., full content type)
                    for the request payload, or information about the
                    expected response.
                </p>
                <div id="table-operation-types">
                    <div style="text-align: center; font-style: italic;">Table 1 Well-known Operation Types for the Web of Things</div>
                    <table class="def">
                        <thead>
                            <tr>
                                <th>Operation Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>readproperty</td>
                                <td>Identifies the read operation on
                                    Property Affordances to retrieve the
                                    corresponding data.</td>
                            </tr>
                            <tr>
                                <td>writeproperty</td>
                                <td>Identifies the write operation on
                                    Property Affordances to update the
                                    corresponding data.</td>
                            </tr>
                            <tr>
                                <td>observeproperty</td>
                                <td>Identifies the observe operation on
                                    Property Affordances to be notified with
                                    the new data when the Property was
                                    updated.</td>
                            </tr>
                            <tr>
                                <td>unobserveproperty</td>
                                <td>Identifies the unobserve
                                    operation on Property Affordances to stop
                                    the corresponding notifications.</td>
                            </tr>
                            <tr>
                                <td>invokeaction</td>
                                <td>Identifies the invoke operation on
                                    Action Affordances to perform the
                                    corresponding action.</td>
                            </tr>
                            <tr>
                                <td>subscribeevent</td>
                                <td>Identifies the subscribe operation
                                    on Event Affordances to be notified by
                                    the Thing when the event occurs.</td>
                            </tr>
                            <tr>
                                <td>unsubscribeevent</td>
                                <td>Identifies the unsubscribe
                                    operation on Event Affordances to stop
                                    the corresponding notifications.</td>
                            </tr>
                            <tr>
                                <td>readallproperties</td>
                                <td>Identifies the readallproperties
                                    operation on Things to retrieve the
                                    data of all Properties in a single interaction.</td>
                            </tr>
                            <tr>
                                <td>writeallproperties</td>
                                <td>Identifies the writeallproperties
                                    operation on Things to update the
                                    data of all writable Properties in a single interaction.</td>
                            </tr>
                            <tr>
                                <td>readmultipleproperties</td>
                                <td>Identifies the readmultipleproperties
                                    operation on Things to retrieve the
                                    data of selected Properties in a single interaction.</td>
                            </tr>
                            <tr>
                                <td>writemultipleproperties</td>
                                <td>Identifies the writemultipleproperties
                                    operation on Things to update the
                                    data of selected writable Properties in a single interaction.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p class="ednote">As of this specification, the
                    well-known operation types are a fixed set that
                    results from the WoT <a>Interaction Model</a>. Other
                    specifications may define further well-known
                    operation types that are valid for their respective
                    document format or form serialization. Later versions of
                    this specification or another specification may set up an IANA registry in
                    the future to enable extension and a more
                    generic Web form model that may be applied beyond
                    WoT specifications.
                </p>
            </section>
        </section>
        <section id="sec-protocol-bindings">
            <h2>Protocol Bindings</h2>
            <p>
                A Protocol Binding is the mapping from an <a>Interaction Affordance</a> to concrete messages of a specific protocol such as HTTP [[!RFC7231]], CoAP [[!RFC7252]], or MQTT [[!MQTT]].
                It informs the <a>Consumer</a> <em>how</em> to activate the <a>Interaction Affordance</a> through a network-facing interface.
                The <a>Protocol Bindings</a> follow the Uniform Interface constraint of REST [[?REST]] to support interoperability.
                Thus, not all communication protocols are eligible to implement <a>Protocol Bindings</a> for W3C WoT;
                the requirements are given in the assertions below.
            </p>
            <p>
                In the door example given in <a href="#sec-affordances"></a>, the <a>Protocol Binding</a> corresponds to the door handle at the level of knob vs lever,
                which suggests <em>how</em> the door can be opened.
            </p>
            <section>
                <h3>Hypermedia-driven</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-hypermedia">
                        Interaction Affordances MUST include one or more Protocol Bindings. 
                    </span>
                    <span class="rfc2119-assertion" id="arch-hypermedia-protocol-binding">
                        Protocol Bindings MUST be serialized as hypermedia controls (see <a
                        href="#sec-hypermedia-controls"></a>) to be self-descriptive on how to activate the Interaction Affordance.
                    </span>
                    <span class="rfc2119-assertion" id="arch-hypermedia-origin">
                        The hypermedia controls MUST originate from the authority managing the Thing that is providing the corresponding Interaction Affordance.
                    </span>
                    The authority can be the <a>Thing</a> itself, generating the <a>WoT Thing Description</a> 
                    at runtime (based on its current state and including network parameters such as its IP address),
                    or an external entity that has full and up-to-date knowledge of the <a>Thing</a> 
                    including its network parameters and internal structure (e.g. software stack).
                    This enables a loose coupling between <a>Things</a>  and clients, allowing for an independent lifecycle and evolution.
                    <span class="rfc2119-assertion" id="arch-hypermedia-caching">
                        The hypermedia controls MAY be cached outside the Thing and used for offline processing if corresponding caching metadata is available to determine the freshness.
                    </span>
                </p>
            </section>
            <section id="sec-arch-URIs">
                <h3>URIs</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-uri-scheme">
                        Eligible protocols for W3C WoT MUST have an associated URI scheme that is registered with IANA [[!RFC4395]].
                    </span>
                    Hypermedia controls rely on URIs to identify link and submission targets.
                    Thereby, the URI scheme (the first component up to ":") identifies the communication protocol to be used for interaction with the Thing.
                    W3C WoT refers to these protocols as <a>transfer protocols</a>.
                </p>
            </section>
            <section id="sec-standard-method">
                <h3>Standard Set of Methods</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-methods">
                        Eligible protocols for W3C WoT MUST be based on a
                        standard set of methods that are known a priori.</span>
                    The standard set of methods makes messages
                    self-descriptive to enable intermediate processing of
                    interactions, for instance by proxies or to translate
                    between Protocol Bindings [[?REST]]. Furthermore, it
                    allows <a>Consumers</a> to have re-usable protocol
                    stacks of common <a>transfer protocols</a> such as HTTP, CoAP, or MQTT,
                    avoiding Thing-specific code or plugins for <a>Consumers</a>.
                </p>
            </section>
            <section id="media-types">
                <h3>Media Types</h3>
                <p>
                    <span class="rfc2119-assertion" id="arch-media-type">All
                        data (a.k.a. content) exchanged when activating Interaction Affordances MUST be identified by a Media Type
                        [[!RFC6838]] in the Protocol Binding.</span>
                    Media Types are labels to identify representation formats, for instance
                    <code>application/json</code>
                    for JSON [[!RFC8259]] or
                    <code>application/cbor</code>
                    for CBOR [[!RFC7049]]. They are managed by IANA. 
                </p>
                <p>
                    Some Media Types might need additional parameters to fully specify the representation format used.
                    Examples are <code>text/plain; charset=utf-8</code> or <code>application/ld+json; profile="http://www.w3.org/ns/json-ld#compacted"</code>.
                    This needs to be taken into account in particular when describing data to be sent to <a>Things</a>.
                    There might also be standardized transformations on the data such as content coding [[!RFC7231]].
                    <span class="rfc2119-assertion" id="arch-media-type-extra">
                        Protocol Bindings MAY have additional information that specifies representation formats in more detail than the Media Type alone.
                    </span>
                </p>
                <p>
                    Note that many Media Types only identify a generic
                    serialization format that does not provide further
                    semantics for its elements (e.g., XML, JSON, CBOR). 
                    <span class="rfc2119-assertion" id="arch-schema">Thus,
                        the corresponding Interaction Affordances SHOULD
                        declare a <em>data schema</em> to provide more detailed
                        syntactic metadata for the data exchanged.</span>
                </p>
            </section>
        </section>
        <section id="sec-WoT-servient-architecture-high-level">
            <h2>WoT System Components and their Interconnectivity</h2>

            <p>Section <a href="#sec-architecture-overview"></a> described the 
               WoT architecture in terms of the abstract WoT architecture components 
               such as <a>Things</a>, <a>Consumers</a> and <a>Intermediaries</a>. 
               When those abstract WoT architecture components are implemented as 
               a software stack to take a specific role in the WoT architecture, 
               such software stacks are called <a>Servients</a>. 
               Systems that are based on the WoT architecture involve <a>Servients</a>, 
               which are communicating with each other to achieve the goals of a system.</p>

            <p>This section uses system configuration diagrams to illustrate
               how <a>Servients</a> work together to build systems based on the WoT architecture.</p>

            <p>A <a>Thing</a> can be implemented by a <a>Servient</a>. In a <a>Thing</a>, 
               a <a>Servient</a> software stack contains a representation of 
               a <a>Thing</a> called <a>Exposed Thing</a>, and makes its <a>WoT Interface</a> 
               available  to <a>Consumers</a> of the <a>Thing</a>.
               This <a>Exposed Thing</a> may be used by other software components on 
               the <a>Servient</a> (e.g. applications) to implement the behavior of the thing.</p>

                <figure id="servient-thing-exposedThing">
                    <img
                        src="images/architecture/servient-thing-exposedThing.png" 
                        class="wot-arch-diagram" />
                    <figcaption>Servient as a Thing</figcaption>
                </figure>

            <p>On the other hand, <a>Consumers</a> are always implemented by
               <a>Servients</a>, as they must be able to process the <a>Thing Description</a> (TD)
               format and must have a protocol stack that can be configured through
               <a>Protocol Binding</a> information contained in the TDs.</p>
            <p>In a <a>Consumer</a>, a <a>Servient</a> software stack provides
               a representation of a <a>Thing</a> called <a>Consumed Thing</a>,
               and makes it available to those applications running on the <a>Servient</a>
               that need to process TDs to interact with <a>Things</a>.</p>

                <figure id="servient-consumer-consumedThing">
                    <img
                        src="images/architecture/servient-consumer-consumedThing.png"
                        class="wot-arch-diagram" />
                    <figcaption>Servient as a Consumer</figcaption>
                </figure>

            <p>A <a>Consumed Thing</a> instance in the <a>Servient</a> software stack serves 
               to separate the protocol level complexity from applications. 
               It is communicating with <a>Exposed Things</a> on behalf of the application.</p>

            <p>Similarly, an <a>Intermediary</a> is yet another WoT
               architecture component implemented by a <a>Servient</a>.
               An <a>Intermediary</a> is located between a <a>Thing</a> and its <a>Consumers</a>, 
               performing the roles of both a <a>Consumer</a> (to the Thing) 
               and a <a>Thing</a> (to the Consumers). 
               In an <a>Intermediary</a>, a <a>Servient</a> software stack contains 
               the representations of both a <a>Consumer</a> (<a>Consumed Thing</a>) 
               and a <a>Thing</a> (<a>Exposed Thing</a>).</p>

                <figure id="servient-intermediary">
                    <img
                        src="images/architecture/servient-intermediary.png"
                        class="wot-arch-diagram" />
                    <figcaption>Servient as an Intermediary</figcaption>
                </figure>

            <section>
                <h3>Direct Communication</h3>
                <p>
                    <a href="#high-level-application-device"></a> shows
                    direct communication between a <a>Thing</a>, which is
                    exposing <a>Interaction Affordances</a> through <a>Thing Descriptions</a>,
                    and a <a>Consumer</a> that uses the <a>Thing</a> by means of
                    the <a>Interaction Affordances</a>.
                    Direct communication applies when both <a>Servients</a>
                    use the same network protocol(s) and are accessible
                    to each other.
                </p>

                <figure id="high-level-application-device">
                    <img
                        src="images/architecture/servient-consumer-thing.png"
                        class="wot-arch-diagram" />
                    <figcaption>High level architecture of
                        Consumer and Thing</figcaption>
                </figure>

                <p>An <a>Exposed Thing</a> is the software representation of
                   a <a>Thing</a> abstraction, serving a <a>WoT Interface</a>
                   of the <a>Interaction Affordances</a> provided by the <a>Thing</a>.</p>

                <p>A <a>Consumed Thing</a> is the software representation of
                   a remote <a>Thing</a> being consumed by a <a>Consumer</a>, serving as
                   the interface to the remote <a>Thing</a> for the applications.
                   A <a>Consumer</a> can generate a <a>Consumed Thing</a> instance
                   by processing a <a>Thing Description</a>.
                   Interactions between a <a>Consumer</a> and a <a>Thing</a>
                   are performed by the <a>Consumed Thing</a> and the <a>Exposed Thing</a>
                   exchanging messages over a direct network connection between them.</p>
            </section>
            <section>
                <h3>Indirect Communication</h3>

                <p>
                    In <a href="#high-level-application-proxy-device-new"></a>,
                    a <a>Consumer</a> and a <a>Thing</a> connect to each other
                    via an <a>Intermediary</a>. An <a>Intermediary</a> is required
                    if the <a>Servients</a> use different protocols
                    or if they are on different networks that require
                    authentication and provide access control (e.g.
                    firewalls).
                </p>

                <figure id="high-level-application-proxy-device-new">
                    <img
                        src="images/architecture/servient-consumer-intermediary-thing.png"
                        class="wot-arch-diagram" />
                    <figcaption>High level architecture
                        with Intermediary</figcaption>
                </figure>

                <p>An <a>Intermediary</a> combines <a>Exposed Thing</a> and 
                   <a>Consumed Thing</a> functionality. The functionality of 
                   <a>Intermediaries</a> includes relaying messages for the 
                   interactions between a <a>Consumer</a> and a <a>Thing</a>, 
                   optionally caching the <a>Thing</a>'s data for faster response, and 
                   transforming communication when the functionality of the 
                   <a>Thing</a> is extended by the <a>Intermediary</a>.
                   In an <a>Intermediary</a>, a <a>Consumed Thing</a> creates
                   a proxy object of the <a>Exposed Thing</a> of a <a>Thing</a>,
                   and a <a>Consumer</a> can access the proxy object through
                   the <a>Exposed Thing</a> of the <a>Intermediary</a>.</p>

                <p>The <a>Exposed Thing</a> and <a>Consumed Thing</a> of an <a>Intermediary</a> can
                    communicate with the <a>Consumer</a> and the <a>Thing</a>
                    in different protocols. For example, an <a>Intermediary</a> can
                    provide a bridge between a <a>Thing</a> that uses CoAP and
                    an application on <a>Consumer</a> that uses HTTP. 
                </p>
                <p>
                    Even when there are
                    multiple <a>Things</a> and their <a>Exposed Things</a> use different protocols,
                    applications on the <a>Consumer</a> can communicate with those <a>Things</a>
                    using a single protocol through the <a>Intermediary</a>. The same
                    is true for the authentication. The <a>Consumed Thing</a> of a <a>Consumer</a> only
                    needs to handle a single authentication method even
                    when the <a>Exposed Things</a> of the multiple <a>Things</a> connected to an <a>Intermediary</a> use                    different authentication methods.</p>

                <p>An <a>Intermediary</a> creates a <a>Consumed Thing</a> and 
                   a proxy object for the <a>Exposed Thing</a> of the <a>Thing</a>, 
                   generates another TD for the proxy object from the 
                   <a>Thing Description</a> (TD) of the originating <a>Thing</a>.
                   Depending on the requirements of the use cases, the TD for the 
                   proxy object may either use the same identifier 
                   as the TD of the originating <a>Thing</a>, or it gets assigned 
                   a new identifier. 
                   <span class="rfc2119-assertion" id="arch-intermediary-td-extra-protocols">The 
                   If necessary, a TD generated by an <a>Intermediary</a> MAY contain 
                   interfaces for other communication protocols. 
                   </span>
                   </p>

                   <p>An <a>Intermediary</a> then creates an <a>Exposed Thing</a>
                   that serves as a bridge to the <a>Thing</a>. A <a>Consumer</a>
                   communicates with a device via an <a>Intermediary</a> through
                   a <a>Consumed Thing</a> that conforms to the TD for the proxy
                   object.</p>
            </section>
        </section>
    </section>

    <section id="sec-building-blocks">
        <h1>WoT Building Blocks</h1>
        <p>
            <em>This section is normative.</em>
        </p>
        <p> The Web of Things (WoT) Building Blocks allow the
            implementation of systems that conform with the abstract WoT
            Architecture. The specifics of these building blocks are
            defined in separate specification; this section provides an
            overview and a summary.
        </p>
        <p> The WoT Building Blocks support each of the architectural
            aspects of a <a>Thing</a> discussed in <a href="#sec-web-thing"></a>
            and depicted in <a href="#arch-webthing"></a>. The individual building
            blocks are shown in the context of an abstract <a>Thing</a> in
            <a href="#arch-building-blocks"></a>. This is an abstract
            view and does not represent any particular
            implementation; instead it illustrates the
            relationship between the building blocks and the main
            architectural aspects of a <a>Thing</a>.
            In this figure the WoT Building Blocks
            are highlighted with black outlines.
            Security, a cross-cutting concern,
            is separated into public and protected private components.
            The <a>WoT Scripting API</a> is optional and the
            <a>Binding Templates</a> are informative.
        </p>
        <figure id="arch-building-blocks">
            <img src="images/bblocks/abstract.png" 
                 class="wot-arch-diagram" />
            <figcaption>Relationship of WoT Building Blocks 
            to the Architectural Aspects of a Thing.</figcaption>
        </figure>
        <p> The <a>WoT Thing Description</a> (TD) contains metadata describing the
            <a>Interaction Affordances</a> of the <a>Thing</a>, the mapping of these
            affordances to concrete network protocols (the
            communication metadata), the <em>public</em> security data
            needed by authorized users to understand how to access the
            <a>Thing</a>, and other general metadata such as IDs, names, and
            descriptions. The <a>Binding Templates</a> are another WoT building
            block that gives guidance on how to provide the correct
            communications metadata in a TD to support
            specific target protocols.
        </p>
        <p> The interaction implementation specifies how a <a>Thing</a>
            actually responds to an interaction, including how state is
            stored and modified. The behavior implementation specifies
            how other behavior of a <a>Thing</a> is implemented, which may or
            may not be directly related to an interaction. For example,
            a thermostat may need to execute a control loop to control a
            furnace based on a sensor reading. This does not directly
            relate to a specific interaction, although it might be
            controlled by a property (such as target temperature) that
            can be modified by an interaction.
        </p>
        <p> For specifying behavior and interaction implementations, an
            optional <a>WoT Scripting API</a> building block is provided which
            supports the definition and consumption of <a>WoT Thing
            Descriptions</a>. This is useful to define application behavior
            using an easy-to-use scripting language. It is however
            possible to implement a <a>Thing</a> <em>without</em> using the
            <a>WoT Scripting API</a>. In this case the externally visible
            interactions and network interface still needs to be
            consistent with the <a>Thing Description</a> defined for the <a>Thing</a>.
        </p>
        <p> Internally to a <a>Thing</a>, it is also generally important to
            provide secure storage for <em>private</em> security data
            such as encryption keys and identity material. This information is
            never directly shared with entities outside the <a>Thing</a>, and ideally
            should not even be directly accessible to the behavior and interaction
            implementations. Instead an abstract set of operations
            should support security functions such as signing,
            authorization, certificate validation, as well as encryption and
            decryption. Technology such as asymmetric public encryption
            schemes are generally used to provide these functions
            without disclosing the secret private security data. 
        </p> 
        <p> In general it is considered a security
            best practice to explicitly manage secrets in a form that is
            easily updated if necessary, and to keep them clearly
            separated from public information. In particular storing secrets as random
            numeric values rather than attempting to obfuscate the
            implementation or network interface is strongly recommended.
            If a numeric value is disclosed it is easily changed.
            This is not true of an implementation or network interface.
        </p>
        <p> In the following sections we will provide additional
            information on each WoT Building Block:
            the <a href="#sec-thing-description">WoT Thing
            Description</a>, the <a href="#sec-binding-templates">WoT Binding Templates</a>,
            and the <a href="#sec-scripting-api">WoT Scripting API</a>.
            Security, although it is a cross-cutting concern, can
            be considered a fourth building block.
        </p>

        <section id="sec-thing-description">
            <h2>WoT Thing Description</h2>
            <p> The <a>WoT Thing Description</a> (TD) specification
                [[!wot-thing-description]] defines an <em>information model</em>
                based on a semantic vocabulary and a <em>serialized
                representation based on JSON</em>. <a>TDs</a> provide rich metadata
                for <a>Things</a> in a way that is both human-readable and
                machine-understandable. Both the information model and
                the representation format of <a>TDs</a> are aligned with Linked
                Data [[?LINKED-DATA]], so that besides raw JSON
                processing, implementations may choose to make use of
                JSON-LD [[?JSON-LD11]] and graph databases to enable
                powerful semantic processing of the metadata.
            </p>
            <p> A <a>Thing Description</a> (TD) describes <a>Thing</a>
                instances with general metadata such as name, ID,
                descriptions, and also can provide relation metadata
                through links to related <a>Things</a> or other documents. <a>TDs</a>
                also contain interaction affordance metadata based on
                the interaction model defined in <a
                    href="#sec-interaction-model"></a>; public security
                configuration metadata; and communications metadata
                defining protocol bindings. The <a>TD</a> can be seen as the <em>index.html
                for <a>Things</a></em>, as it provides the entry point to learn
                about the provided services and related resources, both
                of which are described using hypermedia controls.
            </p>
            <p> Ideally, the <a>TD</a> is created and/or hosted by the <a>Thing</a>
                itself and retrieved upon discovery. Yet it can also be
                hosted externally when a <a>Thing</a> has resource restrictions
                (e.g., limited memory space, limited power) or when an existing device
                is retrofitted to become part of the Web of Things. A
                common pattern to improve discovery (e.g., for constrained devices) and to
                facilitate device management is to register <a>TDs</a> with a directory. 
                It is recommended that Consumers use a <a>TD</a> caching mechanism combined with
                a notification mechanism, which will inform them when it is required to fetch 
                a new version of the <a>TD</a>, in case the <a>Thing</a> is updated.
            </p>
            <p> For semantic interoperability, <a>TDs</a> may make use
                of a domain-specific vocabulary, for which explicit
                extension points are provided. However, development of
                any particular domain-specific vocabulary is currently
                out-of-scope of the W3C WoT standardization activity.
            </p>
            <p> Three examples of potentially useful external IoT
                vocabularies are SAREF [[?SAREF]], iot.schema.org
                [[?iot-schema-org]], and the W3C Semantic Sensor Network
                ontology [[?vocab-ssn]]. Use of such external vocabularies in <a>TDs</a> is
                optional. In the future additional domain-specific
                vocabularies may be developed and used with <a>TDs</a>.
            </p>
            <p> Overall, the <a>WoT Thing Description</a> building block
                fosters interoperability in two ways: First, <a>TDs</a>
                enable machine-to-machine communication in the Web of
                Things. Second, <a>TDs</a> can serve as a common,
                uniform format for developers to document and retrieve
                all the details necessary to create applications that
                can access IoT devices and make use of their data.
            </p>
        </section>
        <section id="sec-binding-templates" class="informative">
            <h3>WoT Binding Templates</h3>
            <p> The IoT uses a variety of protocols for accessing
                devices, since no single protocol is appropriate in all
                contexts. Thus, a central challenge for the Web of
                Things is to enable interactions with the plethora of
                different <a>IoT platforms</a> (e.g., OCF, oneM2M, OMA
                LWM2M, OPC UA) and devices that do not follow any
                particular standard, but provide an eligible interface
                over a suitable network protocol. WoT is tackling this
                variety through <a>Protocol Bindings</a>, which must meet a
                number of constraints (see <a href="#sec-protocol-bindings"></a>).
            </p>
            <p> The non-normative <a>WoT Binding Templates</a> specification
                [[?wot-binding-templates]] provides a collection of
                communication metadata blueprints that give guidance on
                how to interact with different <a>IoT platforms</a>.
                When describing a particular IoT device or service,
                the <a>Binding Template</a> for the corresponding <a>IoT Platform</a>
                can be used to look up the communication metadata that
                must be provided in the <a>Thing Description</a> to
                support that platform.
            </p>
            <figure id="fig-binding-templates">
                <img src="images/bblocks/binding-templates.png"
                     class="wot-arch-diagram" />
                <figcaption>From Binding Templates to Protocol Bindings</figcaption>
            </figure>
            <p> <a href="#fig-binding-templates"></a> shows how <a>Binding
                Templates</a> are applied. A <a>WoT Binding Template</a>
                is created only once for each <a>IoT Platform</a> and
                can then be reused in all <a>TDs</a> for devices of that
                platform. The <a>Consumer</a> that is processing a <a>TD</a> must implement
                the required <a>Protocol Binding</a> by including a
                corresponding protocol stack and by configuring the
                stack (or its messages) according to the information
                given in the <a>TD</a>. 
            </p>
            <p>    
                The communication metadata of
                <a>Protocol Bindings</a> spans five dimensions:
            </p>
            <ul>
                <li><b>IoT Platform:</b> 
                <p><a>IoT Platforms</a> often
                    introduce proprietary modifications at the
                    application layer such as platform-specific HTTP
                    header fields or CoAP options. Forms (see <a
                    href="#sec-hypermedia-forms"></a>) may contain the
                    necessary information to apply these tweaks in
                    additional form fields defined for the
                    application-layer protocol used.</p></li>
                <li><b>Media Type:</b> 
                <p><a>IoT Platforms</a> often
                    differ in the representation formats (a.k.a.
                    serializations) used for exchanging data. The Media
                    Type [[!RFC6838]] identifies these formats, while
                    parameters may specify them further. Forms may
                    contain the Media Type and optional parameters in
                    additional form fields such as a content type field known from HTTP,
                    which combines Media Type and other optional parameters 
                    (e.g., <code>text/plain; charset=utf-8</code>).</p></li>
                <li><b>Transfer Protocol:</b> 
                <p>The Web of Things
                    uses the term <a>transfer protocol</a> for the
                    underlying, standardized application-layer protocol
                    without application-specific options or <a>subprotocol</a>
                    mechanisms. The URI scheme of the form (submission)
                    target contains the information required to
                    identify the <a>transfer protocol</a>, e.g., HTTP, CoAP, or
                    WebSockets.</p></li>
                <li><b>Subprotocol:</b> 
                <p><a>Transfer protocols</a> may have
                    extension mechanisms that must be known to interact
                    successfully. Such <a>subprotocols</a> cannot be
                    identified from the URI scheme and must be declared
                    explicitly. Examples are the push notification
                    workarounds for HTTP such as long polling
                    [[?RFC6202]] or Server-Sent Events [[?EVENTSOURCE]].
                    Forms may contain the necessary information to
                    identify the <a>subprotocol</a> in additional form fields.</p></li>
                <li><b>Security:</b> 
                <p>Security mechanisms can be
                    applied at different layers of the communication
                    stack and might be used together, often to
                    complement each other. Examples are (D)TLS
                    [[?RFC8446]]/[[?RFC6347]], IPSec [[?RFC4301]], OAuth
                    [[?RFC6749]], and ACE [[?RFC7744]]. Due to the
                    cross-cutting nature of security, the necessary
                    information to apply the right mechanism may be
                    given within the general metadata of the <a>Thing</a>.</p></li>
            </ul>
        </section>
        <section id="sec-scripting-api" class="informative">
            <h3>WoT Scripting API</h3>
            <p> The <a>WoT Scripting API</a> is an optional "convenience"
                building block of W3C WoT that eases IoT application
                development by providing an ECMAScript-based API [[ECMAScript]] similar
                to the Web browser APIs.
                By integrating a scripting runtime system into the <a>WoT Runtime</a>,
                the <a>WoT Scripting API</a> enables using portable application scripts
                that define the behavior of <a>Things</a>, <a>Consumers</a>,
                and <a>Intermediaries</a>.
            </p>
            <p> Traditionally, IoT device logic is implemented in
                firmware, which results in productivity constraints
                similar to that of embedded development, including a
                relatively complex update process. The <a>WoT
                Scripting API</a> in contrast supports enables
                implementing device logic by reusable scripts executed
                in a runtime system for IoT applications not dissimilar
                to that of a Web browser, and aims to improve
                productivity and reduce integration costs. Furthermore,
                standardized APIs enable portability for application
                modules, for instance, to move compute-intense logic
                from a device up to a local gateway, or to move
                time-critical logic from the cloud down to a gateway or
                edge node.
            </p>
            <p> The non-normative <a>WoT Scripting API</a> specification [[?wot-scripting-api] defines
                the structure and algorithms of the programming
                interface that allows scripts to discover, fetch, consume,
                produce, and expose <a>WoT Thing Descriptions</a>. The
                runtime system of the <a>WoT Scripting API</a> instantiates local
                objects that act as an interface to other <a>Things</a> and
                their <a>Interaction Affordances</a> (<a>Properties</a>,
                <a>Actions</a>, and <a>Events</a>). It also allows scripts to expose
                <a>Things</a>, that is, to define and implement <a>Interaction
                Affordances</a> and publish a <a>Thing Description</a>.
            </p>
        </section>
        <section id="sec-security-guidelines" class="informative">
            <h3>WoT Security and Privacy Guidelines</h3>
            <p> Security is a cross-cutting concern and should be
                considered in all aspects of system design. In the WoT
                architecture, security is supported by certain explicit
                features, such as support for public security metadata in <a>TDs</a>
                and by separation of concerns in the design of the
                <a>WoT Scripting API</a>. The specification for each building
                block also includes a discussion of particular security
                and privacy considerations of that building block.
                Another non-normative specification, the 
                <em>WoT Security and Privacy Considerations</em> [[?wot-security]], 
                provides additional cross-cutting security and privacy guidance.
            </p>
        </section>
    </section>

    <section id="sec-servient-implementation" class="informative">
        <h1>Servient Implementation</h1>
        <p>
            A <a>Servient</a> is a software stack that implements the WoT building blocks presented in the previous section.
            <a>Servients</a> can host and expose <a>Things</a> and/or consume <a>Things</a> (i.e., host <a>Consumers</a>).
            Depending on the <a>Protocol Binding</a>,
            <a>Servients</a> can perform in both server and client role,
            hence the portmanteau naming.
        </p>
        <p>
            The previous section describes how the WoT building blocks conceptually relate to each other
            and how they correspond to the abstract WoT Architecture (see <a href="#sec-wot-architecture"></a>).
            When implementing these concepts,
            a more detailed view is necessary that takes certain technical aspects into account.
            This section presents the detailed architecture of a <a>Servient</a> implementation.
        </p>
        <p>
            <a href="#architecture-implementation"></a> shows a <a>Servient</a> implementation using the (optional) <a>WoT Scripting API</a> building block.
            Here, the <a>WoT Runtime</a>, which manages the WoT-specific aspects,
            is also a scripting runtime system that is able to interpret and execute application scripts.
            <a>Servients</a> with the <a>WoT Scripting API</a> usually run on powerful devices, edge nodes, or in the cloud.
            There are, however, also scripting environments for resource-constrained systems.
            Furthermore, the WoT Architecture does not limit the application-facing API of the <a>WoT Runtime</a> to JavaScript/ECMAScript.
        </p>
        <p>
            <a href="#native-impl"></a> presents an alternative <a>Servient</a> implementation without the <a>WoT Scripting API</a> building block.
            The <a>WoT Runtime</a> may use any programming language for its application-facing API.
            Usually, it is the native language of the <a>Servient</a> software stack,
            for instance C/C++ for embedded <a>Servients</a> or Java for cloud-based <a>Servient</a>.
            It may also be an alternative scripting langague such as Lua to combine the benefits of application scripts with low resource consumption.
        </p>
        <figure id="architecture-implementation">
            <img src="images/servient/wot-thing-scripting.png"
                 class="wot-arch-diagram" />
            <figcaption>Implementation of a Servient Using the Optional WoT Scripting API</figcaption>
        </figure>
        <p>
            The role and functionality of each internal module shown
            in <a href="#architecture-implementation"></a> is given in
            the following sections.
        </p>
        <section>
            <h2>Behavior Implementation</h2>
            <p>
                The behavior defines the overall application logic and includes
                autonomous behavior of <a>Things</a> (e.g., sampling of sensors or control loops for actuators),
                the handlers for <a>Interaction Affordances</a> (i.e., the concrete actions taken when an affordance is activated),
                <a>Consumer</a> behavior (e.g., controlling a <a>Thing</a> or realizing mashups), and
                <a>Intermediary</a> behavior (e.g., simply proxying a <a>Thing</a> or composing virtual entities).
                The behavior implementation within a <a>Servient</a> defines
                which <a>Things</a>, <a>Consumers</a>, and <a>Intermediaries</a> are hosted on this component.
            </p>
            <p>
                <a href="#architecture-implementation"></a> focuses on <a>Servients</a> implementing the optional <a>WoT Scripting API</a> building block,
                where portable application scripts written in JavaScript [[ECMAScript]] define the behavior.
                They are executed by a scripting runtime system that is part of the <a>WoT Runtime</a>
                (when providing the <a>WoT Scripting API</a> or any other script-based API).
                They are portable, as they are written against the common <a>WoT Scripting API</a> definitions,
                and hence can be executed by any <a>Servient</a> featuring this building block.
                This makes it possible to migrate certain application logic between system components,
                for instance moving a <a>Consumer</a> from the cloud to an edge node to meet networking requirements,
                or move an <a>Intermediary</a> to the cloud to fulfill growing resource demands.
                The portability can also foster <a>Thing</a> customization by installing behavior following the app concept known from smartphones.
            </p>
            <p>
                See <a href="#native-impl"></a> for behavior implementation without the <a>WoT Scripting API</a> building block.
                In principle, any programming language and API can be used in order to define the behavior of a Thing,
                as long as the <a>Interaction Affordances</a> are presented externally through a <a>WoT Interface</a>.
                The adaption between application-facing API and the protocol stack is handled by the <a>WoT Runtime</a>.
            </p>
        </section>
        <section>
            <h2>WoT Runtime</h2>
            <p>
                Technically, the <a>Thing</a> abstraction and its <a>Interaction Model</a> is implemented in a runtime system.
                This <a>WoT Runtime</a> maintains the execution environment for the behavior implementation and is able to expose and/or consume <a>Things</a>,
                and hence must be able to fetch, process, serialize, and serve <a>WoT Thing Descriptions</a>.
            </p>
            <p>
                Every <a>WoT Runtime</a> has an application-facing interface (i.e., an API) for the behavior implementation.
                The optional <a>WoT Scripting API</a> building block shown in <a href="#architecture-implementation"></a>
                defines such an application-facing interface that follows the <a>Thing</a> abstraction
                and enables the deployment of behavior implementations during runtime through application scripts.
                See <a href="#native-impl"></a> for alternative APIs, which can also only be available during compile time.
                In general, application logic should be executed in isolated execution environments
                to prevent unauthorized access to the management aspects of the <a>WoT Runtime</a>,
                in particular the private security configuration.
                In multi-tenant <a>Servients</a>, additional execution environment isolation is required for the different tenants.
            </p>
            <p>
                A <a>WoT Runtime</a> needs to provide certain operations to manage the lifecycle of <a>Things</a>,
                or more precicely their software abstractions and descriptions.
                The details of such operations vary among different implementations.
                A lifecycle management (LCM) system may encapsulate those lifecycle operations within a <a>Servient</a>
                and use internal interfaces to realize the lifecycle management.
                The <a>WoT Scripting API</a> includes LCM functionality, and hence represents one possible implementation of such a system.
            </p>
            <p>
                The <a>WoT Runtime</a> must interface with the protocol stack implementation of the <a>Servient</a>,
                as it decouples the behavior implementation from the details of the <a>Protocol Bindings</a>.
                The <a>WoT Runtime</a> usually also interfaces with the underlying system,
                for instance, to access local hardware such as attached sensors and actuators or to access system services such as storage.
                Both interfaces are implementation-specific,
                yet the <a>WoT Runtime</a> must provide the necessary adaption to the implemented <a>Thing</a> abstraction.
            </p>
        </section>
        <section>
            <h3>WoT Scripting API</h3>
            <p>
                The <a>WoT Scripting API</a> building block defines an ECMAScript API that closely follows the <a>WoT Thing Description</a> specificiation [[wot-thing-description]].
                It defines the interface between behavior implementations and a scripting-based <a>WoT Runtime</a>.
                Other, simpler APIs may be implemented on top of it,
                similar to, for instance, jQuery for the Web browser APIs.
            </p>
            <p>
                See [[?wot-scripting-api]] for more details.
            </p>
        </section>
        <section>
            <h2>Exposed Thing and Consumed Thing Abstractions</h2>
            <p>
                The <a>WoT Runtime</a> instantiates software representations of <a>Things</a> based on their <a>TDs</a>.
                These software representations provide the interface toward the behavior implementation,
                but also toward the underlying protocol stack implementation and system API.
            </p>
            <p>
                The <a>Exposed Thing</a> abstraction represents a <a>Thing</a> hosted locally
                and accessible from the outside through the protocol stack implementation of the <a>Servient</a>.
                The behavior implementation can fully control <a>Exposed Things</a> by defining their metadata and <a>Interaction Affordances</a>,
                and providing their autonomous behavior.
            </p>
            <p>
                The <a>Consumed Thing</a> abstraction represents a remotely hosted <a>Thing</a> for <a>Consumers</a> that needs to be accessed using a communication protocol.
                <a>Consumed Things</a> are proxy objects or stubs.
                The behavior implementation is restricted to reading their metadata and activating their <a>Interaction Affordances</a> as described in the corresponding <a>TD</a>.
                <a>Consumed Things</a> can also represent system features such as local hardware or devices behind proprietary or legacy communication protocols.
                In this case, the <a>WoT Runtime</a> must provide the necessary adaptation between system API and <a>Consumed Thing</a>.
                Furthermore, it must provide corresponding <a>TDs</a> and make them available to the behavior implementation,
                for instance, by extending whatever discovery mechanism is provided by the <a>WoT Runtime</a> through the application-facing API
                (e.g., the <code>discover()</code> method defined in the <a>WoT Scripting API</a> [[?wot-scripting-api]]).
            </p>
            <p>
                When using the <a>WoT Scripting API</a>, <a>Exposed Thing</a> and <a>Consumed Thing</a> are JavaScript objects,
                which can be created, operated on, and destroyed by application scripts.
                However, access my be restricted through a security configuration,
                for instance, in multi-tenant <a>Servients</a>.
            </p>
        </section>
        <section>
            <h2>Private Security Configuration</h2>
            <p>
                Private security metadata is also conceptually
                managed by the <a>WoT Runtime</a> but is intentionally not made
                directly accessible to the application. In fact, in the
                most secure hardware implementations, such private
                security data is stored in a separate, isolated memory
                (e.g., on a secure element or TPM)
                and only an abstract set of operations (possibly even
                implemented by an isolated processor and software stack)
                is provided that limit the attack surface and prevent
                external disclosure of this data. Private security data
                is used transparently by the <a>Protocol Binding</a> to
                authorize and protect the integrity and confidentiality
                of interactions.
            </p>
        </section>
        <section>
            <h2>Protocol Stack Implementation</h2>
            <p>
                The protocol stack of a <a>Servient</a> implements the <a>WoT Interface</a> of the <a>Exposed Things</a>
                and is used by <a>Consumers</a> to access the <a>WoT Interface</a> of remote <a>Things</a> (via <a>Consumed Things</a>).
                It produces the concrete protocol messages to interact over the network.
                <a>Servients</a> may implement multiple protocols, and hence support multiple <a>Protocol Bindings</a> to enable interaction with different <a>IoT Platforms</a>.
            </p>
            <p> In many cases, where standard protocols are used,
                generic protocol stacks can be used to produce the
                platform-specific messages (e.g., one for HTTP(S)
                dialects, one for CoAP(S) dialects, and one for MQTT
                solutions, etc.). In this case, the communication
                metadata from the <a>Thing Description</a> is used to
                select and configure the right stack (e.g., HTTP with
                the right header fields or CoAP with the right options).
                Parsers and serializers for the expected payload representation
                format (JSON, CBOR, XML, etc.)
                as identified by the Internet Media Type can also be
                shared across these generic protocol stacks.
            </p>
            <p>
                See [[?wot-binding-templates]] for details.
            </p>
        </section>
        <section>
            <h2>System API</h2>
            <p>
                A given implementation of a <a>WoT Runtime</a>
                may provide local hardware or system services to
                behavior implementations through the <a>Thing</a>
                abstraction, as if they were accessible over a communication
                protocol. In this case, the <a>WoT Runtime</a> should
                enable the behavior implementation to instantiate <a>Consumed Things</a>
                that internally interface with the system instead of the protocol stack.
                This can be done by listing such system Things, which are only available in the local <a>WoT Runtime</a>,
                in the results of the discovery mechanism provided by the application-facing <a>WoT Runtime</a> API.
            </p>
            <p>
                A device may also be physically external to a <a>Servient</a>,
                but connected via a proprietary protocol or a protocol
                not eligible as <a>WoT Interface</a> (see <a href="#sec-protocol-bindings"></a>).
                In this case, the <a>WoT Runtime</a> may
                access legacy devices with such protocols (e.g., Echonet
                Lite, BACNET, X10, I2C, SPI, etc.) through proprietary APIs,
                but may again choose to expose them to the behavior implementation via
                a <a>Thing</a> abstraction. A <a>Servient</a> can then act
                as gateway to the legacy devices. This should only be
                done if the legacy device cannot be described directly
                using a <a>WoT Thing Description</a>.
            </p>
            <p>
                The behavior implementation may also access local
                hardware or system services (e.g., storage) through a
                proprietary API or other means. This is, however, out of
                scope of the W3C WoT standardization, as it hinders portability.
            </p>
        </section>
        <section id="alt-servient-impl">
            <h3>Alternative Servient and WoT Implementations</h3>
            <p>
                The <a>WoT Scripting API</a> building block is optional.
                Alternative <a>Servient</a> implementations are possible,
                where the <a>WoT Runtime</a> offers an alternative API for the application logic,
                which may be written in any programming language.
            </p>
            <p>
                Furthermore, devices or services unaware of W3C WoT can still be consumed,
                when it is possible to provide a well-formed <a>WoT Thing Description</a> for them.
                In this case, the <a>TD</a> describes a <a>WoT Interface</a> of a <a>Thing</a> that has a black-box implementation.
            </p>
            <section id="native-impl">
                <h3>Native WoT API</h3>
                <p>
                    There are various reasons why a developer may choose
                    to implement a <a>Servient</a> without using the <a>WoT
                        Scripting API</a>. This may be due to insufficient
                    memory or computing resources, so the developer cannot use
                    the required software stack or a fully-featured scripting
                    engine. Alternatively, to support their use case (for
                    example, a proprietary communications protocol)
                    the developer may have to use
                    specific functions or libraries only available
                    through a particular programming environment or
                    language.
                </p>
                <p>
                    In this case, a <a>WoT Runtime</a> can still be
                    used, but with an equivalent abstraction and functionality
                    exposed using an alternative application-facing interface instead of
                    the <a>WoT Scripting API</a>
                    Except for the latter, all block descriptions in <a href="#sec-servient-implementation"></a>
                    are also valid for <a href="#architecture-implementation-native"></a>.
                </p>
                <figure id="architecture-implementation-native">
                    <img src="images/servient/wot-thing-native.png" 
                         class="wot-arch-diagram" />
                    <figcaption>Implementation of a Servient Using a Native WoT API</figcaption>
                </figure>
            </section>
            <section id="existing-impl">
                <h3>Existing Device Described with a Thing Description</h3>
                <p>
                    It is also possible to integrate <em>existing</em> IoT devices
                    or services into the W3C Web of Things and to use them as <a>Things</a>
                    by creating a <a>Thing Description</a> for these devices or services.
                    Such a TD can either be created manually or via a tool or service.
                    For example, a TD could be generated by a service that provides
                    automatic translation of metadata provided by another,
                    ecosystem-dependent machine-readable format.
                    This can only be done, however, if the target device
                    is using protocols that can be described using a <a>Protocol Binding</a>.
                    The requirements for this are given in <a href="#sec-protocol-bindings"></a>
                    Much of the previous discussion also implies that a <a>Thing</a>
                    provides its own <a>Thing Description</a>.  While this
                    is a useful pattern it is not mandatory.
                    In particular, it may not be possible to modify
                    existing devices to provide their
                    own <a>Thing Description</a> directly.  In this case the
                    <a>Thing Description</a> will have to be provided
                    separately using a service such as a directory
                    or some other external and separate distribution mechanism.
                </p>
                <figure id="architecture-implementation-existing">
                    <img src="images/servient/wot-thing-existing.png" 
                         class="wot-arch-diagram" />
                    <figcaption>Integration of Existing IoT Devices into W3C WoT</figcaption>
                </figure>
            </section>
        </section>
    </section>

    <section id="sec-deployment-scenario" class="informative">
        <h1>WoT Deployments</h1>

        <p> This section discusses how the Web of Things as a whole works
            when <a>Things</a> and <a>Consumers</a> implemented as devices and services are
            connected together in various topologies and deployment scenarios.
        </p>
        <p>
            Before discussing specific topologies, we will
            first review the roles that <a>Things</a> and <a>Consumers</a> can
            play in a WoT network and the relationships they have with the
            <a>Exposed Thing</a> and <a>Consumed Thing</a> software abstractions.
            <a>Exposed Thing</a> and <a>Consumed Thing</a> are internally available
            to the behavior implementations of <a>Servients</a>
            in the roles of <a>Things</a> and <a>Consumers</a>, respectively.
        </p>

        <section id="sec-client-server-roles">
            <h2>Thing and Consumer Roles</h2>
            <p> A <a>Servient</a> in the role of a <a>Thing</a> creates an
                <a>Exposed Thing</a> based on a <a>Thing Description</a> (TD).
                TDs are published and made available to other <a>Servients</a>
                that are in the roles of <a>Consumers</a> or <a>Intermediaries</a>.
                Publications of TDs may be done in various different ways: the TD
                might be registered with a management system such as
                the <a>Thing Directory</a> service, or a <a>Thing</a>
                may provide the requesters with a TD upon receiving a request for a TD.
                It is even possible to statically associate a TD with <a>Thing</a>
                in certain application scenarios.
            </p>
            <p> A <a>Servient</a> in the role of a <a>Consumer</a> obtains the TD of a <a>Thing</a>
                using a discovery mechanism implemented in the individual deployment scenarios
                (such as a management system such as <a>Thing Directory</a>, discovery protocol,
                 static assignment, etc. as stated above)
                and creates a <a>Consumed Thing</a> based on the obtained TD.
                Internal system functions of a device such as attached sensors and actuators
                can also optionally be represented as <a>Consumed Thing</a> abstractions.
            </p>
            <p>The functions supported by the <a>Consumed Thing</a> are provided internally
               to the <a>Consumer</a>'s behavior implementation through a programming language
               interface. In the <a>WoT Scripting API</a>, <a>Consumed Things</a>
               are represented by objects.
               The behavior implementation (that is, the application logic) running in
               a <a>Thing</a> can engage in interactions with <a>Consumers</a> by using
               the programming language interface provided by the <a>Exposed Thing</a>.
            </p>
            <p> A <a>Thing</a> may not necessarily represent a physical device.
                <a>Things</a> can also represent a collection of devices, or virtual services
                running in a gateway or in the cloud.
                Likewise, a <a>Consumer</a> may or may not represent
                an application service running on a gateway or cloud.
                <a>Consumers</a> can also be implemented on edge devices.
                In <a>Intermediaries</a>, a single <a>Servient</a>
                simultaneously performs both the roles of a <a>Thing</a> and a <a>Consumer</a>
                sharing a single <a>WoT Runtime</a>.
            </p>
        </section>
        <section id="sec-topologies-deployment-scenarios">
            <h2>WoT System's Topologies and Deployment Scenarios</h2>
            <p>Various topologies and deployment scenarios of WoT systems are discussed in this section.
            These are only example patterns. Other interconnection topologies are also possible.
            The interconnection topologies described here are derived from the Web of Things use cases
            (<a href="#sec-use-cases"></a>)
            as well as the technical requirements extracted from them
            (<a href="#sec-requirements"></a>).
            </p>
        <section id="sec-deployment-app-dev">
            <h2>Consumer and Thing on the Same Network</h2>
            <p> In the simplest interconnection topology, illustrated by <a href="#simple-conf-application-device"></a>,
                the <a>Consumer</a> and <a>Thing</a> are on the same network and can communicate
                directly with each other without any intermediaries.
                One use case where this topology arises is when the <a>Consumer</a> is an orchestration
                service or some other IoT application running on a gateway and the <a>Thing</a> is a device interfacing to
                a sensor or an actuator.  However, the client/server relationship could easily be reversed;
                the client could be a device in the <a>Consumer</a> role accessing
                a service running as a <a>Thing</a> on a gateway or in the cloud.
            </p>
            <figure id="simple-conf-application-device">
                <img src="images/deployments/arch-simple-conf-consumer-thing.png" 
                     class="wot-arch-diagram" />
                <figcaption>Consumer and Thing on the Same Network</figcaption>
            </figure>
            <p> If the <a>Thing</a> is in the cloud and the <a>Consumer</a> is on a local network
                (see <a href="#smart-home"></a> for an example in a Smart Home use case) the actual network topology may be more complex,
                for example requiring NAT traversal and disallowing certain forms of discovery.
                In such cases one of the more complex
                topologies discussed later may be more appropriate.
            </p>
        </section>
        <section id="sec-deployment-app-proxy-dev">
            <h2>Intermediary Acting as a Proxy</h2>
            <p> A <a>Intermediary</a> plays both <a>Thing</a> and
                <a>Consumer</a> roles on the network and supports
                both the <a>Exposed Thing</a> and <a>Consumed Thing</a>
                software abstractions within its <a>WoT Runtime</a>.
            </p>
            <p> One simple application of a <a>Intermediary</a> is as a Thing proxy.
                When functioning as a Thing proxy,
                the <a>Intermediary</a> generally interfaces with two separate
                networks or protocols.  This may involve
                the implementation of additional security mechanisms
                such as providing TLS endpoints.  Generally proxies
                do not modify the set of interactions so the TD exposed
                by the <a>Intermediary</a> will have the same interactions
                as the consumed TD but with the connection metadata modified.
            </p>
            <p> To implement this pattern, the proxy <a>Intermediary</a> obtains a TD
                of a <a>Thing</a> and creates a <a>Consumed Thing</a>.
                It creates a proxy object of the <a>Thing</a> as a software
                implementation that has the same <a>Interaction Affordances</a>.
                It then creates a TD for the proxy object with a new identifier
                and possibly with new communications metadata (protocol bindings)
                and/or new public security configuration metadata.
                Finally, an <a>Exposed Thing</a> is
                created based on this TD, and the <a>Intermediary</a> notifies other
                <a>Consumers</a> or <a>Intermediaries</a> of the TD via
                an appropriate publication mechanism.
            </p>
            <figure id="simple-conf-application-proxy-device">
                <img
                    src="images/deployments/arch-simple-conf-consumer-intermediary-thing.png"
                    class="wot-arch-diagram" />
                <figcaption>Consumer and Thing Connect via a Intermediary Acting as a Proxy</figcaption>
            </figure>
            <p> More complex <a>Intermediaries</a> may be known as <a>digital twins</a>.
                A <a>digital twins</a> may or may not modify the protocols or
                translate between networks, but they provide additional
                services, such as state caching, deferred updates,
                or even predictive simulation of the behavior of the target device.
                For example, if an IoT device has limited power, it
                may choose to wake up relatively infrequently, synchronize
                with a <a>digital twins</a>, and then immediately go to sleep again.
                In this case, assume the <a>digital twins</a> runs on a less power-constrained
                device (such as in the cloud or on a gateway)
                and is able to respond to interactions on the
                constrained device's behalf.
                Requests for the current state of properties
                may also be satisfied by the <a>digital twins</a> using cached state.
                Requests that arrive when the target IoT device is sleeping
                may be queued and sent to it when it wakes up.
                One complication with implementing this pattern is that the
                <a>Intermediary</a> that is a <a>digital twins</a> needs to know when the device is awake where
                the device is implemented as a <a>Thing</a>.  The actual implementation
                may needs to be augmented with a notification mechanism (which could
                be implemented using a separate <a>Consumer</a>/<a>Thing</a> pair),
                although it may also be possible to use <a>Event</a> interactions for this
                purpose.
            </p>
        </section>

        <section id="sec-deployment-cloud-rm">
            <h2>Devices in a Local Network Controlled from a Cloud Service</h2>
            <p> In Smart Home use cases, devices (sensors and home appliances)
                connected to a home network are often
                monitored and, in some cases, also controlled by cloud
                services. There is usually a NAT device between the home
                network to which the devices are connected and the cloud.
                The NAT device translates IP addresses as well as often providing
                firewall services, which block connections selectively.
                The local devices and cloud services can only communicate
                with each other if the communication can successfully
                traverse the gateway.
            </p>
            <p> A typical structure,
                adopted in ITU-T Recommendation Y.2070 [[?Y.2070]] ,
                is shown in <a href="#deployment-cloud-device"></a>.
                In this structure there is both a local and a remote <a>Intermediary</a>.
                The local <a>Intermediary</a> aggregates the <a>Interaction Affordances</a> from multiple
                <a>Thing</a> into a (set of) <a>Exposed Things</a>,
                which can all be mapped onto a common protocol
                (for example, HTTP, with all interactions mapped to a single
                URL namespace with a common base server and using a single port).
                This provides the remote <a>Intermediary</a> with a simple way to
                access all the <a>Things</a> behind the NAT device,
                assuming the local <a>Intermediary</a>
                has used a converged protocol that can traverse the NAT device
                and has some way to expose this service to the Internet (STUN, TURN, DyDNS, etc).
                In addition, the local <a>Intermediary</a> can function as a Thing proxy, so
                even when the connected <a>Things</a> each use a different
                protocol (HTTP, MQTT, CoAP, etc.) and/or a different set of
                ecosystem conventions, the
                <a>Exposed Thing</a> can converge them into a single protocol so
                that <a>Consumers</a> do not need to be aware of the various
                protocols the <a>Things</a> use.
            </p>
            <p> In <a href="#deployment-cloud-device"></a>, there are two
                clients connected to the remote <a>Intermediary</a>, which
                has aggregated the services that reside behind the NAT border and may
                provide additional protocol translation or security services.
                In particular, the local <a>Intermediary</a> may be on a network
                with limited capacity and making that service directly available to all
                users may not be feasible.  In this case access to the local
                <a>Intermediary</a> is <em>only</em> provided to the remote <a>Intermediary</a>.
                The remote <a>Intermediary</a> then implements a more general access
                control mechanism and may also perform caching or throttling to
                protect the consumer from excess traffic.
                Those consumers also will use a
                single protocol suitable for the open Internet (e.g. HTTPS) to communicate with the
                <a>Intermediary</a>, which makes the development of clients much
                simpler.
            </p>
            <p> In this topology there is NAT and firewall functionality between the consumers and things,
                but the local and remote <a>Intermediaries</a> work together to tunnel all communications
                through the firewall, so the consumers and things need to know
                nothing about the firewall.
                The paired <a>Intermediaries</a> also protect the home devices by providing
                access control and traffic management.
            </p>
            <figure id="deployment-cloud-device">
                <img src="images/deployments/arch-deploy-cloud-thing.png"
                     class="wot-arch-diagram" />
                <figcaption>Cloud Applications Implemented as Consumers Connected to
                    Local Devices implemented as Things via Paired Intermediaries</figcaption>
            </figure>
            <p> In more difficult cases the NAT and firewall traversal may not work exactly as
                shown. In particular, an ISP may not support publicly accessible addresses,
                or STUN/TURN and/or DyDNS may not be supported or available.
                In this case the <a>Intermediaries</a>
                may alternative reverse the client/server roles between them to set up an initial
                connection (with the local <a>Intermediary</a> first connecting to the remote <a>Intermediary</a>
                in the cloud), then the pair of <a>Intermediaries</a>
                may establish a tunnel (using for example, a Secure Web Socket, which uses TLS
                to protect the connection).
                The tunnel can then be used to encode all communications between the
                <a>Intermediaries</a> using a custom protocol.
                In this case the initial connection can still be made over HTTPS using standard
                ports, and from the local <a>Intermediary</a> to the remote <a>Intermediary</a> identically
                to a normal browser/web server interaction.
                This should be able to traverse most home firewalls, and since the connection
                is outgoing, network address translation will not cause any problems.
                However, even though a custom tunneling protocol is needed, the
                remote <a>Intermediary</a> can still translate this custom protocol back into
                standard external protocols.  The connected <a>Consumers</a> and <a>Things</a>
                do not need to know about it.
                It is also possible to extend this example to use cases where both <a>Things</a>
                and <a>Consumers</a> can connect on either side of the NAT boundary.
                This however also requires a bidirectional tunnel to be established between
                the two <a>Intermediaries</a>.
            </p>
        </section>
        <section id="sec-deployment-discovery-with-directory-rm">
            <h2>Discovery Using a Thing Directory</h2>
<!-- "application" and "device" are used intentionally here instead of client or server, since they
     might be either! -->
            <p> Once local devices (and possibly services)
                can be monitored or controlled by services
                on cloud, a variety of additional services can be built on top.
                For example, a cloud application could change a device's
                operating condition based on an analysis of collected data.
            </p>
            <p> However when the remote <a>Intermediary</a> is a part of a cloud platform
                servicing client applications, the clients need to be able to find
                device information by, for example, accessing a
                directory of connected devices.  For simplicity in the figure below
                we have assumed all local devices are implemented as <a>Things</a> and
                all cloud applications as <a>Consumers</a>.
                To make the metadata of local devices implemented as <a>Things</a>
                available to the cloud applications,
                their metadata
                can be registered with a <a>Thing Directory</a> service.
                This metadata is specifically the TDs of the local devices modified to
                reflect the security configuration and communication metadata
                provided by the remote <a>Intermediary</a>.
                A client application then can obtain the metadata
                it needs to communicate with local devices to
                achieve its functionality by querying the <a>Thing Directory</a>.
            </p>
            <figure id="deployment-cloud-directory">
                <img src="images/deployments/arch-deploy-service-directory.png"
                     class="wot-arch-diagram" />
                <figcaption>Cloud Service with Thing Directory</figcaption>
            </figure>
            <p> In more complex situations, not shown in the figure, there
                may also be cloud services that act as <a>Things</a>.
                These can also register themselves with the <a>Thing Directory</a>.
                Since a <a>Thing Directory</a> is a Web service, it should be visible
                to the local devices through the NAT or firewall device
                and its interface can even be provided with its own TD.
                Local devices acting as <a>Consumers</a> can then
                discover the <a>Things</a> in the cloud via the <a>Thing Directory</a>
                and connect to the <a>Things</a> directly or via the local
                <a>Intermediary</a> if, for instance, protocol translation is needed.
            </p>
        </section>
        <section id="sec-deployment-service-to-service-rm">
            <h2>Service-to-Service Connections Across Multiple Domains</h2>
            <p> Multiple cloud eco-systems each based on different
                IoT platforms can work together to make a larger,
                system-of-systems eco-system. Building on the previously
                discussed structure of a cloud application eco-system,
                the figure below shows two eco-systems connected to each
                other to make a system-of-systems. Consider the case in
                which a client in one eco-system (i.e., <a>Consumer</a> A
                below) needs to use a server in another eco-system
                (i.e., <a>Thing</a> B below).
                There is more than one mechanism to
                achieve this cross eco-systems application-device
                integration.
                Below, two mechanisms are
                explained, each using a figure, to show how this can be achieved.</p>
            <section id="sec-deployment-service-to-service-rm-synchronized">
                <h3>Connection Through Thing Directory Synchronization</h3>
                <p> In <a href="#deployment-service-sync-directory"></a>,
                    two <a>Thing Directories</a>
                    synchronize information, which makes it possible
                    for <a>Consumer</a> A to obtain the information of
                    <a>Thing</a> B through <a>Thing Directory</a> A. As described in
                    previous sections, remote <a>Intermediary</a> B maintains a shadow
                    implementation of <a>Thing</a> B.
                    By obtaining the TD of this shadow
                    device, <a>Consumer</a> A is able to use <a>Thing</a> B through the
                    remote <a>Intermediary</a> B.
                </p>
                <figure id="deployment-service-sync-directory">
                    <img src="images/deployments/arch-deploy-service-sync-directory.png"
                         class="wot-arch-diagram" />
                    <figcaption>Multiple Cloud Connections Through Thing
                        Directory Synchronization</figcaption>
                </figure>
            </section>
            <section id="sec-deployment-service-sync-proxy-rm">
                <h3>Connection Through Proxy Synchronization</h3>
                <p> In <a href="#deployment-service-sync-proxy"></a>, two remote <a>Intermediaries</a>
                    synchronize device information. When a shadow of <a>Thing</a>
                    B is created in remote <a>Intermediary</a> B, the shadow’s TD is
                    simultaneously synchronized into remote <a>Intermediary</a> A.
                    Remote <a>Intermediary</a> A in turn creates its own shadow of
                    <a>Thing</a> B, and registers the TD with <a>Thing Directory</a>
                    A. With this mechanism, synchronization between
                    <a>Thing Directories</a> is not necessary.
                </p>
                <figure id="deployment-service-sync-proxy">
                    <img src="images/deployments/arch-deploy-service-sync-intermediary.png"
                         class="wot-arch-diagram" />
                    <figcaption>Multiple Cloud Connections Through
                        Intermediary Synchronization</figcaption>
                </figure>
                </section>
            </section>
        </section>
    </section>

    <section id="sec-security-considerations" class="informative">
        <h1>Security and Privacy Considerations</h1>
        <p>
            Security is a cross-cutting issue that needs to be taken
            into account in all <a href="#sec-building-blocks">WoT
                building blocks</a> and WoT implementations. This chapter
            summarizes some general issues and guidelines to help
            preserve the security and privacy of WoT implementations.
            For a more detailed and complete analysis of security and
            privacy issues, see the <em>WoT Security and Privacy Considerations</em>
            specification [[?wot-security]].
        </p>
        <p>Overall, the goal of the WoT is to describe the existing
            access mechanisms and properties of IoT devices and
            services, including security. In general, W3C WoT is
            designed to describe what exists rather than to prescribe
            what to implement.
        </p>
        <p>
            However, the WoT architecture should <em>enable</em> the use
            of best practices in security and privacy. The WoT security
            architecture must support the goals and mechanisms of the
            IoT protocols and systems it connects to. These systems vary
            in their security requirements and risk tolerance, so
            security mechanisms will also vary based on these factors.
        </p>
        <p>Security and privacy are especially important in the IoT
            domain since IoT devices need to operate autonomously and in
            many cases have access to both personal data and/or can be
            in control of safety-critical systems. Compared to personal
            systems, IoT devices are subject to different and in some
            cases higher risks than IT systems. It is also important to
            protect IoT systems so that they can not be used to launch
            attacks on other computer systems.
        </p>
        <p>In general, security and privacy cannot be guaranteed. It
            is not possible for the WoT to turn an insecure system into
            a secure one. However, the WoT architecture needs to do
            no harm: it should support security and privacy at least as
            well as the systems it connects to.
        </p>
        <section id="sec-security-consideration-td-risks">
            <h2>WoT Thing Description Risks</h2>
            <p>
                The metadata contained in a <a>WoT Thing Description</a>
                (TD) is potentially sensitive. As a best practice, TDs
                should be used together with integrity protection
                mechanisms and access control policies, and should be
                provided only to authorized users.
            </p>
            <p>Please refer to the Security and Privacy
                Consideration section of the WoT Thing Description
                specification for additional details and discussion.</p>
            <section id="sec-security-consideration-td-private">
                <h5>Thing Description Private Security Data Risk</h5>
                <p>
                    TDs are designed to carry only public security data.
                    Producers of TDs must ensure that no private
                    security information is included in <a>TDs</a>.
                    There should be a strict separation of public and
                    private security data. A TD should contain only
                    public security information, letting Consumers know what
                    they need to do to access as system if and only if
                    they have authorization. Authorization in turn
                    should be based on separately managed private
                    information.
                </p>
                <p>The built-in TD security schemes defined in the
                    TD specification do not support the encoding of
                    private security data. However, there is a risk that
                    other fields such as
                    human-readable descriptions might be used
                    (incorrectly...) to encode this information, or new
                    security schemes might be defined and deployed via
                    the extension mechanism that encode such
                    information.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>Creators of TDs and extensions meant to be used in TDs
                        must ensure that no private
                        security data is ever stored in TDs.</dd>
                </dl>
            </section>
            <section id="sec-security-consideration-td-pii">
                <h5>Thing Description Personally Identifiable
                    Information Risk</h5>
                <p>Thing descriptions can potentially contain
                    <a>Personally Identifiable Information</a> of various
                    types. Even if it is not explicit, the presence of
                    semantic information in a TD and its association
                    with a person can be used to infer information about
                    that person. For example, the association of
                    uniquely identifiable TDs exposed by mobile devices
                    whose location can be determined can be a tracking
                    risk.
                </p>
                <p>Generally, personally identifiable information in
                    a TD should be limited as much as possible. In some
                    cases, however, it cannot be avoided. The potential
                    presence of PII in a TD means that TD should be
                    treated like other forms of PII. They should be
                    stored and transmitted in a secure fashion, should
                    only be cached for limited times, should be deleted
                    upon request, should only be used for the purpose
                    for which they were provided with user consent, and
                    they should otherwise satisfy local requirements
                    (including any legal requirements) for
                    the use of PII.</p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>Storage of PII in TDs should be minimized
                        as much as possible. Even without explicit PII
                        in TDs, a tracking and identification privacy
                        risk may exist. To minimize this risk, TDs
                        should generally be treated as if they contained PII and
                        subject to the same management policies as other
                        PII. They should only be provided to authorized
                        Consumers.</dd>
                </dl>
            </section>
            <section id="sec-security-consideration-td-cm">
                <h5>Thing Description Communication Metadata Risk</h5>
                <p>
                    The <a>WoT Binding Templates</a> must correctly
                    support the security mechanisms employed by the
                    underlying <a>IoT Platform</a> for that platform to
                    be considered eligible for use with WoT. Due to the
                    automation of network interactions necessary to
                    deploy IoT at scale, operators need to ensure that <a>Things</a>
                    are exposed and consumed in a way that is compliant
                    with their security policies.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        Whenever possible, TD creators should use the vetted communication
                        metadata provided in the <a>WoT Binding
                            Templates</a>. When generating TDs for an IoT
                        ecosystem not covered by the <a>WoT Binding
                            Templates</a>, ensure that all the security
                        requirements of the <a>IoT Platform</a> are
                        satisfied.
                    </dd>
                </dl>
            </section>
        </section>
        <section id="sec-security-consideration-scripting-risks">
            <h2>WoT Scripting API Security and Privacy Risks</h2>
            <p>
                The <a>WoT Runtime</a> implementation and the <a>WoT
                    Scripting API</a> should have mechanisms to prevent
                malicious access to the system and isolate scripts in
                multi-tenant <a>Servients</a> . More specifically the <a>WoT
                    Runtime</a> implementation when used with the <a>WoT
                    Scripting API</a> should take into account the following
                security and privacy risks and implement the recommended
                mitigations.
            </p>
            <section id="sec-security-consideration-cross-script">
                <h5>Cross-Script Security and Privacy Risk</h5>
                <p>
                    In basic WoT setups, all scripts running inside the
                    <a>WoT Runtime</a> are considered trusted,
                    distributed by the manufacturer, and therefore there
                    is no strong need to perform strict isolation
                    between each running script instance. However,
                    depending on device capabilities, deployment use
                    case scenarios, and risk level it might be desirable
                    to do so. For example, if one script handles
                    sensitive privacy-related PII data and is
                    well-audited, it might be desirable to separate it
                    from the rest of the script instances to minimize
                    the risk of data exposure in case some other script
                    inside the same system gets compromised during runtime. Another
                    example is mutual co-existence of different tenants
                    on a single WoT device. In this case each WoT
                    runtime instance will be hosting a different tenant,
                    and isolation between them is required.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The <a>WoT Runtime</a> should perform isolation of
                        script instances and their data in cases when
                        scripts handle privacy-related or other critical
                        security data. Similarly, the <a>WoT Runtime</a>
                        implementation should perform isolation of <a>WoT
                            Runtime</a> instances and their data if a WoT
                        device has more than one tenant. Such isolation
                        can be performed within the <a>WoT Runtime</a>
                        using platform security mechanisms available on
                        the device. For more information see Sections
                        "WoT Servient Single-Tenant" and "WoT Servient
                        Multi-Tenant" of the <em>WoT Security and Privacy
                        Considerations</em> specification [[wot-security]].
                    </dd>
                </dl>
            </section>
            <section
                id="sec-security-consideration-device-direct-access">
                <h5>Physical Device Direct Access Security and
                    Privacy Risk</h5>
                <p>In case a script is compromised or malfunctions
                    the underlying physical device (and potentially
                    surrounded environment) can be damaged if a script
                    can use directly exposed native device interfaces.
                    If such interfaces lack safety checks on their
                    inputs, they might bring the underlying physical
                    device (or environment) to an unsafe state.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The <a>WoT Runtime</a> should avoid directly
                        exposing the native device interfaces to the
                        script developers. Instead a <a>WoT Runtime</a>
                        implementation should provide a hardware
                        abstraction layer for accessing the native
                        device interfaces. Such hardware abstraction
                        layer should refuse to execute commands that
                        might put the device (or environment) to an
                        unsafe state. Additionally, in order to reduce
                        the damage to a physical WoT device in cases a
                        script gets compromised, it is important to
                        minimize the number of interfaces that are
                        exposed or accessible to a particular script
                        based on its functionality.
                    </dd>
                </dl>
            </section>
        </section>
        <section id="sec-security-consideration-runtime-risks">
            <h2>WoT Runtime Security and Privacy Risks</h2>
            <section id="sec-security-consideration-update-provisioning">
                <h5>Provisioning and Update Security Risk</h5>
                <p>
                    If the <a>WoT Runtime</a> implementation supports
                    post-manufacturing provisioning or updates of
                    itself, scripts, or any related data (including
                    security credentials), it can be a major attack
                    vector. An attacker can try to modify any above
                    described element during the update or provisioning
                    process or simply provision attacker's code and data
                    directly.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        Post-manufacturing provisioning or update of
                        scripts, the <a>WoT Runtime</a> itself or any
                        related data should be done in a secure fashion.
                        A set of recommendations for secure update and
                        post-manufacturing provisioning can be found in
                        the <em>WoT Security and Privacy Considerations</em>
                        specification [[wot-security]].
                    </dd>
                </dl>
            </section>
            <section id="sec-security-consideration-credentials-storage">
                <h5>Security Credentials Storage Security and
                    Privacy Risk</h5>
                <p>
                    Typically the <a>WoT Runtime</a> needs to store the
                    security credentials that are provisioned to a WoT
                    device to operate in a network. If an attacker can
                    compromise the confidentiality or integrity of these
                    credentials, then it can obtain access to
                    assets, impersonate other WoT Things, devices, or services,
                    or launch
                    Denial-Of-Service (DoS) attacks.
                </p>
                <dl>
                    <dt>Mitigation:</dt>
                    <dd>
                        The <a>WoT Runtime</a> should securely store any
                        provisioned security credentials, guaranteeing
                        their integrity and confidentiality. In case
                        there are more than one tenant on a single
                        WoT-enabled device, a <a>WoT Runtime</a>
                        implementation should guarantee isolation of
                        each tenant's provisioned security credentials.
                        Additionally, in order to minimize a risk that
                        provisioned security credentials get
                        compromised, the <a>WoT Runtime</a>
                        implementation should not expose any API for
                        scripts to query the provisioned security
                        credentials. Such credentials (or event better,
                        abstract operations that use them but do not
                        expose them) should only be accessible to the <a>Protocol
                            Binding</a> implementation that uses them.
                    </dd>
                </dl>
            </section>
        </section>
    </section>

    <section class="appendix-acknowledgements">
        <h2>Acknowledgments</h2>
        <p>Special thanks to all active Participants of the W3C Web
            of Things Interest Group (WoT IG) and Working Group (WoT WG) for their
            technical input and suggestions that led to improvements to
            this specification.</p>
        <p>The WoT WG also would like to appreciate the pioneering efforts
           regarding the concept of "Web of Things" that started as an academic
           initiative in the form of publications such as [[?wot-pioneers-1]] [[?wot-pioneers-2]]
           [[?wot-pioneers-3]] [[?wot-pioneers-4]] and, starting
           in 2010, a yearly <a href="https://webofthings.org/events/wot/">
           International Workshop on the Web of Things</a>.</p>
    </section>

    <section class="appendix-change-history">
      <h2>Change History</h2>
      <ul>
      <li>Sept 2017: <a href="https://www.w3.org/TR/2017/WD-wot-architecture-20170914/">First Public Working Draft</a>.</li>
      <li>March 2019: Public Working Draft for TAG review.</li>
      </ul>
    </section>

</body>
</html>
