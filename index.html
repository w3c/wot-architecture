<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta charset="utf-8" />
<title>Web of Things (WoT) Architecture</title>
<script class="remove"
	src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
<script class="remove">
	var respecConfig = {
		specStatus : "ED",
		processVersion : 2017,
		shortName : "wot-architecture",
		copyrightStart : 2017,
		wg : "Web of Things Working Group",
		wgURI : "https://www.w3.org/WoT/WG/",
		wgPublicList : "public-wot-wg",
		edDraftURI : "https://w3c.github.io/wot-architecture/",
		githubAPI : "https://api.github.com/repos/w3c/wot-architecture",
		issueBase : "https://www.github.com/w3c/wot-architecture/issues",
		editors : [ {
			name : "Matthias Kovatsch",
			w3cid : "75998",
			company : "Huawei",
			companyURL : "https://www.huawei.com/"
		}, {
			name : "Kazuo Kajimoto",
			w3cid : "74112",
			company : "Panasonic Corp.",
			companyURL : "https://www.panasonic.com/"
		}, {
			name : "Ryuichi Matsukura",
			w3cid : "64284",
			company : "Fujitsu Ltd.",
			companyURL : "https://www.fujitsu.com/"
		}, {
			name : "Michael Lagally",
			w3cid : "47166",
			company : "Oracle Corp.",
			companyURL : "https://www.oracle.com/"
		}, {
			name : "Toru Kawaguchi",
			w3cid : "79307",
			company : "Panasonic Corp.",
			companyURL : "https://www.panasonic.com/"
		} ],
		otherLinks : [
				{
					key : "Contributors",
					data : [ {
						value : "In the GitHub repository",
						href : "https://github.com/w3c/wot-architecture/graphs/contributors"
					} ]
				}, {
					key : "Repository",
					data : [ {
						value : "We are on GitHub",
						href : "https://github.com/w3c/wot-architecture/"
					}, {
						value : "File a bug",
						href : "https://github.com/w3c/wot-architecture/issues"
					} ]
				} ],
		localBiblio : {
			"CoRE-RD" : {
				href : "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11",
				title : "CoRE Resource Directory",
				status : "Internet-Draft",
				publisher : "IETF",
				date : "03 July 2017"
			},
			"WOT-SECURITY-CONSIDERATIONS" : {
				href : "https://www.w3.org/TR/wot-security/",
				title : "Web of Things Security and Privacy Considerations",
				publisher : "W3C"
			},
			"IEC-FOTF" : {
				href : "https://www.iec.ch/whitepaper/pdf/iecWP-futurefactory-LR-en.pdf",
				title : "Factory of the future",
				publisher : "IEC",
				date : "October 2015"
			},
			"REST" : {
				title : "REST: Architectural Styles and the Design of Network-based Software Architectures",
				author : "Roy Thomas Fielding",
				status : "PhD thesis",
				publisher : "University of California, Irvine",
				date : "2000"
			},
			"HMI" : {
				title : "The Encyclopedia of Human-Computer Interaction, 2nd Ed",
				author : "Mads Soegaard, Rikke Friis Dam",
				publisher : "Interaction Design Foundation",
				date : "2013"
			},
			"NORMAN" : {
				title : "The Psychology of Everyday Things",
				author : "Donald A. Norman",
				publisher : "Basic Books",
				date : "1988"
			},
			"MQTT" : {
				title : "MQTT Version 3.1.1",
				author : "Andrew Banks, Rahul Gupta",
				publisher : "OASIS Standard",
				date : "2014"
			},
			"FORMS" : {
				href : "https://tools.ietf.org/html/draft-hartke-t2trg-coral",
				title : "The Constrained RESTful Application Language (CoRAL)",
				author : "Klaus Hartke",
				publisher : "IETF",
				status : "Internet-Draft",
				date : "2019"
			}
		}
	};
</script>
<style type="text/css">
a[href].internalDFN {
	color: inherit;
	border-bottom: 1px solid #99c;
	text-decoration: none;
}
</style>
</head>
<body>
	<section id="abstract">
		<p>The W3C Web of Things (WoT) was created to enable
			interoperability across IoT Platforms and application domains.</p>
		<p>WoT provides mechanisms to formally describe IoT interfaces to
			allow IoT devices and services to communicate with each other,
			independent of their underlying implementation, and across multiple
			networking protocols. In addition WoT offers a standardized way to
			define and program IoT behavior.</p>

		<p>This WoT Architecture document describes the abstract
			architecture for the W3C Web of Things. It is derived from a set of
			requirements that were derived from use cases for multiple
			application domains. The architecture can be mapped onto a variety of
			concrete deployment scenarios, several examples of which are given.</p>
		<p>The document is focused on the scope of W3C WoT
			standardization, which consists of three initial building blocks.
			These are described by additional WoT specifications:</p>
		<ul>
			<li>the <a href="https://w3c.github.io/wot-thing-description/">WoT
					Thing Description</a> ,
			</li>
			<li>the <a href="https://w3c.github.io/wot-binding-templates/">WoT
					Binding Templates</a> , and
			</li>
			<li>the <a href="https://w3c.github.io/wot-scripting-api/">WoT
					Scripting API</a> .
			</li>
		</ul>

		<p>
			The <a>WoT Thing Description</a> is the primary building block, as it
			describes the network-facing interface of a Thing (<a>WoT
				Interface</a>).
		</p>
		<p>
			The optional <a>WoT Binding Templates</a> can be used to describe
			multiple protocol bindings, sothat a <a>Thing</a> can communicate
			with different <a>IoT Platforms</a> (i.e., IoT ecosystems or
			standards).
		</p>
		<p>
			The optional <a>WoT Scripting API</a> enables to implement the
			application logic of a Thing using a standardized contract for
			JavaScript. This simplifies IoT application development and enables
			portability across vendors and WoT network components.
		</p>

		<p>Other non-normative architectural blocks and conditions
			underlying the Web of Things are also described in the context of
			deployment scenarios. In particular, recommendations for security and
			privacy are included, while the goal is to preserve and support
			existing device mechanisms and properties. In general, W3C WoT is
			designed to describe what exists rather than to prescribe what to
			implement.</p>

	</section>
	<section id="sotd">
		<p class="ednote" title="The W3C WoT WG is asking for feedback">
			Please contribute to this draft using the <a
				href="https://github.com/w3c/wot-architecture/issues">GitHub
				Issue</a> feature of the <a
				href="https://github.com/w3c/wot-architecture/">WoT Architecture</a>
			repository. For feedback on security and privacy considerations,
			please use the <a href="https://github.com/w3c/wot-security/issues">WoT
				Security and Privacy</a> Issues, as they are cross-cutting over all our
			documents.
		</p>
	</section>
	<section>
		<h1>Introduction</h1>
		<p>
			The "Web of Things" (WoT) started as an academic initiative in the
			form of publications and, starting in 2010, a yearly <a
				href="https://webofthings.org/events/">International Workshop on
				the Web of Things</a> . Its goal is to improve interoperability as well
			as usability in the Internet of Things (IoT). With the increasing
			role of IoT services using other web standards in commercial and
			industrial applications, the W3C chartered an <a
				href="https://www.w3.org/WoT/IG/">Interest Group</a> in 2015 to
			identify technological building blocks for Recommendation Track
			standardization. With the WoT <a href="https://www.w3.org/WoT/WG/">Working
				Group</a> chartered end of 2016, the first set of WoT building blocks
			has now being standardized:
		</p>
		<ul>
			<li>the <a href="https://w3c.github.io/wot-thing-description/">WoT
					Thing Description</a>,
			</li>
			<li>the <a href="https://w3c.github.io/wot-binding-templates/">WoT
					Binding Templates</a>, and
			</li>
			<li>the <a href="https://w3c.github.io/wot-scripting-api/">WoT
					Scripting API</a>.
			</li>
		</ul>

		<p>This document serves as an umbrella for the W3C WoT draft
			specifications and defines the basics such as terminology and the
			underlying abstract architecture of the W3C Web of Things. In
			particular, the purpose of this document is to provide</p>
		<ul>
			<li>a set of use cases that lead to the W3C WoT Architecture,</li>
			<li>a set of requirements for WoT implementations,</li>
			<li>an overview of the WoT building blocks being standardized
				and their interplay,</li>
			<li>a guideline to map the abstract architecture to software
				stacks and hardware components,</li>
			<li>and security considerations to be aware of when implementing
				WoT building blocks.</li>
		</ul>
	</section>
	<section id="conformance"></section>
	<section>
		<h1>Terminology</h1>
		<p>
			<em>This section is normative.</em>
		</p>

		<p>This document uses the following terms as defined here. The WoT
			prefix is used to avoid ambiguity for terms that are defined
			specifically for Web of Things concepts.</p>
		<dl>
			<dt>
				<dfn>Action</dfn>
			</dt>
			<dd>An Interaction Affordance that allows to invoke a function
				of the Thing, which manipulates internal state that is not directly
				exposed (cf. Properties) based on internal logic or triggers a
				process on the Thing.</dd>
			<dt>
				<dfn>Application</dfn>
			</dt>
			<dd>A running or periodically running process that consumes one
				or more Things (read and processes there data, control their state)
				and/or exposes one or more Things (provide access to locally
				gathered data or computed from consumed Things, provide remote
				control and management interfaces). The application can be
				implemented using the Scripting API or native platform APIs. The
				application may also be distributed over multiple Things and other
				hosts.</dd>
			<dt>
				<dfn data-lt="WoT Binding Templates">Binding Templates</dfn>
			</dt>
			<dd>A re-usable collection of blueprints for the communication
				with different IoT platforms. The blueprints includes the required
				vocabulary for the Thing Description to map Interactions to
				platform-specific messages as well as implementation notes for the
				required protocol stacks or dedicated communication drivers.</dd>
			<dt>
				<dfn>Client API</dfn>
			</dt>
			<dd>Programming interface that allows scripts to access remote
				Things over the network, local Things in a different execution
				environment, or directly attached hardware (which is abstracted as
				Things).</dd>
			<dt>
				<dfn>to consume a Thing</dfn>
			</dt>
			<dd>To read a Thing Description and create a Consumed Thing
				software object for the application in the local runtime
				environment.</dd>
			<dt>
			<dt>
				<dfn>CoAP</dfn>
			</dt>
			<dd>Acronym for Constrained Application Protocol [[RFC7252]]</dd>
			<dt>
				<dfn>CWT</dfn>
			</dt>
			<dd>CBOR Web Token</dd>
			<dfn>Consumed Thing</dfn>
			</dt>
			<dd>A software object instance created through the WoT object of
				the Scripting API that represents a remote Thing used by the local
				application. It is defined by the ConsumedThing interface of the WoT
				Scripting API.</dd>

			<dt>
				<dfn>Digital Twin</dfn>
			</dt>
			<dd>A digital twin is a virtual representation of a device or a
				group of devices that resides on a cloud server or edge device. It
				can be used to represent real-world devices which may not be
				continuously online, or to run simulations of new applications and
				services, before they get deployed to the real devices.</dd>
			<dt>
				<dfn>Discovery API</dfn>
			</dt>
			<dd>Programming interface that allows scripts to discover other
				Things (local, nearby, or remote).</dd>
			<dt>
				<dfn>Domain-specific vocabulary</dfn>
			</dt>
			<dd>Linked Data vocabulary that can be used in the WoT Thing
				Description, but is not defined by W3C WoT.</dd>
			<dt>
				<dfn>Event</dfn>
			</dt>
			<dd>An Interaction Affordance that describes asynchronous push
				interactions initiated by the Thing.</dd>
			<dt>
				<dfn>Execution Environment</dfn>
			</dt>
			<dd>A sandbox within the Runtime that isolates scripts running
				on the same Servient.</dd>
			<dt>
				<dfn>to expose a Thing</dfn>
			</dt>
			<dd>To create an Exposed Thing software object in the local
				runtime environment that enables the application to provide local
				state and calls as Interactions over the network.</dd>
			<dt>
				<dfn>Exposed Thing</dfn>
			</dt>
			<dd>A software object instance created through the Server API
				that is implemented locally and can be accessed over the network by
				remote WoT Clients. It is defined by the ExposedThing interface of
				the WoT Scripting API.</dd>
			<dt>
				<dfn>Hypermedia Control</dfn>
			</dt>
			<dd>Hypermedia controls are Web links [[!RFC8288]] and request
				templates where the latter can be seen as forms to fill in and to
				send to servers.</dd>
			<dt>
				<dfn>Interaction Affordance</dfn>
			</dt>
			<dd>
				Metadata of a Thing exposing <a>hypermedia controls</a> that
				describe the possible protocol-level choices to clients, thereby
				suggesting how clients may interact with the Thing. Examples use of
				affordances includes, but are not limited, getting and setting <a>properties</a>,
				invoking <a>actions</a>, and subscribing to <a>events</a>.
			</dd>
			<dt>
				<dfn>Interaction Model</dfn>
			</dt>
			<dd>An intermediate abstraction that formalizes the mapping from
				application intent to concrete protocol bindings, which are used to
				interact with Web resources.</dd>
			<dt>
				<dfn>IoT platform</dfn>
			</dt>
			<dd>A specific IoT ecosystem such as OCF, oneM2M, or Mozilla
				Project Things with its own specifications for application-facing
				APIs, data model, and protocols or protocol configurations.</dd>
			<dt>
				<dfn>JSON-LD</dfn>
			</dt>
			<dd>
				A JSON document that is augmented with support for Linked Data by
				providing an
				<code>@context</code>
				property with a defining URI [[json-ld]].
			</dd>
			<dt>
				<dfn>JWT</dfn>
			</dt>
			<dd>JSON Web Token [[RFC7519]]</dd>
			<dt>
				<dfn>Local Discovery</dfn>
			</dt>
			<dd>A discovery method that can discover Things directly
				connected to a Servient (e.g., sensor or actuator that is abstracted
				as Thing).</dd>
			<dt>
				<dfn>Manual Discovery</dfn>
			</dt>
			<dd>A discovery method where the URI of the used consumed Thing
				Descriptions is provided manually (e.g., through user configuration
				or hard-coding in a script).</dd>
			<dt>
				<dfn>MQTT</dfn>
			<dd>
				<i>Message Queuing Telemetry Transport</i> is a
				publish-subscribe-based messaging protocol.[[!MQTT]]
			</dd>


			<dfn>Nearby Discovery</dfn>
			</dt>
			<dd>A discovery method where the physical location is considered
				(e.g., BLE, Audio Watermarking, ...).</dd>
			<dt>
				<dfn>Network Discovery</dfn>
			</dt>
			<dd>A discovery method that can discover Things in local
				networks (e.g. SSDP, mDNS/DNS-SD, ...).</dd>
			<dt>
				<dfn>Property</dfn>
			</dt>
			<dd>An Interaction Affordance that exposes internal state of the
				Thing that can be directly accessed (read) and optionally
				manipulated (write).Things can also choose to make Properties
				observable by pushing the new state after a change.</dd>
			<dt>
				<dfn data-lt="WoT Protocol Binding">Protocol Binding</dfn>
			</dt>
			<dd>The set of mapping rules from an Interaction Affordance to
				concrete messages of a specific protocol. These rules are encoded
				into the TD using forms.</dd>
			<dt>
			<dt>
				<dfn>RDF</dfn>
			</dt>
			<dd>The Resource Description Framework (RDF) of the Semantic Web
				[[rdf-concepts]]</dd>
			<dfn>Remote Discovery</dfn>
			</dt>
			<dd>A discovery method which supports lookup of remote Things
				also beyond network boundaries, for instance by using a directory
				service. The endpoint of the directory must be supported.</dd>
			<dt>
				<dfn>Runtime</dfn>
			</dt>
			<dd>A context for executing application logic that includes a
                            language runtime for the Scripting API (if used) and 
                            secure management of private state,
                            including private security data.</dd>
			<dt>
				<dfn>Server API</dfn>
			</dt>
			<dd>Programming interface that allows scripts to expose local
				functionality as Things to WoT Clients.</dd>
			<dt>
				<dfn>Servient</dfn>
			</dt>
			<dd>A software stack that implements the WoT building blocks. A
				Servient can host and expose Things (server role) and/or consume
				Things (client role). Servients usually have multiple Protocol
				Bindings to enable interaction with different platforms.</dd>
			<dt>
				<dfn>Subprotocol</dfn>
			</dt>
			<dd>An extension mechanism to a transfer protocol that must be
				known to interact successfully.</dd>
			<dt>
				<dfn>TD</dfn>
			</dt>
			<dd>Short for Thing Description.</dd>
			<dt>
				<dfn>TD Vocabulary</dfn>
			</dt>
			<dd>A controlled Linked Data vocabulary by W3C WoT to tag the
				metadata of Things in the WoT Thing Description including
				communication metadata of WoT Binding Templates.</dd>
			<dt>
				<dfn>Thing</dfn>
			</dt>
			<dd>An abstraction of a physical or a virtual entity whose
				metadata and interfaces are described by a WoT Thing Description,
				whereas a virtual entity is the composition of one or more Things.</dd>
			<dt>
				<dfn data-lt="WoT Thing Description">Thing Description</dfn>
			</dt>
			<dd>Structured data describing a Thing. A TD includes metadata,
				domain-specific metadata, a list of offered interactions, the
				supported protocol bindings for each interaction, and links to
				related Things. The Thing Description is built around a formal
				Interaction Model.</dd>
			<dt>
				<dfn>Thing Directory</dfn>
			</dt>
			<dd>A directory service for TDs that provides a Web interface to
				register TDs (see [[CoRE-RD]]) and look them up (e.g., using SPARQL
				queries or CoRE Link Format).</dd>
			<dt>
				<dfn>Transfer Protocol</dfn>
			</dt>
			<dd>The underlying, standardized application layer protocol
				without application-specific options or subprotocol mechanisms.</dd>
			<dt>
				<dfn>WoT</dfn>
			</dt>
			<dd>The Web of Things initiative and family of specifications in
				the W3C.</dd>
			<dt>
				<dfn>WoT Client</dfn>
			</dt>
			<dd>An entity that can connect with a network interface
				described by a WoT Thing Description (i.e., consume a Thing). WoT
				Clients usually implement multiple Protocol Bindings. WoT Client is
				also used to refer to a Servient in client role only.</dd>
			<dt>
				<dfn>WoT Interface</dfn>
			</dt>
			<dd>The WoT Interface is the network-facing interface that is
				described by a TD. This requires the mapping rules of Protocol
				Bindings between the abstract WoT Runtime (Thing level) to a
				network-facing interface (protocol level).</dd>
			<dt>
				<dfn>WoT Object</dfn>
			</dt>
			<dd>The WoT object is the Scripting API entry point within a WoT
				Runtime. It provides methods to discover, consume, and expose
				Things.</dd>
			<dt>
				<dfn>WoT Runtime</dfn>
			</dt>
			<dd>A system implementing a Thing's application logic using the WoT Scripting API.
                                Implementing a full WoT Runtime is optional for Servients.
                                However, if it is omitted equivalent functionality
                                needs to be provided by custom application logic.

				The WoT Runtime should instantiate Consumed
				Things and Exposed Things as software objects, manage their public and private state,
				and generate and expose TDs. It communicates with other components such as
				protocol binding implementations and application scripts.
			</dd>
			<dt>
				<dfn data-lt="WoT Scripting API">Scripting API</dfn>
			</dt>
			<dd>The application-facing programming interface provided by a
				Servient; comparable to the Web browser APIs. It is an API provided
				to ease the implementation of, or to extend a WoT Runtime.</dd>
			<dt>
				<dfn>WoT Server</dfn>
			</dt>
			<dd>An entity that exposes a network interface consistent with a
				WoT Thing Description. WoT Server is also used to refer to a
				Servient in server role only.</dd>
		</dl>
	</section>

	<!--  USE CASES -->
	<section id="sec-use-cases" class="informative">
		<h1>Use Cases</h1>

		<p>
			This section presents the application domains and use cases targeted
			by the W3C WoT and which are used to derive the abstract architecture
			discussed in <a href="#sec-building-blocks"></a>.
		</p>
		<p>The Web of Things architecture does not put any limitations on
			use cases and application domains. Various application domains have
			been considered to collect common patterns that have to be satisfied
			by the abstract architecture.</p>
		<p>The following sections are not exhaustive. Rather they serve as
			illustrations, where connected things can provide additional benefit
			or enable new scenarios.</p>
		<section>
			<h2>Application Domains</h2>
			<section id="consumerusecases">
				<h3>Consumer</h3>
				<p>In the consumer space there are multiple assets that benefit
					from being connected. Lights and air conditioners can be turned off
					based on room occupancy. Window blinds can be closed automatically
					based on weather conditions and presence. Energy and other resource
					consumption can be optimized based on usage patterns and
					predictions.</p>
				<p>The consumer use cases in this section includes Smart Home
					use case.</p>
				<p>
					<a href="#smart-home"></a> shows an example of a Smart Home. In
					this case, gateways are connected to edge devices such as sensors,
					cameras and home appliances through corresponding local
					communication protocols such as KNX, ECHONET, ZigBee, DECT ULE and
					Wi-SUN. Multiple gateways can exist in one home, while each gateway
					can support multiple local protocols.
				</p>
				<p>Gateways can be connected to the cloud through the internet,
					while some appliances can be connected to the cloud directly.
					Services running in the cloud collect data from edge devices and
					analyze the data, then provide value to users through the edge
					devices and other UX devices.</p>
				<figure id="smart-home">
					<img src="images/wot-use-cases/smart-home.png"
						style="width: 640px;" />
					<figcaption>Smart Home</figcaption>
				</figure>
				<p>Smart home provides consumer benefits such as remote access
					and control, voice control and home automation. Smart home also
					enables device manufacturers to monitor and maintain devices
					remotely. Smart home can realizes added value services such as
					energy management and security surveilance.</p>
			</section>
			<section id="industrialiotusecases">
				<h3>Industrial</h3>
				<p>
					The industrial use cases in this section are applicable to
					different industry verticals. <br /> Due to the nature of overlaps
					in the application scenarios, different verticals have similar use
					cases.
				</p>
				<section>
					<h4>Example: Smart Factory</h4>
					<p>
						<a href="#smart-factory"></a> shows an example of a Smart Factory.
						In this case, cell controllers automate factory equipment with
						specialized communication such as RS-485 or EtherCAT. Line
						controllers orchestrate multiple cell controllers over IP-based
						networks. A factory controller integrates different line
						controllers. A cloud service collects data from the factory
						controller and analyzes them for predictive maintenance. Users can
						monitor the factory through a dashboard. Note that factories
						usually do not reveal the internal topology of their lines and
						cells.
					</p>
					<figure id="smart-factory">
						<img src="images/wot-use-cases/smart-factory.png"
							style="width: 640px;" />
						<figcaption>Smart Factory</figcaption>
					</figure>
				</section>
				<p>Smart factories require advanced monitoring of the connected
					manufacturing equipment as well of the manufactured products. They
					benefit from predictions of machine failures and early discovery of
					anomalies to prevent costly downtime and maintenance efforts.</p>
				<p>Additionally, monitoring of connected manufacturing equipment
					and the environment at the production facility for the presence of
					poisonous gases, excessive nois or heat increases the safety of the
					workers and reduces the risks of incidents or accidents.</p>
				<p>Real-time monitoring and KPI calculations of production
					equipment helps to detect productivity problems and optimize the
					supply chain.</p>
			</section>
			<section>
				<h4 id="transportationlogistics">Transportation &amp; Logistics</h4>
				<p>Monitoring of vehicles, fuel costs, maintenance needs and
					assignments helps to optimize the full utilization of the vehicle
					fleet.</p>
				<p>Shipments can be tracked to be en-route to ensure consistent
					quality and condition of the transported goods. This is especially
					useful to assert the integrity of the cold-chain from warehouses to
					refrigerated trucks to delivery.</p>
				<p>Centralized monitoring and management of stock in warehouses
					and yards can prevent out of stock and excessive stock situations.
				</p>
			</section>
			<section>
				<h4 id="utilities">Utilities</h4>
				<p>Automated reading of residential and C&I (Commercial and
					Industrial) meters, and billing offers continuous insights into
					resource consumption and potential bottlenecks.</p>
				<p>Monitoring the condition and output of distributed renewable
					energy generation equipment enables optimisation of distributed
					energy resources.</p>
				<p>Monitoring and remote-controlling of distribution equipment
					helps to automate the distribution process.</p>
				<p>Continuous monitoring of generation and distribution
					infrastructure is improving safety of utilities crew in the field.
				</p>
			</section>
			<section>
				<h4 id="oilandgas">Oil and Gas</h4>
				<p>Offshore platform monitoring, leakage detection and
					predicition of pipelines as well as monitoring and controlling the
					levels in tanks and reservoirs helps to improve the industrial
					safety for the workforce as well as for the environment.</p>
				<p>Automated calculation of a distributed stock through various
					storage tanks and delivery pipes/trucks allows for improved
					planning and resource optimisation.</p>
			</section>
			<section>
				<h4 id="insurance">Insurance</h4>
				<p>Proactive Asset Monitoring of high value assets such as
					connected structures, fleet vehicles, etc. mitigates the risk of
					severe damage and high costs due to predictions and early detection
					of incidents.</p>
				<p>Usage based insurance can be offered with usage tracking and
					customized insurance policies.</p>
				<p>Predictive weather monitoring and re-routing fleet vehicles
					to covered garages can limit loss due to hail damage, tree damage.
				</p>
			</section>
			<section>
				<h4 id="engineeringandconstruction">Engineering and
					Construction</h4>
				<p>Monitoring for industrial safety reduces the risks of
					security hazards. Monitoring of assets at construction site can
					prevent damage and loss.</p>
			</section>

			<section id="sec-agriculture">
				<h3 id="agriculture">Agriculture</h3>
				<p>Soil condition monitoring and creating optimal plans for
					watering, fertilizing as well as monitoring the produce conditions
					optimize the quality and output of agricultural produce.</p>
			</section>
			<section id="sec-healthcare">
				<h3 id="healthcare">Healthcare</h3>
				<p>Data collection and analytics of clinical trial data helps to
					gain insights into new areas.</p>
				<p>Remote patient monitoring mitigates the risk of undetected
					critical situations for elderly people and patients after
					hospitalization.</p>
			</section>
			<section>
				<h3 id="environmentmonitoring-1">Environment Monitoring</h3>
				<p>Environment monitoring typically relies on a lot of
					distributed sensors that send their measurement data to common
					gateways, edge devices and cloud services.</p>
				<p>Monitoring of air pollution, water pollution and other
					environmental risk factors such as fine dust, ozone, volatile
					organic compound, radioactivity, temperature, humidity to detect
					critical environment conditions can prevent unrecoverable health or
					environment damages.</p>
			</section>
			<section id="smart cities">
				<h3 id="smartcities">Smart Cities</h3>
				<p>Monitoring of Bridges, Dams, Levees, Canals for material
					condition, deterioration, vibrations discovers maintenance repair
					work and prevents significant damage. Monitoring of highways and
					providing appropriate signage ensures optimized traffic flow.</p>
				<p>Smart Parking is optimizing and tracking the usage and
					availability of parking spaces and automates billing/reservations.</p>
				<p>Smart control of street lights based on presence detection,
					weather predictions, etc reduced cost.</p>
				<p>Garbage containers can be monitored to optimize the waste
					management and the trash collection route.</p>
			</section>
			<section id="smart buildings">
				<h3 id="smartbuildings">Smart Buildings</h3>
				<p>Monitoring the energy usage throughout the building helps to
					optimize resource consumption and reduce waste.</p>
				<p>Monitoring the equipment in the buildings such as HVAC,
					Elevators, etc. and fixing problems early improves the satisfaction
					of occupants.</p>
			</section>
			<section id="connected car">
				<h3 id="connectedcar">Connected Car</h3>
				<p>Monitoring of operation status, prediction of service needs
					optimizes maintenance needs and costs. Driver safety is enhanced
					with notifications of an early warning system for critical road and
					traffic conditions.</p>
				<section id="connected car example">
					<h4 id="connectedcar-example">Connected Car Example</h4>
					<p>
						<a href="#connected-car"></a> shows an example of a Connected Car.
						In this case, a gateway connects to car components through CAN and
						to the car navigation system through a proprietary interface.
						Services running in the cloud collect data pushed from car
						components and analyze the data from multiple cars to determine
						traffic patterns. The gateway can also consume cloud services, in
						this case, to get traffic data and show it to the driver through
						the car navigation system.
					</p>
					<figure id="connected-car">
						<img src="images/wot-use-cases/connected-car.png"
							style="width: 500px;" />
						<figcaption>Connected Car</figcaption>
					</figure>
				</section>
				<p>Monitoring of operation status, prediction of service needs
					optimizes maintenance needs and costs. Driver safety is enhanced
					with notifications of an early warning system for critical road and
					traffic conditions.</p>
			</section>
		</section>



		<section id="commonusecasespatterns">
				<h1>Common Patterns</h1>
				<section>
	
					This section introduces common use case patterns that illustrate how
					devices/things interact with controllers, other devices, agents and
					servers.
	
					<h3 id="device-controllers">Device Controllers</h3>
					<p>
						The first use case is a local device controlled by user-operated
						remote controller as depicted in <a href="#smart-home-device"></a>
						. For example, A remote controller can access an electronic appliance through 
						the local home network directly. In this case, the remote controller can be realized 
						by a browser or native application.
					</p>
					<p>
						In this pattern, at least one device like the electronic appliance have a server role 
						that can accept the request from the other devices and respond them, and sometimes start 
						to initiate mechanical function of it. The another device like the remote controller 
						have a client role that can issue a message to the other with some requests, like to get 
						sensor value or to turn it on.
					</p>
					<figure id="smart-home-device">
						<img src="images/wot-use-cases/smart-home-device.png"
							style="width: 500px;" />
						<figcaption>Device Control</figcaption>
					</figure>
				</section>
				<section>
					<h3>Thing-to-Thing</h3>
					<p>
						<a href="#smart-home-t2t"></a> shows an example of direct
						Thing-to-Thing interaction. The scenario is as follows:
						a sensor detects the change of the room condition, for example the temperature 
						surpassing a set threshold, and issues a control message like "turn on" to the 
						electronic appliance. The sensor unit can issue some trigger messages to other devices.
					</p>
					<p>
						In this case, when two devices that have server roles are connected, at least one device 
						must have also a client role that issues a message to the other to actuate.
					</p>
					<figure id="smart-home-t2t">
						<img src="images/wot-use-cases/smart-home-t2t.png"
							style="width: 500px;" />
						<figcaption>Control Agent</figcaption>
					</figure>
				</section>
				<section>
					<h3>Remote Access</h3>
						This use case contains a mobile remote controller (e.g., on a
						smartphone) as shown in <a href="#smart-home-multi"></a>. 
						The remote controller can switch communication media between cellular network 
						and home network such as Wi-Fi and Bluetooth. When the controller is in the 
						home network it is a trusted device and no additional security or access control 
						is required.When it is outside of the trusted network, additional access control
						and security mechanisms must be applied to ensure a trusted relationship.
						Note that in this scenario the network connectivity may change due to switching between
						different network access points or cellular base stations.
					</p>
					<p>
						In this pattern, the remote controller and the electronic appliance have a client role 
						and a server role as in the related scenario in <a href="#smart-home-device"></a>.	
					</p>
					<figure id="smart-home-multi">
						<img src="images/wot-use-cases/smart-home-multi.png"
							style="width: 500px;" />
						<figcaption>Multiple Network Interfaces</figcaption>
					</figure>
				</section>
				<section>
					<h3>Smart Home Gateways</h3>
					<p>
						<a href="#smart-home-gateway"></a> shows a use case based on a
						Smart Home gateway. A smart home gateway is placed between a home network 
						and the Internet. The gateway manages electronic appliances inside the house 
						and can receive commands from a remote controller over the Internet, e.g., 
						from a smartphone as in the previous use case. It is also is a virtual representation 
						of a device. The smart home gateway typically offers proxy and firewall functionality.
					</p>
					<p>
						In this pattern, the home gateway have both of client and server roles. That is, 
						it can connect to the electronic appliance with the client role and to the remote 
						controller with the server role.
					</p>
					<figure id="smart-home-gateway">
						<img src="images/wot-use-cases/smart-home-gateway.png"
							style="width: 500px;" />
						<figcaption>Smart Home Gateway</figcaption>
					</figure>
				</section>
				<section>
					<h3>Edge Devices</h3>
					<p>
						An Edge Device or Edge Gateway is similar to a Smart Home gateway.
						We use the term to indicate additional tasks that are carried out by the edge gateway.
						Whereas the home gateway in <a href="#smart-home-gateway"></a>
						primarily just bridges between the public and the trusted network,
						the edge device has local compute capabilities and typically bridges 
						between different protocols. Edge devices are typically used
						in industrial solutions, where they can provide preprocessing,
						filtering and aggregation of data provided by connected devices and sensors.
					</p>
					<figure id="smart-home-multi">
						<img src="images/wot-use-cases/edge-device.png"
							style="width: 500px;" />
						<figcaption>Edge device</figcaption>
					</figure>
				</section>
				<section>
					<h3>Digital Twins</h3>
					<p>A digital twin is a virtual representation, i.e. a model of a device or a
						group of devices that resides on a cloud server or edge device. It
						can be used to represent real-world devices which may not be
						continuously online, or to run simulations of new applications and
						services, before they get deployed to the real devices.</p>
					<figure id="digital-twin">
						<img src="images/wot-use-cases/digital-twin.png"
							style="width: 500px;" />
						<figcaption>Digital Twin</figcaption>
					</figure>
					<p>Digital twins can model a single device, or they can
						aggregate multiple devices in a virtual representation of the
						combined devices.</p>
					<figure id="digital-twin-multiple-devices">
						<img src="images/wot-use-cases/digital-twin-multiple-devices.png"
							style="width: 500px;" />
						<figcaption>Digital Twin for Multiple Devices</figcaption>
					</figure>
	
					<p>Digital twins can be realized in different ways, depending on whether a device
					is already connected to the cloud, or whether it is connected to a gateway,
					which itself is connected to the cloud.</p>
					<section>
						<h4>Cloud-ready Devices</h4>
						<p>
							<a href="#smart-home-cloud1"></a> shows an example where
							electronic appliances are connected directly to the cloud. The
							cloud mirrors the appliances and, acting as a digital twin, can
							receive commands from remote controllers (e.g., a smartphone).
							Authorized controllers can be located anywhere, as the digital
							twin is globally reachable.
						</p>
						<figure id="smart-home-cloud1">
							<img src="images/wot-use-cases/smart-home-cloud1a.png"
								style="width: 500px;" />
							<figcaption>Appliance twin for a Cloud-ready Devices</figcaption>
						</figure>
					</section>
					<section>
						<h3>Legacy Devices</h3>
						<a href="#smart-home-cloud2"></a> shows an example where legacy
						electronic appliances cannot directly connect to the cloud. Here, a
						gateway is needed to relay the connection. The gateway works as:
						</p>
						<ul>
							<li>integrator of a variety of legacy communication protocols
								both in the physical and logical view</li>
							<li>firewall toward the Internet</li>
							<li>privacy filter which substitutes real image and/or
								speech, and logs data locally</li>
							<li>local agent in case the Internet connection is
								interrupted</li>
							<li>emergency services running locally when fire alarms and
								similar events occur</li>
						</ul>
						<p>The cloud mirrors the gateway with all connected appliances
							and acts as a digital twin that manages them in the cloud in
							conjunction with the gateway. Furthermore, the cloud can receive
							commands from remote controllers (e.g., a smartphone), which can
							be located anywhere.</p>
						<figure id="smart-home-cloud2">
							<img src="images/wot-use-cases/smart-home-cloud2.png"
								style="width: 500px;" />
							<figcaption>A Digital Twin for a Legacy Device</figcaption>
						</figure>
					</section>
				</section>
	
				<section>
					<h3>Multi-Cloud</h3>
					<p>
						Typical IoT deployments consist of multiple (thousands) of devices.
						Without a standardized mechanism, the management of firmware updates 
						for specific clouds require a lot of effort and hinders wider scale IoT adoption.
					</p>
					<p>The primary benefit of a standardized mechanism for describing				
						devices and device types is the capability of deploying devices to
						different cloud environments without the need of doing
						customization at device software / firmware level, i.e. installing
						cloud specific code to a device. This implies that the solution is
						flexible enough to describe devices in a way that allows
						on-boarding and using devices in multiple IoT cloud environments.</p>
					<p>
						This drives adoption of Web of Things devices, since it enables easy
						usage of new devices in an existing deployment, as well as 
						migration of existing devices from one cloud to the other.
					</p>
				</section>
	
				<section>
					<h3>Cross-domain Collaboration</h3>
					<p>
						<a href="#cross-domain"></a> show an example of a Cross-domain
						collaboration. In this case, each system involves other systems in
						other domains, such as Smart Factrory with Smart City, Smart City
						with Smart Home. This type of system is called "Symbiotic"
						ecosystem, as shown in [[IEC-FOTF]]. There are two collaboration
						models: direct collaboration and indirect collaboration. In the
						direct collaboration model, systems exchange their own information
						directly with each other in peer-to-peer manner. In the indirect
						collaboration, systems exchange their own information via some
						collaboration platform. In order to maintain and continue this
						collaboration, each system provide the metadata of their ability
						and interfaces and adopt itself to others.
					</p>
					<figure id="cross-domain">
						<img src="images/cross-domain-direct.png" style="width: 500px;" />
						<img src="images/cross-domain-indirect.png" style="width: 500px;" />
						<figcaption>Cross-domain collaboration</figcaption>
					</figure>
				</section>
			</section>
	
		<section>
			<h2>Summary</h2>
			<p class="ednote" title="TODO">The following figure has to be
				simplified to only show the abstract patterns without the
				implementation and WoT details (inside the gray boxes). Instead,
				common patterns can be listed at the corresponding places.</p>
			<p>
				The possible architecture patterns are described in the previous
				section. In these patterns, some entities such as the devices
				including the existing devices, the controllers, the gateways, and
				the clouds are located on some places such as inside building,
				outside buildings, and data centers. <a href="#usecase-overview"></a>
				is an integrated overview. To specify the differences of the
				entities, each entities shown in the patters is tied to each of
				functional roles such as a server, a client and a proxy/gateway.
				That is, the client corresponds to the application or the
				controller, and the server dose to the device. The proxy/gateway is
				an entity that relays the connection of the client and the server.
				The gateway is sometimes distinguished from the proxy because of
				having the protocol converter functionality when it's connected to
				the existing devices.
			</p>
			<figure id="usecase-overview">
				<img src="images/arch-use-case-overview.png" />
				<figcaption>Use Case Overview</figcaption>
			</figure>
		</section>
	</section>
	</section>
	<section id="sec-requirements" class="informative">
		<h1>Requirements</h1>
		<p class="ednote" title="TODO">The requirements have to be
			reviewed, partly merged, and sorted into the proper category
			(functional vs technical).</p>
		<section>
			<h2>Functional Requirements</h2>
			<p>This section defines the properties required in an abstract
				Web of Things (WoT) architecture.</p>
			<section id="sec-requirements-principles">
				<h3>Common Principles</h3>
				<ul>
					<li>WoT architecture should enable mutual interworking of
						different eco-systems using web technology.</li>
					<li>WoT architecture should be based on the web architecture
						using RESTful APIs.</li>
					<li>WoT architecture should allow to use multiple payload
						formats which are commonly used in the web.</li>
					<li>Flexibility
						<p>There are a wide variety of physical device configurations
							for WoT implementations. The WoT abstract architecture should be
							able to be mapped to and cover all of the variations.</p>
					</li>
					<li>Compatibility
						<p>There are already many existing IoT solutions and ongoing
							IoT standardization activities in many business fields. The WoT
							should provide a bridge between these existing and developing IoT
							solutions and Web technology based on WoT concepts. The WoT
							should be upwards compatible with existing IoT solutions and
							current standards.</p>
					</li>
					<li>Scalability
						<p>WoT must be able to scale for IoT solutions that
							incorporate thousands to millions of devices. These devices may
							offer the same capabilites even though they are created by
							different manufacturers.</p>
					</li>
					<li>Interoperability
						<p>WoT must provide interoperability across device and cloud
							manufacturers. It must be possible to take a WoT enabled device
							and connect it with a cloud service from different manufacturers
							out of the box.</p>
					</li>

				</ul>
			</section>
			<section id="sec-requirements-thing-functionalities">
				<h3>Thing functionalities</h3>
				<ul>
					<li>WoT architecture should allow thing's to have
						functionalities such as
						<ul>
							<li>reading thing's status information</li>
							<li>updating thing's status information which might cause
								actuation</li>
							<li>subscribing to, receiving and unsubscribing to the
								notification of the change of thing's status information.</li>
							<li>invoking functions with input and output parameters
								which would cause certain actuation or calculation.</li>
							<li>subscribing to, receiving and unsubscribing to the
								notification which does not directly relate to thing's status
								information.</li>
						</ul>
					</li>
				</ul>
			</section>
			<section id="sec-requirements-search-and-discovery">
				<h3>Search and discovery</h3>
				<ul>
					<li>WoT architecture should allow clients to know thing's
						attributes, functionalities and their access points, prior to
						access to the thing itself.</li>
					<li>WoT architecture should allow clients to search things by
						its attributes and functionalities.</li>
					<li>WoT architecture should allow semantic search of its
						functionalities based on unified vocabulary, regardless of naming
						of its functionalities.</li>
				</ul>
			</section>
			<section id="sec-requirements-description-mechanism">
				<h3>Description mechanism</h3>
				<ul>
					<li>WoT architecture should support common description
						mechanism which enables describing things and their functions.</li>
					<li>Such description should be not only human-readable, but
						also machine-readable.</li>
					<li>Such description should allow semantic annotation of its
						structure and described contents.</li>
					<li>Such description should be able to be exchanged using
						multiple formats which are commonly used in the web.</li>
				</ul>
			</section>
			<section id="sec-requirements-description-of-attributes">
				<h3>Description of attributes</h3>
				<ul>
					<li>WoT architecture should allow describing thing's
						attributes such as
						<ul>
							<li>name</li>
							<li>explanation</li>
							<li>version of spec, format and description itself</li>
							<li>links to other related things and information</li>
						</ul>
					</li>
					<li>Such description should support internationalization.</li>
				</ul>
			</section>
			<section id="sec-requirements-description-of-functionalities">
				<h3>Description of functionalities</h3>
				<ul>
					<li>WoT architecture should allow describing thing's
						functionalities which is shown in ## Thing functionalities</li>
				</ul>
			</section>
			<section id="sec-requirements-network">
				<h3>Network</h3>
				<ul>
					<li>WoT architecture should support multiple web protocols
						which are commonly used.</li>
					<li>Such protocols include 1)protocols commonly used in the
						internet and 2)protocols commonly used in the local area network</li>
					<li>WoT architecture should allow using multiple web protocols
						to access to the same functionality.</li>
					<li>WoT architecture should allow using mixture of multiple
						protocols to the functionalities of the same thing (e.g. HTTP and
						WebSocket).</li>
				</ul>
			</section>
			<section id="sec-requirements-deployment">
				<h3>Deployment</h3>
				<ul>
					<li>WoT architecture should support wide variety of thing
						capability such as edge devices with resource restrictions and
						virtual things on the cloud, based on the same model.</li>
					<li>WoT architecture should support multiple levels of thing
						hierarchy with intermediate entities such as gateways and proxies.</li>
					<li>WoT architecture should support accessing things in the
						local network from the outside of the local network (the internet
						or other local network), considering network address translation.</li>
				</ul>
			</section>
			<section id="sec-requirements-application">
				<h3>Application</h3>
				<ul>
					<li>WoT architecture should allow describing applications on
						the wide variety of things such as edge device, gateway, cloud and
						UI/UX device, using web standard technology based on the same
						model.</li>
				</ul>
			</section>
			<section id="sec-requirements-legacy-adaption">
				<h3>Legacy adaption</h3>
				<ul>
					<li>WoT architecture should allow mapping of legacy IP and
						non-IP protocols to web protocols, supporting wide variety of
						hierarchy, where such legacy protocols are terminated and
						translated.</li>
					<li>WoT architecture should allow transparent use of existing
						IP protocols without translation, which follow RESTful
						architecture.</li>
				</ul>
			</section>
		</section>
		<section id="sec-technical-requirements">
			<h2>Technical Requirements</h2>
			<p>The previous section delineated the Web of Things abstract
				architecture by showing various use cases and enumerating patterns
				for combining architectural components. This section describes
				technical requirements derived from the abstract architecture.</p>
			<section>
				<h3>Components consisting Web of Things and the Web of Things
					architecture</h3>
				<p>Observation of the use cases shows that basic components such
					as devices, applications that access and control those devices,
					proxies (e.g. gateways and platforms) that sit between devices and
					applications to link them together, directories that provides
					device search functionality are required.</p>
				<p>Those components are connected to the internet or field
					networks in offices, factories or other facilities. Note that all
					components involved may be connected to a single network in some
					cases, however, components can be deployed across multiple networks
					in general.</p>
			</section>
			<section>
				<h3>Devices</h3>
				<p>Access to devices are made based on descriptions of their
					functions and interfaces (i.e. Thing Description). Those include
					general description about devices, information models representing
					functions, transport protocol description for operating on
					information models, and security information, and so on.</p>
				<p>General descriptions are about device identifiers (URI) and
					other human readable information. Information models defines device
					attributes, and represent device’s internal settings, control
					functionality and notification functionality. Devices that have the
					same functionality have the same information model regardless of
					the transport protocols used.</p>
				<p>Because many systems based on Web of Things architecture are
					crossing system Domains, vocabularies and meta data (e.g.
					ontologies) used in information models should be commonly
					understood by involved parties. In addition to REST transports,
					PubSub transports are also supported.</p>
				<p>Security information includes descriptions about
					authentication, authorization and secure communications. Devices
					are required to put TDs either inside them or at locations external
					to the devices, and to make TDs accessible so that other components
					can find and access them.</p>
			</section>
			<section>
				<h3>Applications</h3>
				<p>Applications need to generate and utilize program interfaces
					internally based on device descriptions (i.e. TD).</p>
				<p>Applications have to be able to obtain device descriptions
					(i.e. TD) through the network, therefore, need to be able to
					conduct search operation and acquire the necessary TD over the
					network.</p>
			</section>
			<section>
				<h3>Twins</h3>
				<p>Twins need to generate program interfaces internally based on
					device descriptions (i.e. TD), and to represent virtual devices by
					using those program interfaces. A twin has to produce a TD for the
					virtual device and make it externally available.</p>
				<p>Identifiers of virtual devices need to be newly assigned,
					therefore, are different from the original devices. This makes sure
					that virtual devices and the original devices are clearly
					recognized as separate entities. Transport and security mechanisms
					and settings of the virtual devices can be different from original
					devices if necessary. Virtual devices are required to have TDs
					provided either directly by the twin or to have them available at
					external locations. In either case it is required to make the TDs
					available so that other components can find and use the devices
					associated with them.</p>
			</section>
			<section>
				<h3>Discovery</h3>
				<p>For TDs of devices and virtual devices to be accessible from
					devices, applications and twins, there needs to be a common way to
					share TDs. Directories can serve this requirement by providing
					functionalities to allow devices and twins themselves automatically
					or the users to manually register the descriptions.</p>
				<p>Descriptions of the devices and virtual devices need to be
					searchable by external entities. Directories have to be able to
					process search operations with search keys such as keywords from
					the general description in the device description or information
					models.</p>
			</section>
			<section>
				<h3>Security</h3>
				<p>Security information related to devices and virtual devices
					needs to be described in device descriptions. This includes
					information for authentication/authorization and payload
					encryptions.</p>
				<p>WoT architecture should support multiple security mechanism
					commonly used in the web, such as Basic, Digest, Bearer and
					OAuth2.0.</p>
			</section>
		</section>
	</section>

	<section id="sec-wot-architecture">
		<h1>WoT Architecture</h1>
		<section>
			<p>
				<em>This section is normative.</em>
			</p>
			<h2>Overview</h2>
			<figure id="architecture-abstract">
				<img src="images/architecture-abstract.png" style="width: 100%;" />
				<figcaption>Abstract Architecture of W3C WoT</figcaption>
			</figure>
		</section>
		<section id="sec-WoT-servient-architecture-high-level">
			<h2>High-level architecture</h2>
			<p>Overview of WoT component’s behavior is explained using a
				couple of system configuration diagrams. First, shown below is a
				configuration that consists of a device and an application shown
				below.</p>
			<figure id="high-level-application-device">
				<img src="images/arch-high-level-application-device-alt.png" />
				<figcaption>High level architecture of application and
					device</figcaption>
			</figure>
			<p>Functions of a device is described by a Thing Description
				(TD). A TD describes, among other things, a device’s identifier,
				functions and attributes of a device implemented internally,
				communication protocols (i.e. transport layer) information. Details
				of TD format are defined the Thing Description specification.</p>
			<p>Each Web of Things device MUST have a corresponding TD.
				Applications can recognize a device by obtaining a TD of the device.
				Conceptually, a device can be thought to have an ExposedThing that
				provides an interface that conforms to the TD. On the other hand, an
				application can be conceptually considered to have a ConsumedThing
				that provides an interface functionality for an application to
				utilize. An application can generate a ConsumedThing upon a receipt
				of a TD. Communication between an application and a device are
				realized by ConsumedThing and ExposedThing connect to each other and
				exchange messages.</p>
			<p>Next, in the below configuration, an application and a device
				connect to each other via a proxy.</p>
			<section class="ednote">
				<p>Need to adapt this chapter to use digital twin terminology
					instead of proxy.</p>
			</section>
			<figure id="high-level-application-proxy-device">
				<img src="images/arch-high-level-application-proxy-device.png" />
				<figcaption>High level architecture with proxy</figcaption>
			</figure>
			<figure id="high-level-application-proxy-device-new">
				<img src="images/arch-high-level-application-proxy-device-alt.png" />
				<figcaption>High level architecture with proxy</figcaption>
			</figure>
			<p>A proxy contains both ExposedThing and ConsumedThing
				functionality, and relay messages that are exchanged between an
				application and a device. In a proxy, a ConsumedThing creates a
				shadow of the device, and an application can access the shadow
				device through the proxy’s ExposedThing.</p>
			<p>Proxy’s ExposedThing and ConsumedThing can communicate in
				different protocols. For example, a device and an application can
				use separate protocols, CoAP and HTTP, respectively. Even when there
				are multiple devices and they use different protocols, an
				application can communicate with those devices using a single
				protocol through the proxy. The same is true for device
				authentication. An application only need to handle a single
				authentication method even when multiple devices connected to a
				proxy use different authentication methods.</p>
			<p>A proxy creates a ConsumedThing based on a TD and generates
				another TD for a shadow device. The TD for a shadow device uses a
				new identifier different from the original device TD’s, and changes
				communication protocols if necessary. A proxy then creates an
				ExposedThing that serves as the Thing for the TD. An application
				communicates with a device via a proxy through a ConsumedThing that
				works according to the TD for the shadow device.</p>
		</section>

		<section id="sec-web-thing">
			<h2>Web Thing</h2>
			<p class="ednote">
				Should the WoT documents consistently refer to <i>Web Thing</i>
				instead of just <i>Thing</i>?
			</p>
			<p>A simple example is a Thing being the digital representation
				of a physical IoT devices, which also directly provides the
				interface for interaction. A Thing may also be hosted on a gateway
				or the cloud, representing a physical entity with which clients
				cannot communicate diretly (e.g., a legacy device) or not all (e.g.,
				a room or table). Virtual entities like a room are often represented
				by a composition of one or more sensors and actuators, each of which
				may also be available as an individual Thing.</p>
			<p>
				A <a>Thing</a> in the Web of Things is the abstraction of a physical
				or a virtual entity whose metadata and interfaces are described by a
				WoT Thing Description. A virtual entity is the composition of one or
				more Things.
			</p>
			<p>A simple example is a Thing being the digital representation
				of a physical IoT devices, which also directly provides the
				interface for interaction. A Thing may also be hosted on a gateway
				or the cloud, representing a physical entity with which clients
				cannot communicate diretly (e.g., a legacy device) or not all (e.g.,
				a room or table). Virtual entities like a room are often represented
				by a composition of one or more sensors and actuators, each of which
				may also be available as an individual Thing.</p>
			<p>
				The interface of a <a>Thing</a> must follow the interaction model of
				the WoT Architecture. However, <a>Things</a> may only consist of
				metadata without offering an interface for interaction.
			</p>
			</p>
		</section>
		<section id="sec-arch-aspects">
			<h2>Architectural Aspects of a Web Thing</h2>
			<p>
				The use cases and the requirements discussed result in an abstract
				model of a Thing that has four architectural aspects of interest:
				its behavior, its interaction affordances, the mapping of those
				affordances to concrete protocols (what we call the Protocol
				Binding), and its security configuration. The behavior aspect
				includes both lifecycle management (onboarding, updating,
				decommissioning, etc) but also the operational behavior of the
				Thing, which can include both autonomous behavior and support for
				interactions. The interaction affordances are an abstract model of
				the network API in terms of properties, actions, and events, but
				without reference to a specific network protocol or payload
				encoding. The protocol binding adds the additional detail needed to
				map each affordance to a particular concrete protocol. In general,
				different protocols may be used to support different subsets of
				affordances even within a single Thing. The security configuration
				aspect represents the mechanisms used to control access to the
				affordances and the management of related public and private
				metadata. <a href="#arch-aspects"></a> shows these aspects in a
				diagram.
			<figure id="arch-aspects">
				<img src="images/wot-building-blocks.png" />
				<figcaption>Architectural Aspects of a Thing</figcaption>
			</figure>
			</p>
		</section>
		<section>
			<h2>Interaction Model</h2>
			<p>Originally, a Web resource usually represented a document on
				the World Wide Web that can simply be fetched by a client. With the
				introduction of Web servives, resources became more generic
				interaction endpoints that can implement any kind behavior. This
				very high level of abstraction makes it hard to provide a loose
				coupling between applications and the manifold interaction
				possibilities of resources. As a result, typical API descriptions
				consist of a static mapping from an application intent to a resource
				address, method, request payload structure, response payload
				structure, and expected errors.</p>
			<p>The interaction model of WoT introduces an intermediate
				abstraction that formalizes the mapping from application intent to
				concrete protocol bindings, which are used to interact with Web
				resources. Instead of generic resources, WoT applications use three
				types of so-called Interaction Affordances: Properties, Actions, and
				Events. While constraining Web resources into three different
				behaviors, the three types are still able to cover virtually all
				functionality found in IoT devices and services.</p>
			<section>
				<h3>Interaction Affordances</h3>
				<p>The term affordance originates in ecological psychology, but
					was adopted in the field of Human-Computer Interaction [[?HMI]]
					based on the definition by Donald Norman: "'Affordance' refers to
					the perceived and actual properties of the thing, primarily those
					fundamental properties that determine just how the thing could
					possibly be used." [[?NORMAN]]</p>
				<p>The hypermedia principle that is one of the bedrock
					foundations of the REST [[?REST]] principle demands that any piece
					of information available on the Web be linked to other pieces of
					information so that the consumer of the information gets explicit
					knowledge about how to navigate the Web and control Web
					applications. The simultaneous presentation to Web clients of
					information and control, provided in the form of hyperlinks, is a
					mechanism that affords clients the means to drive Web applications.
					In this context, an affordance is the description of a hyperlink
					(e.g. via a link relation type or link target attributes)
					suggesting clients how to act on the linked resource.</p>
				<p>
					Drawn from this hypermedia principle, the Web of Things defines
					Interaction Affordances as metadata of a Thing exposing <a>hypermedia
						control</a>s that describe the possible protocol-level choices to
					clients, thereby suggesting how clients may interact with the
					Thing. Examples use of affordances includes, but are not limited,
					getting and setting <a>properties</a>, invoking <a>actions</a>, and
					subscribing to <a>events</a>.
				</p>
				<p>This definition is thereby aligned with HCI and interaction
					designers, who create physical Things, as well as the REST and
					microservice community working on Web services in general.</p>
			</section>
			<p class="ednote">Please comment if the Interaction Affordances
				should be defined using normative langauge. Note that this document
				provides the abstract concept, while the WoT Thing Description
				document defines concrete classes within an information model.</p>
			<section>
				<h3>Properties</h3>
				<p>A Property is an Interaction Affordance that exposes internal
					state of the Thing that can be directly accessed (read) and
					optionally manipulated (write). Things can also choose to make
					Properties observable by pushing the new state after a change (cf.
					CoAP Observe [[?RFC7641]]).</p>
				<p>Properties may contain one data schema if the data is not
					fully specified by the Protocol Binding used (e.g., through a Media
					Type).</p>
				<p>Examples of Properties are sensor values (read-only),
					stateful actuators (read-write), configuration parameters
					(read-write), Thing status (read-only), or computation results
					(read-only).</p>
			</section>
			<section>
				<h3>Actions</h3>
				<p>An Action is an Interaction Affordance that allows to invoke
					a function of the Thing, which manipulates internal state that is
					not directly exposed (cf. Properties) based on internal logic or
					triggers a process on the Thing.</p>
				<p>Actions may contain up to two data schemas, one for optional
					input parameters, one for output results, if the data is not fully
					specified by the Protocol Binding used (e.g., through a Media
					Type).</p>
				<p>Examples of Actions are changing multiple Properties
					simultaneously, changing Properties over time or with a process
					that shall not be disclosed, or invoking a long-lasting process
					such as actuator control.</p>
			</section>
			<section>
				<h3>Events</h3>
				<p>An Event Interaction Affordance describes asynchronous push
					interactions initiated by the Thing. Here not state, but state
					transitions (i.e., events) are communicated. Events may betriggered
					through conditions that are not exposed as Properties.</p>
				<p>Events may contain up to three data schemas, one for the
					event data and optionally one for the subscription data and/or one
					for the cancellation data, if the data is not fully specified by
					the Protocol Binding used (e.g., through a Media Type).</p>
				<p>Examples of Events are discrete events such as an alarm or
					samples of a timeseries that are pushed regularly.</p>
			</section>
		</section>
		<section id="sec-hypermedia-controls">
			<h2>Hypermedia Controls</h2>
			<p>Interaction Affordances showing the possible choices to
				clients must originate from the Thing itself and are shared during
				discovery or in-band during the interaction with the Thing. This is
				opposed to out-of-band interface descriptions that need to be
				preinstalled or hardcoded into clients (e.g., RPC, WS-* Web
				services, HTTP services with fixed URI-method-response definitions).
			</p>
			<p>To suggest how clients may interact with the Thing, WoT makes
				use of hypermedia controls known from REST. Besides the
				well-established Web links [[!RFC8288]], WoT defines the concept of
				Web forms. They allow to adapt to the diverse choices with which
				clients are faced in the Internet of Things [[?FORMS]].</p>
			<section id="sec-hypermedia-links">
				<h3>Links</h3>
				<p>
					Web links enable clients to change the current context (e.g., the
					set of resource representations currently rendered in the Web
					browser) or to include further resources in the current context,
					depending on the relation between context and link target. Clients
					do so by <i>dereferencing</i> the target URI, that is, fetching the
					resource representation.
				</p>
				<p>
					A link is comprised of a link context, relation type, target, and
					optionally target attributes The underlying model for the
					relationships between resources on the Web (i.e., links) is defined
					in [[!RFC8288]]. link relation types are either IANA-registered
					tokens adhering to the ABNF
					<code style="white-space: nowrap;">LOALPHA *( LOALPHA /
						DIGIT / "." / "-" )</code>
					(e.g.,
					<code>stylesheet</code>
					) or extension types in form of absolute URIs. [[!RFC8288]]
				</p>
				<p>In the Web of Things, links are used for discovery and to
					express relations between Things (e.g., hierarchical or functional)
					and relations to other documents on the Web (e.g., manuals or
					alternative representations such as CAD models).</p>
			</section>
			<section id="sec-hypermedia-forms">
				<h3>Forms</h3>
				<p>Forms enable clients to perform interactions that go beyond
					dereferencing a URI such as manipulating resource state at the
					server. This usually requires more detailed information about the
					necessary request such as the method and header fields or protocol
					options. Forms can be seen as a request template, where the server
					prefilled part of the information according to its own interface
					and left parts blank to be filled by the client.</p>
				<p>In the Web of Things, a form provides instructions to perform
					an operation on a resource and is comprised of:
				<ul>
					<li>a form context,</li>
					<li>a submission target,</li>
					<li>an operation type,</li>
					<li>a request method, and</li>
					<li>optionally form fields</li>
				</ul>
				</p>
				<p>
					A form can be viewed as a statement of "To perform a
					<code>operation type</code>
					operation on
					<code>form context</code>
					, make a
					<code>request method</code>
					request to
					<code>submission target</code>
					" where form fields may further describe the required request.
				</p>
				<p>Form contexts and submission targets are both
					Internationalized Resource Identifiers (IRIs) [[!RFC3987]].
					However, in the common case, thay will also be URIs [[!RFC3986]],
					because many protocols (such as HTTP) do not support IRIs.</p>
				<p>Form context and submission target may point to the same
					resource or different resources, where the submission target
					resource implements the operation for the context resource.</p>
				<p>The operation type identifies the semantics of the operation.
					Operation types are denoted similar to link relation types:
				<ul>
					<li><span class="rfc2119-assertion" id="arch-op-wellknown">Well-known
							operation types MUST have a name that follows the ABNF <code
								style="white-space: nowrap;">LOALPHA *( LOALPHA / DIGIT /
								"." / "-" )</code>.
					</span> <span class="rfc2119-assertion" id="arch-op-wellknown-compare">Names
							MUST be compared character by character in a case-insensitive
							fashion.</span> The well-known operation types for the Web of Things
						defined by this specification are given in the following table.</li>
					<li><span class="rfc2119-assertion" id="arch-op-extension">Extension
							operation types MAY be chosen by applications.</span> <span
						class="rfc2119-assertion" id="arch-op-extension-iri">Extension
							operation type names MUST be absolute URIs [[!RFC3986]] that
							uniquely identify the type.</span></li>
				</ul>
				</p>
				<table class="def">
					<caption>Well-known Operation Types for the Web of Things</caption>
					<thead>
						<tr>
							<th>Operation Name</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>readproperty</td>
							<td>Identifies the read operation on Property Affordances to
								retrieve the corresponding data.</td>
						</tr>
						<tr>
							<td>writeproperty</td>
							<td>Identifies the write operation on Property Affordances
								to update the corresponding data.</td>
						</tr>
						<tr>
							<td>observeproperty</td>
							<td>Identifies the observe operation on Property Affordances
								to be notified with the new data when the Property was updated.</td>
						</tr>
						<tr>
							<td>invokeaction</td>
							<td>Identifies the invoke operation on Action Affordances to
								perform the corresponding action.</td>
						</tr>
						<tr>
							<td>subscribeevent</td>
							<td>Identifies the subscribe operation on Event Affordances
								to be notified by the Thing when the event occurs.</td>
						</tr>
						<tr>
							<td>unsubscribeevent</td>
							<td>Identifies the unsubscribe operation on Event
								Affordances to stop the corresponding notifications.</td>
						</tr>
					</tbody>
				</table>
				<p class="ednote">As of this specification, the well-known
					operation types form a fixed set that results from the WoT
					interaction model. Other specifications may define further
					well-known operation types that are valid for their respective
					document format or form serialization. Updates to this
					specification may set up an IANA registry in the future to enable
					extensibility and a more generic Web form model that may be applied
					beyond WoT specifications.</p>
				<p>The request method MUST identify one method of the standard
					set of the protocol identified by the submission target URI scheme.
				</p>
				<p>Form fields may further specify the request expected by the
					server for the given operation. Form fields may depend on the
					protocol used for the submission target. Examples are HTTP header
					fields, CoAP options, the protocol-independent Media Type(s) for
					the submission payload, or information about the expected response.
				</p>
			</section>
		</section>
		<section>
			<h2>Protocol Bindings</h2>
			<p>A Protocol Binding is set of mapping rules from an Interaction
				Affordance to concrete messages of a specific protocol such as HTTP
				[[!RFC7231]], CoAP [[!RFC7252]], or MQTT [[!MQTT]]. The Protocol
				Bindings follow the Uniform Interface constraint of REST [[?REST]].
			</p>
			<section>
				<h3>Hypermedia-driven</h3>
				<p>
					<span class="rfc2119-assertion" id="arch-hypermedia">Interaction
						Affordances MUST use hypermedia controls (see <a
						href="#sec-hypermedia-controls"></a>) to describe their usage.
					</span> <span class="rfc2119-assertion" id="arch-hypermedia-origin">The
						hypermedia controls MUST originate from the Thing providing the
						corresponding Interaction Affordance.</span> This enables a loose
					coupling between Things and clients, allowing for an independent
					lifecycle and evolution. <span class="rfc2119-assertion"
						id="arch-hypermedia-caching">The hypermedia controls MAY be
						cached outside the Thing and used for offline processing if
						correspoding cacheing metadata is available to determine the
						freshness.</span>
				</p>
			</section>
			<section>
				<h3>URIs</h3>
				<p>
					<span class="rfc2119-assertion" id="arch-uri-scheme">Eligible
						protocols for the Web of Things MUST have an associated URI scheme
						that is registered with IANA [[!RFC4395]].</span> Hypermedia controls
					rely on URIs to identify target resources and submission targets.
					Thereby, the URI scheme (the first component up to ":") identifies
					the communication protocol to be used for interaction with the
					Thing. The Web of Things refers to these protocols as <a>transfer
						protocols</a>.
				</p>
			</section>
			<section>
				<h3>Standard Set of Methods</h3>
				<p>
					<span class="rfc2119-assertion" id="arch-methods">Eligible
						protocols for the Web of Things MUST be based on a standard set of
						methods that can be shared a priori.</span> The standard set of methods
					makes messages self-descriptive to enable intermediate processing
					of interactions, for instance by proxies or to translate between
					Protocol Bindings [[?REST]]. Furthermore, it allows clients to have
					application-agnostic protocol stack, avoiding Thing-specific code
					or plugins.
				</p>
			</section>
			<section>
				<h3>Media Types</h3>
				<p>
					<span class="rfc2119-assertion" id="arch-media-type">All
						data (a.k.a. content) exchanged within Interaction Affordances
						MUST be identified by a Media Type [[!RFC6838]].</span> Media Types are
					IANA-managed labels to identify representation formats, for
					instance
					<code>application/json</code>
					for JSON [[!RFC7159]] or
					<code>application/cbor</code>
					for CBOR [[!RFC7049]].
				</p>
				<p>
					Note that many Media Types only identify a generic serialisation
					format that does not provide further semantics for its elements
					(e.g., XML, JSON, CBOR). <span class="rfc2119-assertion"
						id="arch-schema">Thus, the corresponding Interaction
						Affordances SHOULD declare a data schema to provide more detailed
						semantic metadata for the data exchanged.</span>
				</p>
			</section>
		</section>
	</section>

	<section id="sec-building-blocks">
		<h1>WoT Building Blocks</h1>
		<p>
			<em>This section is normative.</em>
		</p>
		<p>The Web of Things building blocks allow the implementation of
			systems that conform with the abstract WoT Architecture. The
			specifics of these building blocks are defined in separate documents;
			this chapter provides an overview and a summary.
		<p>
			The WoT Building Blocks support each of the architectural aspects of
			a Thing discussed in <a href="#sec-arch-aspects"></a> and diagrammed
			in <a href="#arch-aspects"></a>. The building blocks themselves are
			shown in <a href="#arch-thing-with-scripting"></a>.
		<figure id="arch-thing-with-scripting">
			<img src="images/wot-thing-with-scripting.png" />
			<figcaption>Thing with WoT Building Blocks, including
				the WoT Scripting API</figcaption>
		</figure>
		</p>
		<p>The WoT Thing Description contains metadata describing the
			affordances of the Thing, the mapping of these affordances onto
			concrete network protocols, and the public security metadata needed
			by authorized users to access the Thing. For specifying behavior, an
			optional WoT Scripting API is provided which supports the definition
			and consumption of WoT Thing Descriptions. This is useful when the
			application behavior is defined in a scripting language.</p>
		<p>
			It is also possible, as shown in <a
				href="#arch-thing-without-scripting"></a>, to use the WoT Thing
			Description to described a device or service that does not use the
			WoT Scripting API. There are two cases where this may be important:
			pre-existing "brownfield" devices for which we are providing a Thing
			Description in order to allow them to interoperate with other
			elements of a WoT system; and devices which need to use a programming
			language not supported by the WoT Scripting API.
		<figure id="arch-thing-without-scripting">
			<img src="images/wot-thing-without-scripting.png" />
			<figcaption>Thing with WoT Building Blocks, without the
				WoT Scripting API</figcaption>
		</figure>
		</p>

		<section id="sec-thing-description">
			<h2>WoT Thing Description</h2>
			<p>The WoT Thing Description document [[?wot-thing-description]]
				defines an information model based on a semantic vocabulary and a
				JSON-based represenation format to provide rich metadata for Things
				in a machine-understandable way. Both information model and
				represenation format are aligned with Linked Data [[?LINKED-DATA]],
				so that besides raw JSON processing, implementations may choose to
				make use of JSON-LD [[?JSON-LD11]] and graph databases to enable
				powerful semantic processing of the metadata.</p>
			<p>
				A <a>Thing Description</a> (TD) describes Thing instances with
				general metadata such as name and id, interaction metadata based on
				the interaction model defined in <a href="#interaction-model"></a>,
				and relation metadata through links to related Things or other
				documents on the Web. The TD can be seen as the <i>index.html
					for Things</i>, as it provides the entry point to learn about the
				provided services and related resources, both of which are described
				using hypermedia controls.
			</p>
			<p>Ideally, the TD is hosted by the Thing itself and retrieved
				upon discovery. Yet it can also be hosted externally when a Thing
				has resource restrictions (e.g., limited memory space) or when an
				existing device is retrofitted to become part of the Web of Things.
				A common pattern is to cache TDs in a directory to improve discovery
				(e.g., in constrained networks) and facilitate device management.
				Also clients should use TD caching when they are paired with a
				Thing, meaning that they are able to fetch a fresh TD represenation
				in case the Thing is updated.</p>
			<p>
				For semantic interoperability, <a>TDs</a> must make use of a
				domain-specific vocabulary, for which explicit extension points are
				provided. However, any domain-specific vocabulary is out-of-scope of
				the W3C standardization activity.
			</p>
			<p class="ednote">This document should point to iot.schema.org,
				but would need a good reference.</p>
			<p>
				Overall, the WoT Thing Description building block fosters
				interoperability in two ways: First, and foremost, <a>TDs</a> enable
				machine-to-machine communication in the Web of Things. Second, <a>TDs</a>
				can serve as a common, uniform format for developers to document and
				retrieve all details necessary to access IoT devices and make use of
				their data.
			</p>
		</section>
		<section id="sec-binding-templates">
			<h3>WoT Binding Templates</h3>
			<p>
				The IoT uses a variety of protocols for accessing devices, since no
				one protocol is appropriate in all contexts. Thus, a central
				challenge for the Web of Things is to enable interactions with the
				plethora of different <a>IoT platforms</a> (e.g., OCF, oneM2M, OMA
				LWM2M, OPC UA) and RESTful devices that do not following any
				particular standard, but provide an elidigle interface over HTTP or
				CoAP. WoT is tackling this variety through Protocol Bindings, which
				must meet a number of constraints (see <a href="#protocol-bindings"></a>).
			</p>
			<p>
				The non-normative WoT Binding Templates document
				[[?wot-binding-templates]] provides a collection of communication
				metadata blueprints that explain how to interact with different <a>IoT
					platforms</a>. When describing a particular device, the <a>Binding
					Template</a> for the corresponding <a>IoT Platform</a> can be used to
				look up the necessary information that must be provided in the <a>Thing
					Description</a>.
			</p>
			<figure id="fig-binding-templates">
				<img src="images/binding-templates.png" style="width: 800px;" />
				<figcaption>From Binding Templates to Protocol Bindings</figcaption>
			</figure>
			<p>
				<a href="#fig-binding-templates"></a> shows how <a>Binding
					Templates</a> are applied. A <a>WoT Binding Template</a> is created
				only once for each <a>IoT Platform</a> and can then be reused in all
				<a>TDs</a> for devices of that platform. Clients consuming a <a>TD</a>
				must implement the corresponding <a>Protocol Binding</a> by
				including a corresponding protocol stack and configuring the stack
				(or its messages) according to the information given in the <a>TD</a>.
				The communication metadata of Protocol Bindings spans five
				dimensions:
			</p>
			<ul>
				<li><b>IoT Platform:</b> <a>IoT Platforms</a> often introduce
					proprietary modifications at the application layer such as
					platform-specific HTTP header fields or CoAP options. Forms (see <a
					href="sec-hypermedia-forms"></a>) may contain the necessary
					information to apply these tweaks in additional form fields defined
					for the application-layer protocol used.</li>
				<li><b>Media Type:</b> <a>IoT Platforms</a> often differ in the
					representation formats (or serializations) used for exchanging
					data. The Media Type [[!RFC6838]] identifies these formats, while
					parameters may specify them further. Forms may contain the Media
					Type and optional parameters in additional form fields.</li>
				<li><b>Transfer Protocol:</b> The Web of Things uses the term <a>transfer
						protocol</a> for the underlying, standardized application layer
					protocol without application-specific options or subprotocol
					mechanisms. The URI scheme of the form submission target contains
					the necessary information to identify the transfer protocol, e.g.,
					HTTP, CoAP, or WebSockets.</li>
				<li><b>Subprotocol:</b> Transfer protocols may have extension
					mechanisms that must be known to interact successfully. Such <a>subprotocols</a>
					cannot be identified from the URI scheme and must be declared
					explicitly. Examples are the push notification workarounds for HTTP
					such as long polling [[?RFC6202]] or Server-Sent Events
					[[!EVENTSOURCE]]. Forms may contain the necessary information to
					identify the subprotocol in additional form fields.</li>
				<li><b>Security:</b> Security mechanisms can be applied at
					different layers of the communication stack and might be used
					together, often to complement each other. Examples are (D)TLS
					[[!RFC5246]]/[[!RFC6347]], IPSec [[!RFC6071]], OAuth [[!RFC6749]],
					and ACE [[!RFC7744]]. Due to the cross-cutting nature of security,
					the necessary information to apply the right mechanism may be given
					within the general metadata of the Thing.</li>
			</ul>
		</section>
		<section>
			<h3>WoT Scripting API</h3>
			<p>The non-normative WoT Scripting API document proposes a
				programming interface that allows scripts to discover and consume
				(retrieve) Thing Descriptions, instantiate local objects that act as
				a proxy for remote Things and their Interaction Affordances
				(Properties, Actions, and Events). It also allows scripts to specify
				and implement Interaction Affordances and expose Things.</p>
			<p>
				The <a>Scripting API</a> is an optional "convenience" building block
				in WoT and it is typically used in network nodes that are able to
				host a full WoT Runtime, for instance gateways or more powerful IoT
				devices.
			</p>
			<p>
				The <a href="https://w3c.github.io/wot-scripting-api/">Scripting
					API specification</a> describes a low level <a
					href="https://www.ecma-international.org/default.htm">ECMAScript</a>
				API that follows the <a
					href="https://w3c.github.io/wot-thing-description">Thing
					Description specification</a> closely. Other, simpler APIs may be
				implemented on top of it. Other runtime systems (e.g., Python, Lua,
				etc.) may also mimic this API, but in principle any WoT scripting
				API can be defined and used, as long as the Interaction Affordances
				are presented through valid Protocol Bindings.
			</p>
			<p>
				The current reference implementation of the <a>Scripting API</a> is
				the open-source <a href="https://github.com/eclipse/thingweb.node-wot">Eclipse
					ThingWeb (node-wot)</a> project. This API is the only one at the moment
				that ensures "de facto" portability of WoT scripts. Other,
				proprietary implementations of the <a>Scripting API</a> exist as
				well and have been tested against node-wot during Working Group
				PlugFests.
			</p>
		</section>
		<section>
			<h3>WoT Security and Privacy Guidelines</h3>
			<p>
				<em>This section contains recommendations and is non-normative.</em>
			</p>

			<p class="ednote" title="TODO">Explain how to use and apply
				guidelines.</p>
		</section>
	</section>

	<section>
		<h1>Servient Implementation</h1>
		<p>
			<em>This section describes an implementation and is
				non-normative.</em>
		</p>

		<p class="ednote" title="TODO">
			This section needs to be revised and aligned with the new <a
				href="#sec-wot-architecture"></a>.
		</p>
		<p>
			A <a>Servient</a> is a software stack that implements the WoT
			building blocks presented in the previous section. <a>Servients</a>
			can host and expose <a>Things</a> and/or consume <a>Things</a>. Thus,
			<a>Servients</a> can perform in both the server and client roles; the
			name (a portmanteau of server and client) is based on this dual role.
		</p>
		<p>
			The chapter <a href="#sec-building-blocks"></a> shows how the WoT
			building blocks conceptionally relate to each other and to the 
                        key architectural aspects introduced in chapter <a href="sec-arch-aspects"></a>.
                        When implementing these concepts, an even more detailed view is necessary that
			takes certain technical aspects into account. The detailed
			architecture of a <a>Servient</a> shown in 
                        <a href="#architecture-implementation"></a> 
                        diagrams some additional details, such as the WoT Runtime
                        (a container for executing the application logic and maintaining private state
                        using the WoT Scripting API)
                        and the possible presence of system APIs.
		</p>
		<figure id="architecture-implementation">
			<img src="images/architecture-implementation.png"
				style="width: 640px;" />
			<figcaption>Implementation View of a Servient</figcaption>
		</figure>
		<p>
			The role and functionality of each module shown in <a
				href="#architecture-implementation"></a> is as follows:
		</p>

		<section>
			<h2>Application</h2>
			<p>
				<a>Applications</a> running on a <a>Servient</a> may be
				implemented through scripts and the WoT Scripting API.
                                The application scripts must be provided along with private data,
                                including security metadata that defines
				their <a>Execution Environment</a> and consequently how scripts must
				be isolated. The security metadata also needs to include keying
				material or certificates to authenticate the <a>Things</a> the
				script exposes.
			</p>
			<p>
				However, the <a>WoT Scripting API</a> building block is optional.
				There can be alternative <a>Servient</a> implementations where
				applications are implemented natively for the software stack. 
                                These alternative implementations do not have the <a>Scripting API</a> but still need 
                                a custom "application logic" component in place of the WoT Runtime
                                to manage application logic and private state.
                                Such custom application logic may or may not be able to expose or consume TDs.
                                If such an implementation cannot itself expose a TD,
                                it may still be able for it to participate in the WoT
                                if a TD can be provided for it via an external mechanism.
                                Such a use case will be typical of "brownfield" IoT devices retro-fitted with TDs.
			</p>
			<section id="native-impl">
				<h3>Native platform API</h3>
				<!--<p class="ednote" title="TODO">Explain native implementation
					against custom API in programming language of choice.</p>-->
				<p>
                                A servient's application logic may also be implemented using a custom (native) API.
				There are various reasons why application might be implemented without 
                                using <a>Scripting API</a>, includig but not limited to:
				</p>
				<ul>
					<li>Due to limited computing resources, a developer can't use a
						rich software stack or a fully-featured scripting engine.</li>
					<li>To cooperate with other functions or applications,
						the developer may have to use platform specific functions or libraries.</li>
					<li>The developer may need to build on top of an existing implementation.</li>
				</ul>
				<p>
					Because the semantics of <a>Thing Description</a> are well-defined,
					developers can still develop their own application by parsing <a>TDs</a> and
					interacting with other WoT Things as specified using their own native platform API.
                                        Moreover, developers can reuse existing services
                                        by creating TDs in the proper configuration for those services.
				</p>
			</section>
			<section>
				<h3>WoT Scripting API</h3>
				<p>
					The standardized <a>WoT Scripting API</a> is the contract between
					applications and the runtime system of a <a>Servient</a>, the
					so-called <a>WoT Runtime</a>. 
<!-- Let's discuss this later under Security Considerations? 
                                        The <a>WoT Scripting API</a> is
					equivalent to any platform API, and hence there must be mechanisms
					to prevent malicious access to the system. 
-->
                                        As mentioned above, this
					building block, including the underlying WoT Runtime
					implementation, is optional.
				</p>
				<p>
					The <a>WoT Scripting API</a> is an optional building block that
					eases IoT application development. Traditionally, device logic is
					implemented in firmware, which underlies the productivity
					constraints of embedded development. The <a>WoT Scripting API</a>
					enables having a runtime system for IoT applications similar to a
					Web browser, and aims to improve productivity and reduce
					integration costs. Furthermore, standardized APIs enable
					portability for application modules, for instance, to move
					compute-intense logic from a device up to a local gateway, or to
					move time-critical logic from the cloud down to a gateway or edge
					node.
				</p>
				<p>
					The <a>Scripting API</a> is built on top of the <a>Thing</a>
					abstraction and the TD <a>Interaction Model</a>. There are three
					sub APIs:
				</p>
				<ul>
					<li><b><code>WoT</code> object</b> as API entry point to
						discover, consume, and expose <a>Things</a></li>
					<li><b><code>ConsumedThing</code> interface</b> as Client API
						to consume <a>Things</a> over the network or locally (e.g.,
						physically attached hardware)</li>
					<li><b><code>ExposedThing</code> interface</b> as Server API
						to configure and expose <a>Things</a> over the network</li>
				</ul>
				<p>
					See <a href="https://w3c.github.io/wot-scripting-api/">WoT
						Scripting API</a> for details.
				</p>
			</section>
		</section>
		<section>
			<h2>WoT Runtime</h2>
			<p>
				The <a>Thing</a> abstraction and <a>Interaction Model</a> is
				implemented in a runtime system that offers the application-facing <a>WoT
					Scripting API</a>. This <a>WoT Runtime</a> interfaces with the <a>Protocol
					Bindings</a> to access remote <a>Things</a> and with the system API to
				access local hardware and proprietary means for communication. Note
				that both local hardware and devices behind proprietary
				communications protocols are also represented as <a>Things</a> in
				the runtime environment, that is, they are also accessed through the
				<a>Client API</a>. The <a>WoT Runtime</a> is also tasked with
				generating the <a>Thing Description</a> based on the <a>Servient</a>
				metadata (e.g., location), application metadata (e.g., <a>Interaction
					Affordance</a>), and available <a>Protocol Bindings</a> (e.g.,
				implemented <a>WoT Binding Templates</a>).
			</p>
			<p>The "WoT Runtime" functionally realizes operations based on
				interaction model described in Thing Descriptions, and is the
				central functionality of a WoT Servient. Based on a Thing
				Description, the WoT Runtime instantiates ExposedThing and
				ConsumedThings in a WoT Servient, and they provide functions used by
				applications, proxies and devices to serve as server's and/or
				client's roles. For example, when a WoT Servient is a device, an
				ExposedThing gets instantiated based on the device's Thing
				Description.</p>
		</section>
		<section>
			<h2>Life Cycle Management</h2>
			<p>Regarding the operations to manage the lifecycle of an
				ExposedThing such as retrieving and/or serving Thing Descriptions,
				instantiating an ExposedThing based on the Thing Descriptions and
				terminating an ExposedThing, the details of the operation vary among
				different kind of devices. The WoT Servient Life Cycle Management
				(LCM) encapsulates those lifecycle operations. It uses internal
				interfaces to realize the lifecycle management of ExposedThings. The
				LCM is an application that runs on top of the WoT Runtime. The WoT
				Scripting API is one implementation of such an internal interface
				that includes functionality to realize the lifecycle management of
				ExposedThings.</p>
			<p>
				When a WoT Servient is an application or a proxy, the lifecycle
				management of ConsumedThings are realized in the same manner as that
				of ExposedThings. The WoT Runtime provides an interface to operate
				on the interaction model. This interface is defined as an abstract
				interface.
				<!-- (the "Abstract Interface" in the figure [TDB?]). -->
				For this abstract interface to be used to interact with other WoT
				Servients or Web Server/Clients in practice, concrete bindings to
				underlying protocols need to be selected and used. It is the REST
				protocol that is most commonly used as the WoT interface on the Web.
				Other protocols such as CoAP, MQTT and WebSocket are also commonly
				used, and the protocol bindings enable the use of those protocols to
				interact with other Web Servients and Web Servers/Clients.
			</p>
			<p>Note that Web Servers and Clients are "Web Objects" that can
				directly interact with WoT Servients through the WoT interface even
				though they are not designed on the WoT interaction model. The
				overwhelming majority of existing sensors and devices are not
				implemented as Web Objects. The Device interface adapter represents
				the functionality to translate the native interface of those diverse
				kind of devices to/from the Abstract interface. As for the
				interfaces to existing devices, there are standards in each domain
				such as Home, Building and Factory. Moreover, the standards adopted
				by nations and even regions are often different, adding more
				complexity. Although in the future a framework for native protocol
				translation may be considered that eases the development of such
				translation work, it is not in the scope of the current WoT charter,
				therefore, the translation functionality is just called the "Device
				interface adapter".</p>
		</section>
		<section>
			<h2>Protocol Bindings</h2>
			<p>
				<a>Protocol Bindings</a> are implementations of the <a>Binding
					Templates</a>. They produce the messages to interact with <a>Things</a>
				over the network based on the information given in the <a>Thing
					Description</a> of the <a>Consumed Thing</a>. <a>Servients</a> usually
				have multiple <a>Protocol Bindings</a> to enable interaction with
				different <a>IoT Platforms</a>.
			</p>
			<p>
				In many cases, where standard protocols are used, generic protocol
				stacks can be used to produce the platform-specific messages (e.g.,
				one for HTTP(S) dialects, one for CoAP(S) dialects, and one for MQTT
				solutions, etc.). In this case, the communication metadata from the
				<a>Thing Description</a> is used to select and configure the right
				stack (e.g., HTTP with the right header fields or CoAP with the
				right options). Parsers and serializers for the expected
				representation format identified by the Internet Media Type can also
				be shared across these generic protocol stacks.
			</p>
			<p>
				In some cases, where no aspects can be shared, the <a>Protocol
					Binding</a> is more comparable to a platform-specific driver that is
				selected and configured through the communication metadata in
				similar way as above.
			</p>
			<p>
				See <a href="https://w3c.github.io/wot-binding-templates/">WoT
					Binding Templates</a> for details.
			</p>
		</section>
		<section>
			<h2>System API</h2>
			<p>
				The implementation of a <a>Thing</a> may access local hardware or
				system services (e.g. storage) through proprietary APIs or other
				means. This block is out of scope of WoT standardization.
			</p>
			<p>
				A <a>WoT Runtime</a> may provide local hardware or system services
				to application scripts through the <a>Thing</a> abstraction, as if
				they were accessible over a network protocol. In this case the
				implementation should be optimized to avoid the overhead that would
				be involved in a literal implementation of a network protocol while
				maintaining a consistent <a>WoT Interface</a>. The details of such
				"System Things" are out of the scope of standardization at present,
				although W3C WoT will document several informational examples.
			</p>
			<p>
				A device may be physically external to a <a>Servient</a>, but
				connected via proprietary protocols. In this case, the implemented
				runtime environment may access legacy devices with such protocols
				(e.g., Echonet Lite, X10, I2C, SPI) through proprietary APIs, but
				again exposes them to applications as <a>Things</a> through the <a>Scripting
					API</a>. A script can then act as gateway to the legacy devices. This
				should only be done if the legacy device cannot be described using
				the <a>WoT Thing Description</a>.
			</p>
		</section>
		<section>
			<h3>Inter Connection of Servients</h3>
			<p>This section describes below how to inter connect among the
				servients.</p>

			<section>
				<h3>Inter connection between application and device servients</h3>
				<p>First, inner structure of a servient is explained based on
					the structure of an application servient and a device servient. WoT
					runtime defines an abstract interface that contains methods such as
					READ, WRITE, INVOKE, SUBSCRIBE, NOTIFY through which to access
					devices. When a servient communicates over a network, those methods
					are bound to concrete protocols. For example, in the case of HTTP,
					HTTP methods such as PUT and GET are assigned to implement the
					abstract methods. WoT clients can retrieve and change device
					settings or device attributes defined in TDs through those abstract
					methods. In a device servient, WoT Servient Life Cycle Management
					(S-LCM) creates an ExposedThing based on TD. S-LCM also advertises
					a TD to other servients, or provides other servients with a TD upon
					request. A device servient's functions are usually implemented as
					hardware, and those functions are accessible through its firmware.
					An ExposedThing's abstract interface is translated into hardware
					commands by a device interface adapter. A device interface adapter
					is a custom software developed for each specific type of hardware.
					In an application servient, on the other hand, a S-LCM obtains TDs
					by getting one from location advertised by other servients or
					requesting other servients of TDs, and creates a ConsumedThing
					based on the obtained TD. Functions of an application servient are
					usually implemented as an application. The abstract interface of a
					ConsumedThing is provided as a programming language (such as
					JavaScript) interface, and the application achieves its functions
					by using this interface.</p>
				<figure id="simple-conf-application-device">
					<img src="images/arch-simple-conf-application-device.png" />
					<figcaption>Simple configuration of application and
						device</figcaption>
				</figure>
			</section>
			<section>
				<h3>Inter connection with Proxy Servient</h3>
				<p>Next, inner structure of a servient is explained based on the
					structure of a proxy servient that connects a device servient and
					application servient together.</p>
				<p>A runtime in a proxy servient has both ExposedThing and
					ConsumedThing functionality. A S-LCM, similar to that of an
					application servient, obtains a TD of a device servient, and
					creates a ConsumedThing. At the same time, a S-LCM creates a shadow
					of the device as well as a TD for the shadow device where the
					identifier is a new one and protocol bindings are appropriately
					described to serve for the application. An ExposedThing is created
					based on this TD, and a S-LCM notifies other servients of the TD.</p>
				<figure id="simple-conf-application-proxy-device">
					<img src="images/arch-simple-conf-application-proxy-device.png" />
					<figcaption>Simple configuration with proxy</figcaption>
				</figure>
			</section>
		</section>
	</section>

	<!-- DEPLOYMENT SCENARIOS  -->
	<section id="sec-deployment-scenario">
		<h1>WoT Deployments</h1>
		<p>
			<em>This section is non-normative.</em>
		</p>

		<p>In the previous sections, how WoT servients connect to each
			other and their roles and basic behaviors were described based on two
			simple structures; one with an application and a device, and the
			other with a proxy connecting an application and a device together.
			These simple structures can be used as is for use cases involving
			relatively small numbers of devices. However, they are too simple per
			se to describe those more complex uses cases where the number of
			connected devices are not small, or devices are physically located in
			multiple remote sites. This section illustrates more advanced
			structures that can be applied to those non-simple use cases.</p>

		<p>This section defines components that make a Web of Things
			entity, clarifies each component’s functions, and then shows how a
			web of Things as a whole works. The architecture described here is
			derived from the Web of Things use cases as well as technical
			requirements extracted from them.</p>

		<section id="sec-deployment-cloud-rm">
			<h2>Devices in a Local Network Controlled from a Cloud</h2>
			<p>In smart home cloud service use cases, sensors and home
				appliances connected to a home network are monitored as well as in
				some cases operated by cloud applications. There is a firewall
				between the home network to which the devices are connected and the
				cloud. The WoT servients in this case can communicate each other
				only if the communication successfully goes through the firewall.</p>
			<p>The figure below shows a typical structure that is adopted in
				ITU-T Recommendation Y.2070. As described in previous sections, a
				proxy can aggregate multiple device servients into common
				ExposedThing(s), and provide the applications with a simple access
				interface. For example, even when the connected devices each uses a
				different protocol such as REST, WebSocket and CoAP, the
				ExposedThing can converge them into a single protocol so that
				applications do not need to be aware of the various protocols the
				devices use. In the figure, there are two applications connected to
				a proxy. Those applications use a single protocol (e.g. REST) to
				communicate with the proxy, which makes the development of an
				application much simpler.</p>
			<p>There is a firewall between applications and devices. There is
				a proxy on each side of the firewall; one in the home network and
				the other in the internet. These two proxies work together to tunnel
				all communications to go through the firewall. The local proxy which
				is on the home network side aggregates all connected devices, and
				the remote proxy on the internet side aggregates the applications.
				Applications and devices need to know nothing about the firewall.</p>
			<figure id="deployment-cloud-device">
				<img src="images/arch-deploy-cloud-device-alt.png" />
				<figcaption>TODO: ADD A CAPTION</figcaption>
			</figure>
			<p>Note: An example structure adopted in ITU-T Recommendation
				Y.2070</p>
		</section>
		<section id="sec-deployment-service-to-service-rm">
			<h2>Service-to-Service connections across multiple Domains</h2>
			<p>Once devices can be monitored or operated by cloud
				applications, a variety of services can be built on top of that. For
				example, a cloud application can change a device’s operating
				condition based on analysis of collected data. When the remote proxy
				is a part of a cloud platform servicing applications, an application
				needs to be able to find device information by, for example,
				accessing a directory of connected devices. In the figure below,
				information of all devices connected to the remote proxy via a local
				proxy is registered in a directory. An application needs to obtain
				the information of the device(s) that it needs to communicate with
				to achieve its application functionality. It can do so by querying
				the directory of device information.</p>
			<figure id="deployment-cloud-directory">
				<img src="images/arch-deploy-service-directory-alt.png" />
				<figcaption>Cloud service with directory</figcaption>
			</figure>
			<p>Multiple cloud eco-systems each based on a different platform
				can work together to make a larger, systems-of-systems eco-system.
				Built on the previously discussed structure of a cloud application
				eco-system, the figure below shows two eco-systems connected each
				other to make a system-of-systems. Consider a case in which an
				application servient in one eco-system (i.e. Application Servient A
				in below) uses a device servient in another eco-system (i.e. Device
				Servient B in below). There are more than one mechanisms to achieve
				this cross eco-systems application-device integration. Below, two
				mechanisms of doing this are explained each using a figure to help
				understand how it can be achieved.</p>
			<p>In the first figure below, two directories synchronize device
				information, which makes it possible for Application Servient A to
				obtain the information of Device Servient B through TD directory A.
				As described in previous sections, Remote Proxy Servient B holds a
				shadow device of Device servient B. By obtaining the TD of this
				shadow device, Application servient A is able to use Device Servient
				B through the shadow device on Remote Proxy Servient B.</p>
			<figure id="deployment-service-sync-directory">
				<img src="images/arch-deploy-service-sync-directory-alt.png" />
				<figcaption>Multiple cloud connect through directory
					synchronization</figcaption>
			</figure>
			<p>In the second figure below, two remote proxy servients
				synchronize device information. When a shadow of Device Servient B
				is created in Remote proxy servient B, the shadow’s TD is
				simultaneously synchronized into Remote proxy servient A. Remote
				proxy servient A in turn creates its own shadow of Device servient
				B, and registers the TD to TD directory A. With this mechanism,
				synchronization between TD directories is not necessary.</p>
			<figure id="deployment-service-sync-proxy">
				<img src="images/arch-deploy-service-sync-proxy-alt.png" />
				<figcaption>Multiple cloud connect through proxy
					synchronization</figcaption>
			</figure>
		</section>

	</section>
	<section id="sec-security-considerations">
		<h1>Security and Privacy Considerations</h1>
		<p>
			<em>This section is non-normative.</em>
		</p>

		<p class="ednote">
			This section will likely undergo significant revision and
			reorganization. Please see the <a
				href="https://github.com/w3c/wot-security/">WoT Security and
				Privacy</a> repository for work in progress. In particular, the <a
				href="https://github.com/w3c/wot-security/blob/master/wot-threat-model.md">WoT
				Threat Model</a> defines the main WoT security stakeholders, assets,
			attack surfaces, and threats.
		</p>
		<p>The functional WoT architecture should enable the use of best
			practices in security and privacy. Generally, the WoT security
			architecture must support the goals and mechanisms of the IoT
			protocols and systems it connects to. These systems vary in their
			security requirements and risk tolerance, so security mechanisms will
			also vary based on these factors. However, the WoT architecture needs
			to do no harm: it should support security and privacy at least as
			well as the systems it connects to.</p>
		<p>Security means the system should preserve its integrity and
			functionality even when subject to attack. Privacy means that the
			system should maintain the confidentiality of personally identifiable
			information. In general, security and privacy cannot be guaranteed
			but the WoT architecture should support best practices.</p>
		<p>Security and privacy are especially important in the IoT domain
			since IoT devices need to operate autonomously and in many cases have
			access to both personal data and/or can be in control of
			safety-critical systems. Compared to personal systems, IoT devices
			are subject to different and in some cases higher risks than IT
			systems. It is also important to protect IoT systems so that they can
			not be used to launch attacks on other computer systems.</p>
		<p class="ednote">
			Security and privacy considerations are still under discussion and
			development; the content below should be considered preliminary. Due
			to the complexity of the subject we are considering producing a
			separate document containing a detailed security and privacy
			considerations discussion including a risk analysis, threat model,
			recommended mitigations, and appropriate references to best
			practices. A summary will be included here. Work in progress is
			located in the <a href="https://github.com/w3c/wot-security/">WoT
				Security and Privacy</a> repository. Please file any security or privacy
			considerations and/or concerns using the <a
				href="https://github.com/w3c/wot-security/issues">GitHub Issue</a>
			feature.
		</p>
		<p>
			<!-- Security requirements for the the WoT -->
			Security is a cross-cutting issue that needs to be taken into account
			in all <a href="#sec-building-blocks">WoT building blocks</a> . The
			W3C WoT does not define any new security mechanisms, but provides
			guidelines to apply the best practices from Web security, IoT
			security, and information security for general software and hardware
			considerations.
		</p>
		<p>
			The <a>WoT Thing Description</a> must be used together with integrity
			protection mechanisms and access control policies. Users must ensure
			that no sensitive information is included in the <a>TDs</a>
			themselves.
		</p>
		<p>
			The <a>WoT Binding Templates</a> must correctly cover the security
			mechanisms employed by the underlying <a>IoT Platform</a> . Due to
			the automation of network interactions necessary in the IoT,
			operators need to ensure that <a>Things</a> are exposed and consumed
			in a way that is compliant with their security policies.
		</p>
		<section id="sec-security-consideration-runtime-risks">
			<h2>WoT Runtime Security and Privacy Risks</h2>
			<p>
				The <a>WoT Runtime</a> implementation for the <a>WoT Scripting
					API</a> must at least have mechanisms to prevent malicious access to
				the system and isolate scripts in multi-tenant <a>Servients</a> .
				More specifically the <a>WoT Runtime</a> implementation for the <a>WoT
					Scripting API</a> should take into account the below security and
				privacy risks and implement the recommended mitigations.
			</p>
			<section id="sec-security-consideration-cross-script">
				<h5>Cross-Script Security and Privacy Risk</h5>
				<p>
					In basic WoT setups, all scripts running inside the <a>WoT
						Runtime</a> are considered trusted, and therefore there is no strong
					need to perform strict isolation between each running script
					instance. However, depending on device capabilities and deployment
					use case scenario risk level it might be desirable to do so. For
					example, if one script handles sensitive privacy-related data and
					well-audited, it might be desirable to separate it from the rest of
					the script instances to minimize the risk of data exposure in case
					some other script inside WoT gets compromised during runtime.
					Another example is mutual co-existence of different tenants on a
					single WoT device. In this case each WoT runtime instance will be
					hosting a different tenant, and isolation between them is required.
				</p>
				<dl>
					<dt>Mitigation:</dt>
					<dd>
						The WoT runtime should perform isolation of script instances and
						their data in cases when scripts handle privacy-related or other
						critical security data. Similarly, the <a>WoT Runtime</a>
						implementation should perform isolation of <a>WoT Runtime</a>
						instances and their data if a WoT device has more than one tenant.
						Such isolation can be performed within the <a>WoT Runtime</a>
						using platform security mechanisms available on the device. For
						more information see Sections "WoT Servient Single-Tenant" and
						"WoT Servient Multi-Tenant" of [[!WOT-SECURITY-CONSIDERATIONS#]].
					</dd>
				</dl>
			</section>
			<section id="sec-security-consideration-device-direct-access">
				<h5>Physical Device Direct Access Security and Privacy Risk</h5>
				<p>In case a script is compromised or misbehaving, the
					underlying physical device (and potentially surrounded environment)
					can be damaged if a script can use directly exposed native device
					interfaces. If such interfaces lack safety checks on their inputs,
					they might bring the underlying physical device (or environment) to
					an unsafe state (i.e. device overheats and explodes).</p>
				<dl>
					<dt>Mitigation:</dt>
					<dd>
						The <a>WoT Runtime</a> should avoid directly exposing the native
						device interfaces to the script developers. Instead a <a>WoT
							Runtime</a> implementation should provide a hardware abstraction
						layer for accessing the native device interfaces. Such hardware
						abstraction layer should refuse to execute commands that might put
						the device (or environment) to an unsafe state. Additionally, in
						order to reduce the damage to a physical WoT device in cases a
						script gets compromised, it is important to minimize the number of
						interfaces that are exposed or accessible to a particular script
						based on its functionality.
					</dd>
				</dl>
			</section>
			<section id="sec-security-consideration-update-provisioning">
				<h5>Provisioning and Update Security Risk</h5>
				<p>
					If the <a>WoT Runtime</a> implementation supports
					post-manufacturing provisioning or updates of itself, WoT scripts,
					or any related data (including security credentials), it can be a
					major attack vector. An attacker can try to modify any above
					described element during the update or provisioning process or
					simply provision attacker's code and data directly.
				</p>
				<dl>
					<dt>Mitigation:</dt>
					<dd>
						Post-manufacturing provisioning or update of scripts, the <a>WoT
							Runtime</a> itself or any related data should be done in a secure
						fashion. A set of recommendations for secure update and
						post-manufacturing provisioning can be found in
						[[!WOT-SECURITY-CONSIDERATIONS]].
					</dd>
				</dl>
			</section>
			<section id="sec-security-consideration-credentials-storage">
				<h5>Security Credentials Storage Security and Privacy Risk</h5>
				<p>
					Typically the <a>WoT Runtime</a> needs to store the security
					credentials that are provisioned to a WoT device to operate in WoT
					network. If an attacker can compromise the confidentiality or
					integrity of these credentials, then it can obtain access to the
					WoT assets, impersonate WoT things or devices or create
					Denial-Of-Service (DoS) attacks.
				</p>
				<dl>
					<dt>Mitigation:</dt>
					<dd>
						The <a>WoT Runtime</a> should securely store the provisioned
						security credentials, guaranteeing their integrity and
						confidentiality. In case there are more than one tenant on a
						single WoT-enabled device, a <a>WoT Runtime</a> implementation
						should guarantee isolation of each tenant provisioned security
						credentials. Additionally, in order to minimize a risk that
						provisioned security credentials get compromised, the <a>WoT
							Runtime</a> implementation should not expose any API for scripts to
						query the provisioned security credentials.
					</dd>
				</dl>
			</section>
		</section>
	</section>
	<section class="appendix">
		<h1>Example Sequences of interaction patterns</h1>
		<p>
			<em>This section is non-normative.</em>
		</p>
		<p>This section illustrates example sequences of interaction
			patterns such as read propery, invoke action and event, among WoT
			client and WoT server.</p>
		<p>For the sake of simplicity, remote and local proxies between
			client and server are omitted from following sequences.</p>
		<section>
			<h2>Property</h2>
			<section>
				<h3>Read property (binding = HTTP)</h3>
				<p>Following sequence illustrates example sequence of read
					property operation with HTTP binding.</p>
				<p>
					<img src="images/message-flows/A_1_1_readProperty.png"
						alt="Read property               (binding = HTTP)" />
				</p>
			</section>
			<section>
				<h3>Write property (binding = HTTP)</h3>
				<p>Following sequence illustrates example sequence of write
					property operation with HTTP binding.</p>
				<p>
					<img src="images/message-flows/A_1_2_writeProperty.png"
						alt="Write               property (binding = HTTP)" />
				</p>
			</section>
			<section>
				<h3>Observe property (binding = HTTP Long Polling)</h3>
				<p>Following sequence illustrates example sequence of observe
					property operation with HTTP Long Polling binding.</p>
				<p>
					<img src="images/message-flows/A_1_3a_observePropertyLongPoll.png"
						alt="Observe property (binding = HTTP Long Polling)" />
				</p>
			</section>
			<section>
				<h3>Observe property (binding = HTTP Server Sent Event)</h3>
				<p>Following sequence illustrates example sequence of observe
					property operation with HTTP Server Sent Event binding.</p>
				<p>
					<img src="images/message-flows/A_1_3b_observePropertySSE.png"
						alt="Observe property (binding = HTTP Server Sent Event)" />
				</p>
			</section>
			<section>
				<h3>Observe property (binding = Simple WebSocket)</h3>
				<p>Following sequence illustrates example sequence of observe
					property operation with simple WebSocket binding.</p>
				<p>
					<img src="images/message-flows/A_1_3c_observePropertyWebSocket.png"
						alt="Observe property (binding = simple WebSocket)" />
				</p>
			</section>
		</section>
		<section>
			<h2>Action</h2>
			<section>
				<h3>Invoke action (binding = HTTP)</h3>
				<p>Following sequence illustrates example sequence of invoke
					action operation with HTTP binding, where operation is synchronous
					and the request to server is blocked until action completes.</p>
				<p>
					<img src="images/message-flows/A_2_1_invokeAction.png"
						alt="Invoke action               (binding = HTTP)" />
				</p>
				<p>Note: Action with asynchronous operation is subject to
					further study.</p>
			</section>
		</section>
		<section>
			<h2>Event</h2>
			<section>
				<h3>Subscribe, notify and unsubscribe event (binding = HTTP
					Long Polling)</h3>
				<p>Following sequence illustrates example sequence of subscribe,
					notify and unsubscribe event operation with HTTP Long Polling
					binding.</p>
				<p>
					<img src="images/message-flows/A_3_1a_eventLongPoll.png"
						alt="Subscribe,               notify and unsubscribe event (binding = HTTP Long               Polling)" />
				</p>
			</section>
			<section>
				<h3>Subscribe, notify and unsubscribe event (binding = HTTP
					Server Sent Event)</h3>
				<p>Following sequence illustrates example sequence of subscribe,
					notify and unsubscribe event operation with HTTP Server Sent Event.</p>
				<p>
					<img src="images/message-flows/A_3_1b_eventSSE.png"
						alt="Subscribe,               notify and unsubscribe event (binding = HTTP Server Sent               Event)" />
				</p>
			</section>
			<section>
				<h3>Subscribe, notify and unsubscribe event (binding = Simple
					WebSocket)</h3>
				<p>Following sequence illustrates example sequence of subscribe,
					notify and unsubscribe event operation with simple WebSocket
					binding.</p>
				<p>
					<img src="images/message-flows/A_3_1c_eventWebSocket.png"
						alt="Subscribe,               
						notify and unsubscribe event (binding = simple WebSocket)" />
				</p>
			</section>
		</section>
	</section>
	<section class="appendix">
		<h1>SNIPPETS: (was WoT Deployment Scenarios and Guidelines)</h1>
		<p class="ednote">This section contains text that became obsolete
			and will be removed before the document will be published.</p>

		<p>There are many possibilities for deploying the abstract WoT
			Architecture and mapping the functions to physical devices and
			network structures. This section, which is informative but not
			normative, lists a number of design patterns that may be used when
			implementing the Web of Things.</p>
		<section>
			<h2>WoT Client</h2>
			<figure id="wot-existing">
				<img src="images/wot-existing.png" style="width: 500px;" />
				<figcaption>Servient Consuming Thing</figcaption>
			</figure>
			<p>
				<a href="#wot-existing"></a> shows the basic scenario, where a <a>Servient</a>
				in client role, a <a>WoT Client</a> , is consuming an existing
				device that is augmented with a <a>Thing Description</a> (TD). The
				latter could be generated from digital descriptions already
				available for the device within the corresponding <a>IoT
					Platform</a> . It could also be written by a developer using tools or
				even manually.
			</p>
			<p>
				The Application Script is loaded and executed by the <a>WoT
					Runtime</a> . Scripts can be manually configured with the URI of the
				device <a>TD</a> located on a reachable Web server. Using the <a>
					<code>WoT</code> object
				</a> , the Application Script retrieves the <a>TD</a> and instantiates a
				corresponding <a>Consumed Thing</a> . The Application Script can use
				the metadata of the <a>Thing</a> and inspect what Interactions it
				provides. The communication metadata within the <a>TD</a> is used by
				the <a>Servient</a> to select the matching <a>Protocol Binding</a>
				and to configure its protocol stack. These communication details are
				hidden from the Application Script. However, the script can only
				interact with the <a>Thing</a> , if the <a>Servient</a> implements a
				<a>Protocol Binding</a> that matches the communication metadata
				given in the <a>TD</a> .
			</p>
			<p>
				Using the <a>Client API</a> (i.e.,
				<code>ConsumedThing</code>
				interface), the Application Script can read or write a <a>Property</a>
				, invoke an <a>Action</a> , or subscribe for <a>Events</a> offered
				by the <a>Thing</a>. The selected <a>Protocol Binding</a> maps these
				Interactions to the low-level protocol operations and serializations
				understood by the remote <a>Thing</a> . When a message is returned
				by the <a>Thing</a> , the <a>Protocol Binding</a> parses the
				response and maps it back to the Interaction abstraction. The
				Interaction output is delivered back to the Application Script by
				resolving a (JavaScript) Promise.
			</p>
			<p class="ednote">Each sub-section shall describe the technical
				details to realize the scenario. They shall describe how to discover
				the involved WoT components, how to realize connectivity, and what
				security mechanisms can be used. For now, the draft only contains
				strawman proposals and placeholders that will be replaced as the
				draft progresses.</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li>Manual (Application Script is configured with TD URI)</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li>Local over (W)LAN or LPWANs (ZigBee, Z-Wave, etc.)</li>
						<li>Remote over globally reachable IP address of the Thing</li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li>Security metadata to sandbox the Application Script</li>
						<li>Access control implemented on the Thing</li>
						<li>Integrity protection when retrieving the TD</li>
						<li>Potentially confidentiality and integrity protection when
							interacting with the Thing</li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<h2>Servient on Device</h2>
			<figure id="wot-on-device">
				<img src="images/wot-on-device.png" style="width: 640px;" />
				<figcaption>Servient on Device Itself</figcaption>
			</figure>
			<p>
				In this case, a <a>Servient</a> is running on the device itself. The
				right most <a>Servient</a> in <a href="#wot-on-device"></a> shows an
				LED Light, whose controller has a powerful CPU and a large memory
				and is able to provide web server functionality connected directly
				to the Internet. Then the leftmost browser and/or another
				application on the internet can access the LED light through the
				Internet directly.
			</p>
			<figure id="wot-on-device-minimal">
				<img src="images/wot-on-device-minimal.png" style="width: 640px;" />
				<figcaption>Resource-constrained Device as Thing</figcaption>
			</figure>
			<p>
				Devices that are not powerful enough to host a <a>Servient</a> can
				still act as <a>Things</a> . In this case, a classic firmware is
				providing a <a>Thing Description</a> that describes the
				functionality and protocols implemented. The right most <a>Servient</a>
				in <a href="#wot-on-device-minimal"></a> shows a legacy device that
				has a constrained CPU and a small memory and is able to provide web
				server functionality connected directly to the internet. Then the
				leftmost browser and/or another application on the internet can
				access the device through the Internet directly like <a
					href="#wot-on-device"></a>.
			</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li>WoT Client discovers <a>Servient</a> on the same network
							[network discovery].
						</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li>(W)LAN</li>
						<li>LPWANs (ZigBee, Z-Wave, etc.)</li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<h2>Servient on Smartphone</h2>
			<p>
				This example uses a <a>Servient</a> running on a Smartphone.
				Smartphones are not only popular but have enough performance to
				provide gateway functionality. This functionality can be used to
				bridge between the internet and a legacy device without any
				intermediate hardware.
			</p>
			<figure id="wot-on-smartphone">
				<img src="images/wot-on-smartphone.png" style="width: 640px;" />
				<figcaption>Servient on Smartphone</figcaption>
			</figure>
			<p>
				shows an example of a <a>Servient</a> on a smartphone, which can act
				as a gateway to existing devices (e.g., via Bluetooth or local
				Wi-Fi). The Web browser with the user interface can either run on
				the smartphone directly or remotely on a separate device (such as a
				laptop).

			</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li>WoT Client discovers an electronic appliance when the
							remote controller is nearby [nearby discovery].</li>
						<li>WoT Client discovers <a>Servient</a> remotely when the
							remote controller is outside [remote discovery].
						</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<h2>Servient on Gateway</h2>
			<figure id="wot-on-gateway">
				<img src="images/wot-on-gateway.png" style="width: 640px;" />
				<figcaption>Servient on Gateway</figcaption>
			</figure>
			<p>
				shows an example of a <a>Servient</a> on a gateway. Gateway are
				often introduced as a home automation and/or home energy management
				solution. In the case of consumer electronics, there are very wide
				variety of physical communication formats such as WiFi, 802.15.4g,
				Bluetooth Low Energy, HDPLC and so on. In order to normalize those
				variations, almost all home automation systems introduce a gateway.
				In , a <a>Servient</a> wraps various mechanisms for communicating
				with legacy devices and provides to other clients a universal device
				accessing method. Inside the home, HTTP/TCP/IP/WiFi can then be used
				as the sole unfied communication method between the <a>Servient</a>
				on the gateway and a user interface device such as a Web broswer.
			</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li><a>Servient</a> discovers electronic appliances nearby
							[nearby discovery].</li>
						<li>WoT Client discovers <a>Servient</a> remotely [remote
							discovery].
						</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<h2>Servient on Cloud and Gateway</h2>
			<p>
				Client Apps can control devices at home through a <a>Servient</a> on
				a gateway. But in this case the location of client apps is
				restricted to the home, because physical communication path "WiFi"
				and/or wired Ethernet between gateway and client apps such as a Web
				browser is limited to the physical domain provided by the WiFi
				signal. To provide for controlling devices at home from outside the
				house, a HTTP/TCP/IP interface to a <a>Servient</a> running in the
				cloud with a globally reachable address could be used. However, in
				this case the <a>Servient</a> in the cloud cannot generally access
				devices running in the home through only local interfaces such as
				Bluetooth.
			</p>
			<figure id="wot-on-cloud">
				<img src="images/wot-on-cloud.png" style="width: 800px;" />
				<figcaption>Servient on Cloud Server and Gateway</figcaption>
			</figure>
			<p>
				shows an example of <a>Servient</a> running on a cloud server paired
				with another <a>Servient</a> running on a gateway. In the case of ,
				a browser accesses the <a>Servient</a> on the cloud Server named
				"Cloud". This <a>Servient</a> provides its interface through the
				Internet globally. So, wherever a browser user is, they can access
				this <a>Servient</a> . The <a>Servient</a> on "Cloud" can accept the
				request of the browser and/or other application through HTTP, CoAP,
				and so on. Then the <a>Servient</a> on the cloud server finds out
				the route to access another <a>Servient</a> on the gateway. After
				finding out the route, the <a>Servient</a> on the cloud server
				transfers the request from the browser to the <a>Servient</a> on the
				gateway. After that, the gateway processes the request according the
				use case. The <a>Thing Description</a> of the <a>Servient</a> on the
				cloud server can be just a mirror of that on the gateway, since it
				will generally just pass interactions directly through. More
				generally, though, one or both <a>Servients</a> can provide services
				such as privacy filtering or sub-setting. When the user is home,
				they can also access the <a>Servient</a> in the gateway directly.
			</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li><a>Servient</a> discovers WoT Server remotely [remote
							discovery].</li>
						<li>WoT Client discovers <a>Servient</a> remotely [remote
							discovery].
						</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<h2>Servient on Cloud Server</h2>
			<figure id="wot-on-cloud-legacy">
				<img src="images/wot-on-cloud-legacy.png" style="width: 800px;" />
				<figcaption>Servient on Cloud Server Only</figcaption>
			</figure>
			<p>
				shows a second example of <a>Servients</a> in the cloud. In this
				case, a browser accesses a <a>Servient</a> on a cloud server,
				similar to . This <a>Servient</a> provides access through the global
				Internet. So, wherever the browser user is, they can access this <a>Servient</a>
				. The cloud <a>Servient</a> accepts the requests of the browser
				and/or other applications through HTTP, CoAP, etc. Then it finds out
				the route to access a proprietry discovery service running on a
				gateway. In , the <a>Servient</a> running in the cloud could talk to
				another <a>Servient</a> running on the gateway. However, many
				service providers have already provided IoT services using
				proprietary IoT interfaces or some other IoT standard. In this case,
				the gateway can still support the same functionalities, as in the
				previous case, but using methods outside of the WoT definitions.
			</p>
			<dl>
				<dt>Discovery</dt>
				<dd>
					<ul>
						<li>Servient1 discovers Servient2 remotely [remote
							discovery].</li>
						<li>Servient2 discovers electronic appliances nearby [nearby
							discovery].</li>
						<li>WoT Client discovers Servient1 remotely [remote
							discovery].</li>
					</ul>
				</dd>
				<dt>Connectivity</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
				<dt>Security</dt>
				<dd>
					<ul>
						<li><span style="color: red">t.b.d.</span></li>
					</ul>
				</dd>
			</dl>
		</section>

		<section>
			<h2>WoT in the Web Browser</h2>
			<p class="ednote">This section is an early outline to realize WoT
				with the existing browser APIs. More details and a native WoT
				integration into the Web browser will be added as the WG drafts
				progress.</p>
			<p>
				<a href="#architecture-browser"></a> shows how a <a>Servient</a>
				implementation for Web browsers would look like.
			</p>
			<figure id="architecture-browser">
				<img src="images/architecture-browser.png" style="width: 640px;">
				<figcaption>Implementing WoT in the Web Browser</figcaption>
			</figure>
			<p>
				The Web browser implicitly isolates applications in tabs using the <a
					href="https://www.w3.org/Security/wiki/Same_Origin_Policy">same-origin
					policy</a>. Thus, the security metadata is not mandatory. The
				application scripts would be part of a Web page that can provide
				visualization and user interaction.
			</p>
			<p>
				The <a>WoT Scripting API</a> needs to be added by a WoT library
				loaded together with the application scripts by the Web page. This
				library would also implement <a>TD</a> handling (i.e., parsing for
				consuming <a>Things</a> and generating for exposing <a>Things</a>)
				and provide glue code to use the browser APIs. The other aspects of
				the <a>WoT Runtime</a> are provided by the browser JavaScript
				runtime system.
			</p>
			<p>
				The <a>Protocol Bindings</a> are limited to the protocols
				implemented by Web browsers. These are:
			</p>
			<ul>
				<li>HTTP(S) (1.0/1.1/2.0) [[!RFC7230]]/[[!RFC7540]] (including
					Server-Sent Events [[!HTML5]]),</li>
				<li>WebSockets [[!RFC6455]] (which enables the WoT library to
					implement MQTT-over-WebSockets and CoAP-over-WebSockets)</li>
				<li>(S)RTP of WebRTC [[!WEBRTC]], and</li>
				<li>FTP [[!RFC765]] (which might be of limited use similar to
					the file protocol)</li>
			</ul>
			<p>
				The other browser APIs (e.g., Geolocation, Vibration, and Web
				Storage) are comparable to the System API of normal <a>Servients</a>
				and can enable access to local hardware.
			</p>
		</section>
	</section>

	<section class="appendix">
		<h2>Acknowledgements</h2>
		<p>Special thanks to all active Participants of the W3C Web of
			Things Interest Group and Working Group for their technical input and
			suggestions that led to improvements to this document.</p>
	</section>
	<!--
    <section class="appendix">
      <h2>Change History</h2>
      <p>
        This is the First Public Working Draft.
      </p>
    </section>
-->
</body>
</html>
